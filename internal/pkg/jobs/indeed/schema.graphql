# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

directive @apollo_studio_metadata(buildId: String, checkId: String, launchId: String) on SCHEMA

"Generic account interface to be implemented by various account types, i.e. Passport or OneLogin"
interface Account {
    "User's account ID"
    id: ID!
}

"Interface to an entity with unique GUID, author and date."
interface AuthoredInterface {
    "Encrypted account ID of original author."
    createdByAccount: ID
    "Date this was created."
    dateCreated: DateTime!
    "Date this was most recently modified."
    dateLastModified: DateTime!
    "The globally unique UUID."
    id: ID!
}

interface AvailabilityResource {
    """

    Settings that define when the resource is available to schedule events.

    Availability settings can not absolutely prevent events that do not match the rules
    from being scheduled on the resource. They are rules that are applied during scheduling
    unless specifically overridden.
    """
    availabilitySettings: ResourceAvailabilitySettings!
    """

    Time periods that the resource is available for scheduling, subject to the
    [availabilityRules] and events that are scheduled on the resource.

    The time periods do not overlap and are not empty.

    The periods may be consecutive. For example:
    period1=2021-01-01T10:00-11:00Z, period2=2021-01-01T11:00-12:00Z
    """
    available(
        "Retrieve edges after this cursor."
        after: String,
        """

        If non-null, override the availability window configured in the resource
        [availabilitySettings].
        """
        availabilityWindow: AvailabilityWindowFilter,
        """

        Date/time to stop listing availability at.

        Value must be at least 1 minute after the [startTime] and strictly less than 35 days from [startTime].

        The default value will be 1 minute less than 35 days from [startTime].
        """
        endTime: DateTime,
        """

        The event uuid to get the rsvps. This is only used by IHE for event
        information and will be removed once IHE migrates to IMS and availability service.
        """
        eventUuid: String,
        """

        Maximum number of edges to return.

        Value must be greater than zero. Default is determined by the server.
        """
        first: Int,
        "Controls the distribution of the returned slots. See [AvailabilitySlotFormat] for details."
        outputFormat: AvailabilitySlotFormat = CONSISTENT_SLOTS,
        """

        Length of the returned availability periods.

        Minimum value is 1 minute. Only hours and minutes are allowed.
        """
        requiredDuration: Duration!,
        """

        Time intervals that returned periods will start on.

        The default start interval depends on `outputFormat`. If the output format is `SLOTS`,
        the start interval is `MINUTE_1`. Otherwise, the start interval is the largest start
        interval that is less than or equal to the provided `requiredDuration`.
        """
        startInterval: StartInterval,
        """

        Date/time to start listing availability from.

        The default value will be `now()`
        """
        startTime: DateTime,
        """

        Timezone Offset for requested availability

        This should only be necessary if the timezone of the request is on a non-hour offset.
        It will allow the [startInterval] to properly begin at the top of an hour in those timezones.

        This value, if provided, will override the [startTime] offset
        """
        timeZone: ZoneID
    ): AvailabilitySlotConnection!
    "Globally unique resource id."
    id: ID!
}

interface AvailabilitySettings {
    """

    Rules that specify specific time periods.

    The periods are not empty. The periods may overlap or may be consecutive.
    """
    periods(
        "Retrieve edges after this cursor."
        after: String,
        """

        End time of the periods to return or null for no limit.

        Value must be greater than or equal to [startTime].
        """
        endTime: DateTime,
        """

        Maximum number of edges to return.

        Value must be greater than zero. Default is determined by the server.
        """
        first: Int,
        "True to include periods that overlap [startTime] or [endTime]."
        includeOverlapping: Boolean = true,
        "Start time of the periods to return or null to return all periods."
        startTime: DateTime
    ): AvailabilityPeriodConnection!
    "Weekly repeating rules."
    week(input: WeekAvailabilityRulesFilterInput): WeekAvailabilityRules!
}

"The general interface for any type of event on a calendar."
interface CalendarEvent {
    "Plain text description of the calendar event."
    description: String
    "The endTime for the calendar event."
    endTime: DateTime!
    "The id uniquely identifying this calendar event."
    id: CalendarEventId!
    "The start time for the calendar event."
    startTime: DateTime!
    "Plain text summary of the calendar event."
    summary: String!
}

"Interface to a employer job post capability."
interface EmployerJobPostCapabilityInterface {
    "Encrypted account ID of original author."
    createdByAccount: ID
    "Date this was created."
    dateCreated: DateTime!
    "Date this was most recently modified."
    dateLastModified: DateTime!
    "The globally unique UUID for the capability"
    id: ID!
}

"Represents a Job stored in Hiring Events."
interface HiringEventJob {
    """

    Job attributes, using [SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID).
    This includes things such as the job types (SUID=H96S2) and pay types (SUID=VFY2W).
    """
    attributes: [HiringEventJobAttributeFacet!]!
    "Compensation for the Job"
    compensation: HiringEventCompensation!
    "the id of the job's conductor screening workflow. Empty if this is not a conductor job"
    conductor_workflow_id: String!
    "Free-form description of the Job"
    descriptionHTML: String!
    """

    The HiringEvent-specific UUID for this job.
    Note that this refers to a legacy HiringEvent Job entity that is not tied to a location
    """
    id: ID!
    "The title of the job. This is not necessarily normalized"
    title: String!
}

interface HiringEventLocation {
    "Two-character representation of the country, based on https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2."
    countryName: String!
    "Formatted and localized location string for display on the user interface"
    formattedLocation: String!
    "Whether the event is remote"
    isRemote: Boolean!
    "Timezone (in TZ DB format) where the interviews occur (e.g. 'America/Chicago')"
    timezone: String!
}

interface IndeedApplyExpectation {
    "If job requires jobSeeker to perform any action regarding the relevant expectation"
    expected: Boolean!
}

"""

IN_PERSON requires an address.
WEBSITE requires a website URL.
EMAIL requires at least one email.
"""
interface JobPostApplyMethodInterface {
    "Enum indicating apply method"
    method: JostPostApplyMethodType
}

"A  Job Post capability"
interface JobPostInterface {
    "List of extended job attributes"
    attributes: [KeyValuePair!]!
    "Country where this Job is located."
    country: CountryCode
    "List of job types."
    jobTypes: [JobType!]!
    "The language in which this Job is presented to candidates."
    language: LanguageCode
    "List of taxonomy attributes grouped by custom class"
    taxonomyAttributes: [JobPostTaxonomyCustomClassAttributes!]!
}

interface Node {
    id: ID!
}

"Base Content Field"
interface TargetedContentDisplayData {
    "Content to render"
    contentsInHtml: String!
    "Text for the Go Action of the Targeted Content"
    goText: String!
    "Header Image Url: Indeed logo by default"
    headerImageUrl: String!
    "URL to use for the Go Action of the Targeted Content"
    landingUrl: String!
    "Content Title"
    title: String!
}

"Base Targeted Content Result Field"
interface TargetedContentResult {
    "Content to display"
    content: TargetedContentDisplayData!
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID!
}

union CreateHiringEventEnhancedScreeningResult = HiringEventEnhancedScreeningCreatedResult | HiringEventEnhancedScreeningRejectedResult

union CreateHiringEventRsvpResult = HiringEventRsvpCreatedResult | HiringEventRsvpRejectedResult

union IhpJobRecommendation = HostedJobPost | IhpAggJobPost

union RangeType = AtLeast | AtMost | Exactly | Range

union RelevantJobsMatchInfo = DefaultRelevantJobsMatchInfo | RecentQueryRelevantJobsMatchInfo

type AddAvailabilityPeriodsPayload {
    "Exclude period rules that were added to the resource."
    exclude: [AvailabilityPeriod!]!
    "Include period rules that were added to the resource."
    include: [AvailabilityPeriod!]!
    "ID of the [AvailabilityResource] availability periods were added to."
    resourceId: ID
}

type AddFieldsJobSeekerProfileStructuredDataDislikedPreferencePayload {
    "Disliked Preference."
    dislikedPreference: JobSeekerProfileStructuredDataPreference
}

"Payload that includes awards that were added"
type AddJobSeekerProfileResumeAwardsPayload {
    awards: [JobSeekerProfileAward!]!
}

"Payload that includes the certifications that are added"
type AddJobSeekerProfileResumeCertificationsPayload {
    certifications: [JobSeekerProfileCertification!]!
}

"Payload that includes the educations that are added"
type AddJobSeekerProfileResumeEducationsPayload {
    educations: [JobSeekerProfileEducation!]!
}

"Payload that includes the language skills that are added"
type AddJobSeekerProfileResumeLanguageSkillsPayload {
    languageSkills: [JobSeekerProfileLanguageSkill!]!
}

type AddJobSeekerProfileResumeLinksPayload {
    links: [JobSeekerProfileLink!]!
}

type AddJobSeekerProfileResumeMilitaryPayload {
    military: [JobSeekerProfileMilitary!]!
}

"Payload that includes the skills that are added"
type AddJobSeekerProfileResumeSkillsPayload {
    skills: [JobSeekerProfileSkill!]!
}

"Payload that includes work experiences that were added"
type AddJobSeekerProfileResumeWorkExperiencesPayload {
    workExperiences: [JobSeekerProfileWorkExperience!]!
}

type AddJobSeekerProfileStructuredDataPreferencePayload {
    "Preference."
    preference: JobSeekerProfileStructuredDataPreference
}

type AddOrUpdateUDPConfirmedSectionsPayload {
    "Document of userDisplayPreference payload."
    userDisplayPreference: UserDisplayPreferencePayload!
}

type AddOrUpdateUDPSkippedQuestionsPayload {
    "Document of userDisplayPreference payload."
    userDisplayPreference: UserDisplayPreferencePayload!
}

type AddUserDisplayPreferencePayload {
    "Document of userDisplayPreference payload."
    userDisplayPreference: UserDisplayPreferencePayload!
}

"Address output for VerificationInfo"
type Address {
    "Country code (ISO 3166-1 - alpha 2 encoded country code string)"
    countryCode: CountryCode!
    "Locality (ie. city)"
    locality: String
    "Postal code (ie. zip code)"
    postalCode: String
    "Region name (eg. name of state, territory, or province)"
    region: String
    "Street address, line 1"
    streetAddressLine1: String
    "Street address, line 2 (optional, for things like apartment or unit numbers)"
    streetAddressLine2: String
}

"The advertising location of draft job post."
type AdvertisingLocation {
    """

    At least one location must be active = true.
    A job may no longer be available at a location by setting to false.
    Default: false.
    """
    active: Boolean!
    """

    The minimum granularity of suggested locations.
    A default granularity will be used if this parameter is not given.
    """
    granularity: MinimumGranularity
    "The normalized job location"
    location: String!
}

type AggJob {
    aggJobID: ID
    normTitle: String
    normTitleCategory: String
    title: String
}

type AggJobLocation {
    admin1: String
    admin2: String
    admin3: String
    admin4: String
    city: String
    country: String
    jobLocationID: ID
}

type AggregatedNativeHiringEventJob {
    job: Job!
    jobKey: ID! @deprecated(reason: "No longer supported")
    nativeJobId: ID!
    nativeLocationId: ID!
    refnum: ID!
}

"This payload type returned by a `allHostedEmployers` query."
type AllHostedEmployersPayload {
    "The array of results returned by a `allHostedEmployers` query."
    results: [HostedEmployerResult!]!
    "Total number of results."
    totalCount: Int
}

"Represents the link to the Indeed Apply web-based apply flow. Note that requesting this link will generate an \\\"iaLoadEnv\\\" log type."
type ApplyLink {
    "The logging ID of the \\\"iaLoadEnv\\\" log type."
    iaUid: String!
    "The URL of the web-based apply flow."
    url: String!
}

type Appointment implements CalendarEvent {
    "Plain text description of the appointment."
    description: String
    "The endTime for the appointment."
    endTime: DateTime!
    "The id uniquely identifying this appointment."
    id: CalendarEventId!
    "The start time for the appointment."
    startTime: DateTime!
    "Plain text summary of the appointment."
    summary: String!
}

type AppointmentPayload {
    result: Appointment!
}

type AtLeast {
    min: Float!
}

type AtMost {
    max: Float!
}

"Rule that defines a specific availability period of time."
type AvailabilityPeriod implements Node {
    """

    End time of the rule period.

    Value is greater than [startTime]. Resolution is 1 minute.
    """
    endTime: DateTime!
    "Globally unique rule id."
    id: ID!
    "Rule identifier that is unique within the calendar, which is ASCII-only String of up to 64 characters."
    key: String!
    """

    Start time of the rule period.

    Resolution is 1 minute.
    """
    startTime: DateTime!
}

type AvailabilityPeriodConnection {
    edges: [AvailabilityPeriodEdge!]!
    pageInfo: PageInfo!
}

type AvailabilityPeriodEdge {
    cursor: String!
    node: AvailabilityPeriod!
}

"Response from the [availabilityResource] query to retrieve an availability resource."
type AvailabilityResourcePayload {
    "Availability Resource that was retrieved."
    result: AvailabilityResource!
}

"Period of time on a calendar that is available for scheduling an event."
type AvailabilitySlot implements Node {
    """

    Number of events scheduled during this time period.

    The events may be partially overlapping this period, so may be included in the
    count for surrounding availability periods.
    """
    capacity: AvailabilitySlotCapacity!
    """

    End time of the period.

    Value is greater than [startTime]. Resolution is 1 minute.
    """
    endTime: DateTime!
    "Globally unique period id."
    id: ID!
    """

    True if this period is available to schedule events in.

    This property should be used to determine if an event can be scheduled within this time
    period.
    This property will be false if [isOutsideWindow] is true.
    """
    isAvailable: Boolean!
    "True if this period is outside the resource's availability window."
    isOutsideWindow: Boolean!
    """

    Start time of the period.

    Resolution is 1 minute.
    """
    startTime: DateTime!
}

type AvailabilitySlotCapacity {
    """

    Number of events currently scheduled during the time period.

    The events may be partially overlapping this period, so may be included in the
    count for surrounding availability periods.
    """
    count: Int!
}

type AvailabilitySlotConnection {
    edges: [AvailabilitySlotEdge!]!
    pageInfo: PageInfo!
    startInterval: StartInterval!
}

type AvailabilitySlotEdge {
    cursor: String!
    node: AvailabilitySlot!
}

"""

Specifies the time window in the future an event can be scheduled.

Example: If the minimum is one hour and the maximum is two weeks, only events that occur
later than one hour and less than two weeks from now should be scheduled on the calendar.
"""
type AvailabilityWindow {
    """

    Maximum amount of time in the future an event can be scheduled.

    Value is greater than or equal to [minimum] or null if unbounded.
    """
    maximum: Duration
    """

    Minimum amount of time in the future an event can be scheduled.

    Value is greater than or equal to zero.
    """
    minimum: Duration!
}

type AvailableCountrySitesPayload {
    results: [CountrySite!]!
}

"Average and number of rating data point. Data point value belongs to {1, 2, 3, 4, 5}"
type AverageRating {
    "Number of data points"
    count: Int
    "Average rating"
    value: Float
}

"Provides pagination information for use in subsequent queries."
type BidirectionalCursorInfo {
    """

    The "end" of the result set. This cursor is intended to be used with the "after" attribute in order to
    advance to the next page.
    """
    endCursor: String!
    "Indicates if it is likely that there is a next page."
    hasNextPage: Boolean!
    "Indicates if it is likely that there is a previous page."
    hasPreviousPage: Boolean!
    """

    The "beginning" of the result set. This cursor is intended to be used with the "before" attribute in order to
    go back to the previous page.
    """
    startCursor: String!
}

type BulkMarketInsightsPayload {
    "List of BulkMarketInsightsPayload"
    results: [BulkMarketInsightsResult!]!
}

type BulkMarketInsightsResult {
    "Query MarketInsights data to map relevant response"
    query: MarketInsightsRequest
    "Response for the MarketInsights query."
    response: MarketInsightsPayload
}

"A way of identifying a calendar event."
type CalendarEventId {
    "The calendar this appointment belongs to."
    calendarId: CalendarId!
    "Key that will be used to uniquely identify this calendar event within a calendar."
    key: String!
}

"A way of identifying a calendar."
type CalendarId {
    "The availability resource id."
    availabilityResourceId: ID
    "The account id for the user."
    indeedAccountId: IndeedAccountId
}

type Campaign {
    adName: String
    advertisementID: ID
}

type CampaignsPayload {
    result: [Campaign!]!
}

type CeoPhotoUrlBundle {
    "Link to a CEO photo (256x256)"
    url256: String!
    "Link to a CEO photo (48x48)"
    url48: String!
    "Link to a CEO photo (512x512)"
    url512: String!
    "Link to a CEO photo (96x96)"
    url96: String!
}

type ClassifyOccupationsForJobDetailsPayload {
    """

    All of the ancestors are returned ranked order.
    The rank of a derived ancestor is the same as the original occupation.
    """
    ancestors: [TaxonomyConcept!]!
    """

    Occupations are returned ranked order, highest to lowest. When the rank is a tie the order is not
    guaranteed. The rank represents the confidence that the Occupation is applicable to the input.
    """
    occupations: [TaxonomyConcept!]!
    responseStatus: MdsResponseStatus!
}

type CompanyAutofillPayload {
    "company name to be suggested"
    companyName: String
    "industry"
    industry: String
    "segment the user could be categorized as"
    segment: Segment
    "website url"
    website: String
}

" Email-related company settings "
type CompanyEmailSettings {
    " Flag for whether or not monthly budget alerts have been enabled "
    monthlyBudgetAlertsEnabled: Boolean!
    " Company email settings related to new candidate notifications "
    newCandidates: NewCandidateEmailSettings
}

" Email-related company settings mutations "
type CompanyEmailSettingsMutations {
    " Company email settings mutations related to new candidate notifications "
    newCandidates: NewCandidateEmailSettingsMutations
    " Sets the monthly budget alert flag "
    updateMonthlyBudgetAlerts(input: UpdateMonthlyBudgetAlertsInput!): UpdateMonthlyBudgetAlertsPayload
}

" Language-related company settings "
type CompanyLanguageSettings {
    " The languages available to use for email notifications "
    availableLanguages: [LanguageAndDisplayName!]!
    " The language to use for email notifications "
    currentLanguage: LanguageCode!
}

" Language-related company email settings mutations "
type CompanyLanguageSettingsMutations {
    " Sets the current language to a new values "
    updateCurrentLanguage(input: UpdateCurrentLanguageInput!): UpdateCurrentLanguagePayload
}

" Namespace type for company settings queries in root Mutation "
type CompanySettingsMutations {
    " Email-related company settings mutations "
    email: CompanyEmailSettingsMutations
    " Language-related company settings mutations "
    language: CompanyLanguageSettingsMutations
}

" Namespace type for company settings queries in root Query "
type CompanySettingsQueries {
    " Email-related company settings "
    email: CompanyEmailSettings
    " Language-related company settings "
    language: CompanyLanguageSettings
}

type ConfirmJobSeekerProfileStructuredDataPayload {
    "JobSeeker Profile Ceritification."
    certification: JobSeekerProfileStructuredDataCertification
    "JobSeeker Profile Education."
    education: JobSeekerProfileStructuredDataEducation
    "JobSeeker Profile License."
    license: JobSeekerProfileStructuredDataLicense
    "JobSeeker Profile Occupation."
    occupation: JobSeekerProfileStructuredDataOccupation
    "JobSeeker Profile Skill."
    skill: JobSeekerProfileStructuredDataSkill
}

type ConfirmedParsedSectionsMutations {
    "Updates and adds confirmed parsed sections from userDisplayPreference that has matching accountId."
    addOrUpdate(input: AddOrUpdateUDPConfirmedSectionsInput!): AddOrUpdateUDPConfirmedSectionsPayload
    "Removes confirmed parsed sections from userDisplayPreference that has matching accountId."
    remove(input: RemoveUDPConfirmedSectionsInput!): RemoveUDPConfirmedSectionsPayload
    "Removes all confirmed parsed sections from userDisplayPreference that has matching accountId."
    removeAll: RemoveUDPAllConfirmedSectionsPayload
}

"""

External calendar profile connected to the user's calendar.

For example: Google Calendar, Apple iCloud Calendar, etc.
"""
type ConnectedCalendarProfile {
    "The globally unique ID of the profile."
    id: ID!
    """

    The display name of the profile.

    This name can be displayed to help users distinguish between different profiles.
    In many cases, it is the user's email address, but that is not guaranteed.
    """
    name: String!
    "Service that provides the calendar."
    provider: ConnectedCalendarProvider!
}

"""

External calendar service.

For example: Google Calendar, Apple iCloud Calendar, etc.
"""
type ConnectedCalendarProvider {
    "Type of the calendar provider service."
    type: ConnectedCalendarProviderType!
}

type ConnectedCalendars {
    """

    External connected calendar profiles.

    For example: Google Calendar, Apple iCloud Calendar, etc.
    """
    profiles: [ConnectedCalendarProfile!]!
}

"Count by different job status"
type CountByStatus {
    "Count of jobs with ACTIVE status"
    active: Int!
    "Count of jobs with DELETED status"
    deleted: Int!
    "Count of jobs with PAUSED status"
    paused: Int!
}

type CountryJobCountResult {
    "The number of jobs or groups that matched the provided filters."
    count: Int!
    "Country code for which jobs are located. Format: ISO 3166-1 alpha-2 (Example: \"CA\")"
    countryCode: String!
}

type CountrySite {
    "Localized Indeed URL."
    baseIndeedUrl: String!
    "2-letter country code. Corresponds to URL parameter **co**."
    countryCode: CountryCode!
    "Name translated into current country language."
    countryName: String!
    "Supported languages for country site"
    supportedLanguages: [LanguageCode!]!
}

"Job's cpo eligibility"
type CpoEligibility {
    cpoIneligibilityReasons: [CpoIneligibilityReason!]!
}

"Payload for Cpo Eligibility"
type CpoEligibilityPayload {
    "Job's cpo eligibility"
    results: [CpoEligibility!]!
}

type CreateDraftJobPostFromHostedJobPostPayload {
    "The result from CreateDraftJobPostFromHostedJobPost."
    result: CreateDraftJobPostFromHostedJobPostResult!
}

type CreateDraftJobPostFromHostedJobPostResult {
    "The DraftJobPost result from CreateDraftJobPostFromHostedJobPost."
    draftJobPost: DraftJobPost!
}

type CreateDraftJobPostPayload {
    "The result."
    result: CreateDraftJobPostResult!
}

type CreateDraftJobPostResult {
    "The created DraftJobPost."
    draftJobPost: DraftJobPost!
}

type CreateEventCalendarPayload {
    id: ID!
}

type CreateHiringEventEnhancedScreeningPayload {
    result: CreateHiringEventEnhancedScreeningResult!
}

type CreateHiringEventRsvpPayload {
    result: CreateHiringEventRsvpResult!
}

type CreateHostedEmployerPayload {
    "The create result."
    result: CreateHostedEmployerResult!
}

type CreateHostedEmployerResult {
    "The created Hosted Employer."
    hostedEmployer: HostedEmployer!
}

type CreateHostedJobPostPayload {
    "The result."
    result: CreateHostedJobPostResult!
}

type CreateHostedJobPostResult {
    "The created HostedJobPost."
    hostedJobPost: HostedJobPost!
}

type CreateOrUpdateTimePunchPayload {
    result: CreateOrUpdateTimePunchResult
}

type CreateOrUpdateTimePunchResult {
    clientExternalId: ID
    comment: String
    jobsiteExternalId: ID
    jobsiteTimezone: String
    punchCode: PunchCode
    punchIn: DateTime
    punchOut: DateTime
    shiftExternalId: ID
    slug: ID
    workerExternalId: ID
}

"Result payload for the `createReviewComment` mutation"
type CreateReviewCommentPayload {
    "Available details of the created comment, including its ID"
    comment: ReviewComment!
}

"This payload type returned by a `currentHostedEmployer` query."
type CurrentHostedEmployerPayload {
    "The result."
    result: HostedEmployerResult!
}

"Current User"
type CurrentUserPayload {
    "User Account"
    account: Account
    "User IP Address"
    ipAddress: IpAddress
}

"Employer-submitted content used to display one section of \"Why Join Us\" page."
type CustomEmployerContent {
    "Description of content"
    description: String
    "Image/Youtube/null depending on type of content"
    mediaUrl: String
    "Title of content"
    title: String!
}

"Employer-submitted link to external resource"
type CustomEmployerLink {
    "Localized version of name"
    name: String
    "URL of target"
    url: String
}

type CustomTaxonomyClass {
    """

    SUID(Short UID) of TaxonomyConcept.
    Used as the primary key.
    """
    key: ID!
    """

    Preferred label of CustomClass.
    This field will only be in English and not be localized.
    """
    label: String!
    """

    UUID of TaxonomyConcept.
    Will be finally replaced with SUID.
    """
    uuid: ID!
}

type DefaultRelevantJobsMatchInfo {
    "see MatchReasonId on https://go.indeed.com/GLYK6YA6M"
    reason: String!
}

type DeleteAppointmentPayload {
    id: CalendarEventId!
}

type DeleteDraftJobPostPayload {
    "The result of the delete."
    result: DeleteDraftJobPostResult!
}

type DeleteDraftJobPostResult {
    "Was the delete successful?"
    success: Boolean!
}

"Output result for deleteDraftVerificationInfo"
type DeleteDraftVerificationInfoPayload {
    "Whether or not the transaction succeeded"
    results: Boolean!
}

type DeleteEventCalendarPayload {
    id: ID!
}

type DeleteFieldsJobSeekerProfileStructuredDataDislikedPreferencePayload {
    "List of disliked companies."
    companyIDs: [String!]!
}

"Payload that includes the file ID of the jobseeker"
type DeleteJobSeekerProfileFilePayload {
    id: ID
}

"Payload that includes award ids that were deleted"
type DeleteJobSeekerProfileResumeAwardsPayload {
    awardIds: [String!]!
}

"Payload that includes the certification IDs that are deleted"
type DeleteJobSeekerProfileResumeCertificationsPayload {
    certificationIds: [String!]!
}

"Payload that includes the educations IDs that are deleted"
type DeleteJobSeekerProfileResumeEducationsPayload {
    educationIds: [String!]!
}

"Payload that includes the languages that are deleted"
type DeleteJobSeekerProfileResumeLanguageSkillsPayload {
    languages: [String!]!
}

type DeleteJobSeekerProfileResumeLinksPayload {
    linkIds: [String!]!
}

type DeleteJobSeekerProfileResumeMilitaryPayload {
    militaryIds: [String!]!
}

"Payload that includes list of UpdogRezIDs for deleted jobseeker resumes"
type DeleteJobSeekerProfileResumePayload {
    defaultInfo: JobSeekerProfileDefaultInfo
    resumes: [ID!]!
}

"Payload that includes the skills IDs that are deleted"
type DeleteJobSeekerProfileResumeSkillsPayload {
    skillIds: [String!]!
}

"Payload that includes work experience ids that were deleted"
type DeleteJobSeekerProfileResumeWorkExperiencesPayload {
    workExperienceIds: [String!]!
}

"Result payload for the `deleteReviewComment` mutation"
type DeleteReviewCommentPayload {
    key: ID!
}

type DeleteUserCalendarPayload {
    id: ID!
}

" Device clicks "
type DeviceClicks {
    activityDate: String
    deviceType: DeviceType
    sumClicks: Int
}

type DeviceClicksPayload {
    result: [DeviceClicks!]!
}

" Return type for updateNewCandidateEmailAttachResume "
type DisableAttachNewCandidateResumesPayload {
    " New value for whether or not to attach resumes "
    attachResumes: Boolean!
    " Reference to company settings to use for subsequent calls "
    companySettings: CompanySettingsQueries
}

"Payload that includes the S3 signed url for file of the jobseeker"
type DownloadJobSeekerProfileFilePayload {
    url: String
}

type DraftJobPost implements EmployerJobPostCapabilityInterface & JobPostInterface {
    "List of advertising locations for this job."
    advertisingLocations: [AdvertisingLocation!]!
    """

    An apply method, look at specific implementation
    for details.
    """
    applyMethod: JobPostApplyMethodInterface
    "List of extended job attributes"
    attributes: [KeyValuePair!]!
    """

    The hiring company name.
    The maximum length for the company name should not exceed 200
    characters.
    """
    company: String
    "Country where this Job is located."
    country: CountryCode
    "Is cover letter required?"
    coverLetterRequired: JobRequirement
    "Encrypted account ID of original author."
    createdByAccount: ID
    "Date this was created."
    dateCreated: DateTime!
    "Date this was most recently modified."
    dateLastModified: DateTime!
    """

    The job description.
    Markdown formatting may be used:
    For _italics_ use underscores: `_italics_`
    For emphasis use asterisks: `*bold*`
    For line breaks use: `\n`
    For bullets use an asterisk and a space: `* Item`
    The minimum length for the job description should be 30
    characters and the maximum length should not exceed 20000.
    """
    description: String
    "External structured data"
    extensionMetadata: [EmployerJobPostExtensionMetadata!]!
    fieldEditRules: FieldEditRules
    """

    The globally unique UUID for a job post.
    There may exist an associated PublishedJobPost with the same ID.
    """
    id: ID!
    "The full street address where work will be performed."
    jobAddress: String
    "List of job types."
    jobTypes: [JobType!]!
    "The language in which this Job is presented to candidates."
    language: LanguageCode
    "The taxonomy UUID that identifies the job occupation."
    occupationUuid: String
    "Indicating the origin of this job."
    origin: JobPostOrigin!
    "Is phone required?"
    phoneRequired: JobRequirement
    "Is resume required?"
    resumeRequired: JobRequirement
    "Job salary period and range amounts."
    salary: JobSalary
    "List of taxonomy attributes"
    taxonomyAttributes: [JobPostTaxonomyCustomClassAttributes!]!
    """

    The job post title
    The maximum length for the job title should not exceed 75
    characters.
    """
    title: String
}

"Response payload from draftJobPosts()"
type DraftJobPostsPayload {
    "Matching results. Maximum of 100."
    results: [DraftJobPostsResult!]!
    "Total number of results."
    totalCount: Int
}

"Draft Job Post result."
type DraftJobPostsResult {
    "Draft job post"
    draftJobPost: DraftJobPost!
}

"Output for draftVerificationInfo"
type DraftVerificationInfoPayload {
    "The current working copy of the verification info for the advertiser"
    results: VerificationInfo!
}

type Employer {
    """

    True: There is at least one verified account for the company.
    False: There are no verified accounts.
    Null: We were unable to determine if the company has been claimed or not.

    Note: Verification of accounts depends on the claim process and may not be a stringent check.
    """
    claimed: Boolean
    "EmployerDossier"
    dossier: EmployerDossier
    "The employer key, used to identify the employer"
    key: ID!
    "Company name (calculated based on locale)"
    name: String
    """

    Url of employer's company page on Indeed. Relative to domain address.

    If full URL is "www.indeed.com/cmp/Indeed", then field contains "/cmp/Indeed"
    """
    relativeCompanyPageUrl: String
    "Reviews. Country/Language parameters applied for employer are automatically passed into filter"
    reviews(filter: ReviewFilterParams, paging: PagingParams, sort: [ReviewSortParams]): [Review]
    "Salary information for the employer. Can be filtered on location, jobTitle or time range. Location and jobTitle fields are deprecated. Use filter instead."
    salaries(
        filter: EmployerSalaryInput,
        "Deprecated. Use recommended filter instead."
        jobTitle: String,
        "Deprecated. Use recommended filter instead."
        location: String
    ): SalaryInfo
    """

    Returns similar employers.
    If the parent Employer has the country attribute, these results may be specific to that country.
    If no country was specified, or if there is no data specific to a country, results will be based on "global" similarity.
    """
    similarEmployers: SimilarEmployersPayload
    "Free or enterprise tier"
    tier: EmployerTier
    "Stats based on user generated content submitted by jobseekers, e.g. number of reviews, average ratings, salary satisfaction etc"
    ugcStats: JobseekerUgcStats
}

"Cursor-based page info result."
type EmployerBidirectionalCursorInfo {
    "Cursor of last item in the page."
    endCursor: ID!
    "Are there more results going forward?"
    hasNextPage: Boolean!
    "Are there more results going backwards?"
    hasPreviousPage: Boolean!
    "Cursor of first item in the page."
    startCursor: ID!
}

"Details of an approved claim on the company page of an Employer. The claimant is implied by context."
type EmployerClaim {
    "The claimed Employer. Country and language are for localizing some content."
    employer(country: String, language: String): Employer!
}

"Result of 'myEmployerClaims' query."
type EmployerClaimsResult {
    "Approved claims on company pages."
    employerClaims: [EmployerClaim!]!
}

"Employer description and different facts"
type EmployerDetails {
    "A localized version of address"
    addresses: [String]
    "One line description or employer's motto"
    briefDescription: String
    "CEO name"
    ceoName: String
    "Link to CEO photo (400x400)"
    ceoPhotoUrl: String @deprecated(reason: "Use ceoPhotoUrls")
    "Links to CEO photos"
    ceoPhotoUrls: CeoPhotoUrlBundle
    "Paragraph long description of the employer"
    companyDescription: String
    "Headquarters country"
    country: String
    "Approximate number of employees in the company. Enum value"
    employees: String
    "Main industry of employer. Enum value"
    industry: String @deprecated(reason: "Use sectors")
    "Approximate revenue of employer. Enum value"
    revenue: String
    "Company Sectors of employer"
    sectors: EmployerSectors
    "Stock symbol"
    stockSymbol: String
}

"Information about employer. Most of the types and fields are specific for requested country/language pair"
type EmployerDossier {
    "The employers brand color"
    brandColor: String
    "List of up to 10 CustomEmployerContent items, each representing section of \"Why Join Us\" page"
    customContents: [CustomEmployerContent]
    "Facts about employer such as CEO, industry, head count etc"
    employerDetails: EmployerDetails
    """

    Alt text for the headerImageUrl in images.

    This is user generated text which may be in a different language from request
    """
    headerAltText: EmployerHeaderText
    "Company logos, header (for given locale) and ceo photo"
    images: ImageBundle
    "Links to other sites where employer is represented, e.g. employer site, Facebook, Instagram etc"
    links: EmployerLinks
    """

    Flag to determine whether the premium company header is shown for Enterprise clients

    This needs to be checked in conjunction with the employer tier.
    """
    premiumHeaderEnabled: Boolean @deprecated(reason: "Premium header is now enabled for all by default.")
}

"Cursor-based page info result."
type EmployerForwardOnlyCursorInfo {
    "Cursor of last item in the page."
    endCursor: ID!
    "Are there more results going forward?"
    hasNextPage: Boolean!
}

type EmployerHeaderText {
    "Country code for the alt text. Format: ISO 3166-1 alpha-2 e.g. 'CA')"
    countryCode: String
    "Language code for the alt text. Format: ISO 639-1 e.g. 'fr')"
    languageCode: String
    "Alt text for the headerImageUrl in images."
    value: String
}

type EmployerJob {
    "The employer job id for this job."
    id: ID!
}

"""

An external structured data extension defined by external client.
Examples of metadata that may be attached include:
- Job Requirements (aka screener questions)
- Funnel-specific data
This is specific to the DraftJobPost and there should be no
expectation that the extension metadata will be retained once the
job is published.
"""
type EmployerJobPostExtensionMetadata {
    """

    Metadata as a JSON string.
    e.g.: "{\"twitterHandle\":\"@thescavenger\"}"
    The structure of this data is externally defined (e.g. by the IQ
    team or funnel team).
    It must be a valid, parsable JSON
    string. It must not exceed 4096 bytes.
    """
    data: String!
    """

    Type
    e.g. "IqRequirements"
    """
    type: String!
    """

    Version of the type.
    e.g.: "2.1"
    """
    version: String
}

"Links to external resources related to employer"
type EmployerLinks {
    "A link to the company's corporate website"
    corporateWebsite: String
    "A set of custom links, created by the employer"
    customLinks: [CustomEmployerLink]
    "A link to the company's Facebook page"
    facebook: String
    "A link to the company's Instagram page"
    instagram: String
    "A link to the company's Twitter profile"
    twitter: String
}

"Offset-based page info result."
type EmployerOffsetInfo {
    "The offset of the first item in the current page. Null if there are no items in the page."
    offset: Int
    "The page-based offset of the current page. Null if there are no items in the page."
    pageOffset: Int
}

type EmployerSectors {
    results: [SectorResult!]!
}

" Return type for updateNewCandidateEmailAttachResume "
type EnableAttachNewCandidateResumesPayload {
    " New value for whether or not to attach resumes "
    attachResumes: Boolean!
    " Reference to company settings to use for subsequent calls "
    companySettings: CompanySettingsQueries
}

type EstimateSalaryForJobDetailsPayload {
    result: EstimateSalaryForJobDetailsResult!
}

type EstimateSalaryForJobDetailsResult {
    country: CountryCode
    currency: CurrencyCode
    estimatedSalaryStatistics: [EstimatedSalaryStatistic!]!
    mostCommonSalaryPeriod: EstimationJobSalaryPeriod
    normalizedJobTitle: String
    normalizedLocation: String
    "Boolean to show if salary can be estimated"
    unableToEstimate: Boolean!
    "Explaining why salary estimation failed"
    unableToEstimateReason: String
}

type EstimatedSalaryStatistic {
    distribution: [SalaryDistribution!]!
    "This is the formatted maximum salary with unit being standard main unit like dollar or yen"
    formattedMaximum: String
    "This is the formatted median salary with unit being standard main unit like dollar or yen"
    formattedMedian: String
    "This is the formatted minimum salary with unit being standard main unit like dollar or yen"
    formattedMinimum: String
    "This is the maximum salary with unit being standard main unit like dollar or yen"
    maximum: Float
    "This is the median salary with unit being standard main unit like dollar or yen"
    median: Float
    "This is the minimum salary with unit being standard main unit like dollar or yen"
    minimum: Float
    period: EstimationJobSalaryPeriod
}

type EventCalendar implements AvailabilityResource & Node {
    availabilitySettings: ResourceAvailabilitySettings!
    available(after: String, availabilityWindow: AvailabilityWindowFilter, endTime: DateTime, eventUuid: String, first: Int, outputFormat: AvailabilitySlotFormat = CONSISTENT_SLOTS, requiredDuration: Duration!, startInterval: StartInterval, startTime: DateTime, timeZone: ZoneID): AvailabilitySlotConnection!
    id: ID!
}

"Response from the [eventCalendar] query to retrieve an availability resource of type [EventCalendar]."
type EventCalendarPayload {
    "Event Calendar that was retrieved."
    result: EventCalendar!
}

type Exactly {
    value: Float!
}

"""

Rules that specify when an [AvailabilityResource] is explicitly unavailable for
events to be scheduled.
"""
type ExcludeAvailabilitySettings implements AvailabilitySettings {
    periods(after: String, endTime: DateTime, first: Int, includeOverlapping: Boolean = true, startTime: DateTime): AvailabilityPeriodConnection!
    week(input: WeekAvailabilityRulesFilterInput): WeekAvailabilityRules!
}

type FieldEditRule {
    fieldSource: FieldSource!
    isEditable: Boolean!
}

type FieldEditRules {
    advertisingLocations: FieldEditRule
    applyUrl: FieldEditRule
    company: FieldEditRule
    country: FieldEditRule
    description: FieldEditRule
    jobAddress: FieldEditRule
    jobTypes: FieldEditRule
    language: FieldEditRule
    salary: FieldEditRule
    title: FieldEditRule
}

"Response payload from findDraftJobPosts()"
type FindDraftJobPostsPayload {
    "Number of results in this page."
    count: Int!
    "Info for fetching subsequent pages of results."
    offsetInfo: EmployerOffsetInfo
    "Page of results."
    results: [DraftJobPostsResult!]!
    "Total number of results. May not be available."
    totalCount: Int
}

type FindEmployerJobsPayload {
    "An estimate of the total number of results that match the given query."
    estimatedTotalResultsCount: Int!
    "Pagination information. See: https://wiki.indeed.com/display/Microservices/API+Recommendations for details"
    pageInfo: BidirectionalCursorInfo!
    "List of employer job results."
    results: [FindEmployerJobsResult!]!
}

type FindEmployerJobsResult {
    "The employer job for this result."
    employerJob: EmployerJob!
}

type FindEmployersNormalizedQuery {
    "Additional information about what query"
    what: [FindEmployersNormalizedWhat!]!
    "Additional information about where query"
    where: [FindEmployersNormalizedWhere!]!
}

type FindEmployersNormalizedWhat {
    "Normalized version of what search term that was actually used for search"
    normalizedWhat: String!
    "Matched type of search term"
    whatType: FindEmployersWhatType!
}

type FindEmployersNormalizedWhere {
    "Normalized location"
    normalizedWhere: String!
    "Matched type of search term"
    whereType: FindEmployersWhereType!
}

type FindEmployersPageInfo {
    "Number of items in the current page"
    count: Int!
    "Offset the current page represents"
    pageOffset: Int!
    "Total number of pages"
    pages: Int!
    "Total number of items in the results"
    totalCount: Int!
}

type FindEmployersPayload {
    "List of employers"
    employers: [FindEmployersResult!]!
    "Additional info about search query"
    normalizedQuery: FindEmployersNormalizedQuery!
    "Results pagination"
    pageInfo: FindEmployersPageInfo!
}

type FindEmployersResult {
    employer: Employer!
    "Matched type for search query influencing this result"
    whatType: FindEmployersWhatType!
    "Matched type for location query influencing this result"
    whereType: FindEmployersWhereType!
}

type FindHiringEventResult {
    hiringEvent: HiringEvent!
}

type FindHiringEventRsvpResult {
    hiringEventRsvp: HiringEventRsvp!
}

type FindHiringEventRsvpsPayload {
    result: [FindHiringEventRsvpResult!]!
}

type FindHiringEventsPayload {
    result: [FindHiringEventResult!]!
}

"Response payload from findHostedJobPosts()"
type FindHostedJobPostsPayload {
    "Number of results in this page."
    count: Int!
    "Info for fetching subsequent pages of results."
    offsetInfo: EmployerOffsetInfo
    "Page of results."
    results: [HostedJobPostsResult!]!
    "Total number of results. May not be available."
    totalCount: Int
}

type FindRelevantJobsPayload {
    results: [RelevantJobsResult!]!
    trackingKey: String!
}

"Payload with return data with the results of retrieving targeted content"
type FindTargetedContentPayload {
    "Determination Type used to generate the results"
    determinationType: TargetedContentDeterminationType!
    "Targeted Content Results"
    results: [TargetedContentResult!]!
}

type FindUserDisplayPreferenceByIdPayload {
    "Document of userDisplayPreference payload."
    userDisplayPreference: UserDisplayPreferencePayload!
}

type FindUserDisplayPreferencePayload {
    "Document of userDisplayPreference payload."
    userDisplayPreference: UserDisplayPreferencePayload!
}

type FindYelpBusinessPayload {
    result: YelpBusinessData
}

type FindYelpBusinessesByIdsPayload {
    results: [YelpBusinessData!]!
}

type FindYelpBusinessesPayload {
    results: [YelpBusinessData!]!
}

"FormattedJobLocation sub fields may be localized via the locale URL parameter"
type FormattedJobLocation {
    """

    Long format is used in the following places:
    - H1
    - Page Title

    Examples:
    - US - 'New York, NY 10048'
    - JP - '大阪府 豊能郡 能勢町 大里'
    - GB - 'Manchester M9'
    - AU - 'Melbourne VIC 3076'
    """
    long: String!
    """

    Short format is meant for used on SERPs next to company names to identify the location of the job

    Examples:
    - US - 'New York, NY'
    - JP - '能勢町 大里'
    - GB - 'Manchester'
    - AU - 'Melbourne VIC'
    """
    short: String!
}

type FormattedJobSalaryExample {
    formattedJobSalaryRange: FormattedJobSalaryRange!
    jobSalaryPeriod: EstimationJobSalaryPeriod!
}

type FormattedJobSalaryRange {
    "This is the formatted maximum salary with unit being standard main unit like dollar or yen"
    formattedMaximum: String!
    "This is the formatted minimum salary with unit being standard main unit like dollar or yen"
    formattedMinimum: String!
}

"""

FormattedLocation sub fields may be localized.
Eventually, Location will resemble Job Seeker's FormattedLocation with:
long: String!
short: String!
"""
type FormattedLocation {
    "The short display formatted version of location"
    short: String!
}

type GlassdoorAnnualSalary {
    currencyCode: String
    max: Float
    median: Float
    min: Float
    preferredPayPeriodEnum: String
    salarySourceEnum: String
}

type GlassdoorEmployer {
    businessOutlookRating: Float
    careerOpportunitiesRating: Float
    ceoRating: Float
    compensationAndBenefitsRating: Float
    cultureAndValuesRating: Float
    diversityAndInclusionRating: Float
    divisionKey: ID
    divisionName: String
    employeeCount: Int
    employerKey: ID
    employerRating: Float
    employerRatingCount: Int
    employerShortName: String
    industryKey: ID
    recommendToFriendRating: Float
    seniorManagementRating: Float
    workLifeBalanceRating: Float
}

"""

Represents the Glassdoor facets.

It wraps all the Glassdoor related fields including
- employerKey
- industryKey
- employeeCount
- sGocKey
- seniorityKey
- cityKey

**Example**

```
facets {
glassdoor {
employerKey (top: 3) {
key
count
}

industryKey (keys: ["key1", "key2"]) {
key
count
}

sGocKey (keys: ["key3", "key4"]) {
key
count
}

seniorityKey (keys: ["key5", "key6"]) {
key
count
}

cityKey (keys: ["key7", "key8"]) {
key
count
}

employeeCount (
ranges: [
{
label: "Small Company"
min: 1
max: 200
},
{
label: "Medium Company"
min: 201
max: 500
}
]
) {
label
min
max
count
}
}
}
```

Results can be utilized in `keyword` filters or `range` filters to restrict the search result set.

**Example**

```
filters: [
{
keyword: {
field: "glassdoor.employerKey",
keys: ["key1", "key2"]
operation: OR
}
}
{
keyword: {
field: "glassdoor.industryKey",
keys: ["key3"]
}
}
{
range: {
field: "glassdoor.employeeCount"
min: 1
max: 200
}
}
]
```
"""
type GlassdoorFacet {
    "Provides facets for Glassdoor city key"
    cityKey(
        """

        Return facets for each of the specified city keys.
        Keys are limited to a maximum 25.
        """
        keys: [ID!],
        """

        Return the top most frequent city keys contained in the result set up to the number requested.

        Defaults to 5 if `keys` is null or empty; 0 otherwise.
        Must be at least 1 and at most 25 when specified.
        """
        top: Int
    ): [JobSearchKeywordFacet!]!
    """

    Provides facets about combined (Indeed/Glassdoor) compensation.

    **Example**

    ```
    combinedCompensation {
    currencyCode
    baseAnnualSalary (
    numRanges: 20
    minRangeWidth: 1000
    ) {
    ranges {
    min
    max
    count
    }
    }
    }
    ```
    """
    combinedCompensation: JobSearchCompensationFacet!
    """

    Provides facets about Glassdoor compensation.

    **Example**

    ```
    compensation {
    currencyCode
    baseAnnualSalary (
    numRanges: 20
    minRangeWidth: 1000
    ) {
    ranges {
    min
    max
    count
    }
    }
    }
    ```
    """
    compensation: JobSearchCompensationFacet!
    "Provides range facets for Glassdoor employee count"
    employeeCount(
        "Requests must include at least 1 range facet"
        ranges: [JobSearchRangeFacetInput!]!
    ): [JobSearchRangeFacet!]!
    "Provides facets for Glassdoor employer key"
    employerKey(
        """

        Return facets for each of the specified employer keys.
        Keys are limited to a maximum 25.
        """
        keys: [ID!],
        """

        Return the top most frequent employer keys contained in the result set up to the number requested.

        Defaults to 5 if `keys` is null or empty; 0 otherwise.
        Must be at least 1 and at most 25 when specified.
        """
        top: Int
    ): [JobSearchKeywordFacet!]!
    "Provides facets for Glassdoor industry key"
    industryKey(
        """

        Return facets for each of the specified industry keys.
        Keys are limited to a maximum 25.
        """
        keys: [ID!],
        """

        Return the top most frequent industry keys contained in the result set up to the number requested.

        Defaults to 5 if `keys` is null or empty; 0 otherwise.
        Must be at least 1 and at most 25 when specified.
        """
        top: Int
    ): [JobSearchKeywordFacet!]!
    "Provides facets for Glassdoor sGoc key"
    sGocKey(
        """

        Return facets for each of the specified sgoc keys.
        Keys are limited to a maximum 25.
        """
        keys: [ID!],
        """

        Return the top most frequent sGoc keys contained in the result set up to the number requested.

        Defaults to 5 if `keys` is null or empty; 0 otherwise.
        Must be at least 1 and at most 25 when specified.
        """
        top: Int
    ): [JobSearchKeywordFacet!]!
    "Provides facets for Glassdoor seniority key"
    seniorityKey(
        """

        Return facets for each of the specified seniority keys.
        Keys are limited to a maximum 25.
        """
        keys: [ID!],
        """

        Return the top most frequent seniority keys contained in the result set up to the number requested.

        Defaults to 5 if `keys` is null or empty; 0 otherwise.
        Must be at least 1 and at most 25 when specified.
        """
        top: Int
    ): [JobSearchKeywordFacet!]!
}

type GlassdoorGoc {
    gocKey: ID
    mGocKey: ID
    normTitle: String
    sGocKey: ID
    seniorityKey: ID
}

type GlassdoorJobData {
    annualSalary: GlassdoorAnnualSalary
    """

    Last successful annotated date for the Glassdoor data.
    If this timestamp equals to the `dateLastAnnotated` field in the `job` section, it means the latest annotation succeeded.
    Otherwise it means the latest annotation failed, and this timestamp represents for the last successful annotation date.
    """
    dateLastAnnotated: Timestamp
    employer: GlassdoorEmployer
    goc: GlassdoorGoc
    "True if this job has an active ad campaign attached."
    hasActiveAdCampaign: Boolean!
    indeedApplyPingbackUrl: String
    location: GlassdoorLocation
    "True if this job is ineligible for Google for Jobs."
    noindex: Boolean!
    """

    This is always `null` in jobSearch requests.
    In jobData requests, this has a value only when the job can be sponsored.
    """
    searchlessPrice: JobDataPrice
    sponsoredClickTrackingPixelUrl: String
    thirdPartyApplyUrl: String
}

type GlassdoorLocation {
    cityKey: String
    countryKey: String
    stateKey: String
}

type GlobalJobCountPayload {
    results: [CountryJobCountResult!]!
}

"Represents the rating of a happiness dimension."
type HappinessRating {
    "Total number of answers"
    count: Int!
    "Grade based on the score"
    grade: HappinessGrade!
    "Score from 20 to 100"
    score: Int!
}

type HappinessStats {
    "I am achieving most of my goals at work."
    achievement: HappinessRating!
    "There are people at work who appreciate me as a person."
    appreciation: HappinessRating!
    "I feel a sense of belonging in my company."
    belonging: HappinessRating!
    "I am paid fairly for my work."
    compensation: HappinessRating!
    "In most of my work tasks, I feel energized."
    energy: HappinessRating!
    "My work has the time and location flexibility I need."
    flexibility: HappinessRating!
    "My work environment feels inclusive and respectful of all people."
    inclusion: HappinessRating!
    "I often learn something at work."
    learning: HappinessRating!
    "My manager helps me succeed."
    management: HappinessRating!
    "I feel happy at work most of the time."
    overall: HappinessRating!
    "My work has a clear sense of purpose."
    purpose: HappinessRating!
    "There are people at work who give me support and encouragement."
    support: HappinessRating!
    "I can trust people in my company."
    trust: HappinessRating!
}

type HeaderImageUrlBundle {
    "Link to a header image (1960x400)"
    url1960x400: String!
    "Link to a header image (980x200)"
    url980x200: String!
}

"Result Payload for the `highlight review` mutation"
type HighlightReviewPayload {
    highlightedReview: HighlightedReview
}

"Result of highlightedReview query"
type HighlightedReview {
    countryCode: String!
    employerKey: String!
    languageCode: String!
    review: Review
}

"""

Entity that represents a hiring event - a period of time that an employer sets aside for physical
(similar a job fair) or non-physical (e.g. online, phone), queued interviews
"""
type HiringEvent {
    "The externally-facing identifier for the advertiser that created this event"
    advertiserNumber: ID
    "Information pertinent to how this hiring event should be advertised"
    advertising: HiringEventAdvertising!
    "Name of the company who is having the hiring event"
    companyName: String!
    "Points of contact for this event (e.g. employer emails)"
    contacts: HiringEventContacts!
    "Locale that the event's materials should be displayed in."
    eventLocale: String!
    "Indicates if the event has a linked advertisement id"
    hasLinkedAdvertisementId: Boolean!
    """

    Whether or not this Event has existing jobs opted in
    (as opposed to creating the jobs from scratch within the HiringEvents funnel)
    """
    hasOptInJobs: Boolean!
    "The hiring event's UUID"
    id: ID!
    "Information around the event's interviews"
    interviewConfig: HiringEventInterviewConfig!
    "Whether the event has been approved to go live by reps"
    isApproved: Boolean!
    """

    All the jobs for the event. This corresponds to the legacy HiringEvent Job -
    if it is a non-opt-in job then it will have 1+ locations nested in the locations field
    """
    jobs: [HiringEventJob!]!
    """

    Numeric Id of the event. This field is deprecated and should not be used.
    We already have an ID field but it is mapped to the UUID of the event
    """
    numericId: Int! @deprecated(reason: "No longer supported")
    "Information relevant to the event posting"
    posting: HiringEventPosting!
    """

    Count of RSVPs for this event
    IHPINTS-130: non-null
    """
    rsvpCount: Int!
    "Sources of referral that link to this hiring event (e.g. Instagram)"
    rsvpReferrers: [HiringEventRsvpReferrer!]!
    """

    "RSVPs to the event
    IHPINTS-107: non-null
    """
    rsvps: [HiringEventRsvp!]
    "Scheduling choices available for a jobseeker seeking an interview"
    schedulingChoices: [HiringEventSchedulingChoice!]!
    "Information around how candidates are screened for this hiring event"
    screening: HiringEventScreening!
    "Status of the hiring event (i.e. pending/scheduled/etc.)"
    status: HiringEventStatus!
}

type HiringEventAdvertising {
    """

    How much we should aim to spend for this event's advertising.
    Note that this only applies for events that has hiring events do advertising on their behalf
    """
    budget: HiringEventCurrencyAmount!
    """

    Whether this event should be advertised across the country
    (as opposed to where the job locations are or where the physical event location is).
    """
    remoteNationwideAdvertising: Boolean!
    """

    How much has been spent for this event's advertising.
    Note that this only applies for events that has hiring events do advertising on their behalf
    """
    spend: HiringEventCurrencyAmount
    "When to start advertising this event"
    startAdvertisingDatetime: DateTime
}

type HiringEventAvailabilityResource {
    "A reference to an external availability resource"
    availabilityId: ID
    "# of interviewers available / max interviews per slot"
    capacity: Int
    "The time periods available for interview scheduling"
    timePeriod: [HiringEventAvailablePeriod!]!
}

type HiringEventAvailabilitySlot {
    availableCapacity: Float!
    time: String!
}

type HiringEventAvailablePeriod {
    "End time of the period, inclusive"
    endTime: DateTime!
    "Start time of the period, inclusive"
    startTime: DateTime!
}

type HiringEventClientIntakeResult {
    "The contact infos of the clients"
    clientContacts: [HiringEventContactInfos!]!
    "The client intake type"
    clientIntakeType: HiringEventClientIntakeType!
    "The contact info of the client services representative"
    clientServicesContact: HiringEventContactInfos
    "Name of the company associated with the client intake"
    companyName: String!
    "The UUID of the client intake"
    id: ID!
    "The contact info of the sales representative"
    salesRepContact: HiringEventContactInfos
}

type HiringEventClientIntakesPayload {
    "The HiringEventClientIntakeResults"
    result: [HiringEventClientIntakeResult!]!
}

type HiringEventCompensation {
    "SUID of compensation frequency"
    compensationFrequencyKey: ID
    "Whether the provided compensation includes commission"
    includesCommission: Boolean!
    "The maximum compensation amount for this Job. If it is not a range then this value is equal to minAmount"
    maxAmount: HiringEventCurrencyAmount!
    "The minimum compensation amount for this Job. If it is not a range then this value is equal to maxAmount"
    minAmount: HiringEventCurrencyAmount!
}

type HiringEventContactInfos {
    "The email address of the contact"
    email: String!
    "The email UUID of the contact"
    emailId: ID!
}

type HiringEventContactInfosPayload {
    result: [HiringEventContactInfos!]!
}

"IHPINTS-131: all fields non-null"
type HiringEventContacts {
    "Contact info of the client services representative"
    clientServicesContact: HiringEventContactInfos
    "Contact infos of the internal-to-Indeed people who need to be in the loop about the hiring event"
    internalContacts: [HiringEventContactInfos!]!
    "Emails of the internal-to-Indeed people who need to be in the loop about the hiring event. Deprecated, prefer internalContacts."
    internalEmails: [String!]! @deprecated(reason: "No longer supported")
    "Contact infos of the people giving the interviews."
    interviewerContacts: [HiringEventContactInfos!]!
    "Emails of the people giving the interviews. Deprecated, prefer interviewer contacts"
    interviewerEmails: [String!]! @deprecated(reason: "No longer supported")
    "Contact infos of the people who need to be in the loop about administrative communications about the hiring event"
    reportContacts: [HiringEventContactInfos!]!
    "Emails of the people who need to be in the loop about administrative communications about the hiring event. Deprecated, prefer reportContacts."
    reportEmails: [String!]! @deprecated(reason: "No longer supported")
    "Contact info of the sales representative"
    salesRepContact: HiringEventContactInfos
}

type HiringEventCurrencyAmount {
    "Amount in smallest currency unit (e.g. Yen for JP, cents for US)"
    amountLocal: Int!
    "Currency that the amount is in"
    currency: HiringEventCurrency!
}

type HiringEventEnhancedScreeningCreatedResult {
    "Url to either Evaluate assesment (first submission, pending, failed) or event confirmation page (passed)."
    enhancedScreeningUrl: String!
    "A logging identifier corresponding to the RSVP attempt. One is generated regardless of creation success."
    rsvpAttemptId: ID!
    timePeriod: HiringEventAvailablePeriod
}

type HiringEventEnhancedScreeningRejectedReason {
    code: HiringEventEnhancedScreeningRejectedReasonCode!
    message: String!
}

type HiringEventEnhancedScreeningRejectedResult {
    reasons: [HiringEventEnhancedScreeningRejectedReason!]!
    "A logging identifier corresponding to the RSVP attempt. One is generated regardless of creation success."
    rsvpAttemptId: ID!
}

type HiringEventGenericOnlineLocation implements HiringEventLocation {
    countryName: String!
    formattedLocation: String!
    isRemote: Boolean!
    "A description of what tech requirements are needed to partake in the interview"
    technologyRequirements: String!
    timezone: String!
    "URL that the jobseeker should visit for the interview"
    url: String!
}

type HiringEventInterviewConfig {
    """

    Availability for the event. Note that this is independent of what has been booked thus far
    so is effectively the 'maximum' of what can be scheduled
    """
    availability: HiringEventAvailabilityResource!
    "How jobseekers should dress when attending the interview"
    dressCodeDescription: String!
    "Where the interviews take place"
    location: HiringEventLocation!
    "Items jobseekers should bring to their interview"
    requiredItems: [String!]!
    "Contains information on how interviews should be scheduled"
    schedulingConfig: HiringEventSchedulingConfig!
    "Indicates if the event uses the Indeed Remote Interviewing Platform"
    useIndeedRemoteInterviewingPlatform: Boolean!
}

type HiringEventJobAttributeFacet {
    count: Int!
    "[SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) of attribute"
    key: ID!
    "Localized label to explain attribute"
    label: String!
}

type HiringEventLobby {
    id: Int
    name: String!
}

type HiringEventPhoneLocation implements HiringEventLocation {
    countryName: String!
    formattedLocation: String!
    isRemote: Boolean!
    "Phone number that the jobseeker should call for the interview"
    phoneNumber: String!
    "A description of what tech requirements are needed to partake in the interview"
    technologyRequirements: String!
    timezone: String!
}

type HiringEventPhysicalLocation implements HiringEventLocation {
    """

    Broadest administrative division under the countryCode.

    Examples:
    - US - 'WA' (State) or 'PR' (Territory)
    - JP - 'JPC' (Region)
    - GB - 'ENG' (Country)
    - AU - 'QLD' (State) or 'NT' (Territory)
    """
    admin1Code: String!
    """

    Human readable version of the admin1Code.

    Examples:
    - US - 'Washington State' (State) or 'Puerto Rico' (Territory)
    - JP - '関東' (Region)
    - GB - 'England' (Country)
    - AU - 'Queensland' (State) or 'Northern Territory' (Territory)
    """
    admin1Name: String!
    """

    Typically represents a city; however, in some markets like Japan may represent a station or district name.

    Examples:
    - US - 'Bellingham'
    - JP - '新宿駅' (Station) '赤坂' (District)
    - GB - 'Birkenhead'
    - AU - 'Brisbane'
    """
    city: String!
    countryName: String!
    formattedLocation: String!
    "The ID of the HiringEvent physical location entity"
    id: ID!
    "True if the location is invisible on the event page since it is for advertising but not hiring"
    isAdvertisingOnlyLocation: Boolean!
    isRemote: Boolean!
    """

    Display name of the location.

    Examples:
    - US - 'The Driskill Hotel'
    """
    name: String!
    "ZIP code / Postal Code"
    postalCode: String!
    """

    Street address

    Examples:
    - US - '3551 West Olympic Boulevard'
    """
    streetAddress: String!
    timezone: String!
}

"All the details about an Event that are mostly for the posting"
type HiringEventPosting {
    "Url for submitting an application to the company"
    applicationUrl: String!
    "Blob of rich-text information about the company"
    companyAboutHTML: String!
    "The custom perks of the Event (e.g. bagels & coffee)"
    customPerks: [String!]!
    "Blob of rich-text directions for the event"
    directionsHTML: String!
    "Requirements for attending the event"
    eventRequirements: [String!]!
    "The predefined perks of the Event"
    genericPerks: [HiringEventGenericPerk!]!
    "Blob of rich-text description for what a hiring event is"
    hiringEventIntroHTML: String!
    "The URL that leads to the page for viewing the job/RSVP'ing"
    interviewJobPageUrl: String!
    "Whether the event offers interviews"
    interviewsOffered: Boolean!
    "The company's logo displayed on the event posting"
    logoUrl: String!
    "Whether the event gives offers immediately after the interview"
    offersOnTheSpot: Boolean!
    "Whether the event gives offers within 30 days of the interview"
    offersWithin30Days: Boolean!
    "Title of the event posting"
    title: String!
    "A youtube url which is embedded on the event posting"
    youtubeUrl: String!
}

type HiringEventRsvp {
    accountKey: ID!
    conductorExternalId: ID!
    desiredJobLocationId: ID!
    desiredJobTitle: String!
    email: String!
    firstName: String!
    hiringEvent: HiringEvent
    id: ID!
    joinInterviewUrl: String!
    lastName: String!
    phone: String!
    sourceJobKey: String!
    status: HiringEventRsvpStatus!
    timePeriod: HiringEventAvailablePeriod
    vipId: ID
}

type HiringEventRsvpCreatedResult {
    rsvp: HiringEventRsvp!
    "A logging identifier corresponding to the RSVP attempt. One is generated regardless of creation success."
    rsvpAttemptId: ID!
}

type HiringEventRsvpReferrer {
    "The tracking code for the referrer (e.g. fb, oj, sj)"
    trackingCode: String!
}

type HiringEventRsvpRejectedReason {
    code: HiringEventRsvpRejectedReasonCode!
    message: String!
}

type HiringEventRsvpRejectedResult {
    reasons: [HiringEventRsvpRejectedReason!]!
    "A logging identifier corresponding to the RSVP attempt. One is generated regardless of creation success."
    rsvpAttemptId: ID!
}

type HiringEventRsvpResult {
    hiringEventRsvp: HiringEventRsvp!
}

type HiringEventRsvpsPayload {
    result: [HiringEventRsvpResult!]!
}

"""

This corresponds to the scheduling choices available for a jobseeker seeking an interview.
There are 5 cases for how this data may be represented
1) The event does not use timeslots and has no max for rsvps
2) The event does not use timeslots and has an event max for rspvs
3) The event uses timeslots and has no max for rsvps
4) The event uses timeslots and has an event max for rsvps
5) The event uses timeslots and has a rsvp max per timeslot
"""
type HiringEventSchedulingChoice {
    "# of interviews rsvp'd per slot or event"
    count: Int!
    """

    How many more people can be schedule into the time period
    When this field is null, there is no rsvp max capacity for the event or timeslot if timeslots are used
    When the event uses timeslots and has timeslot rsvp max, this field represents the capacity remaining for this slot
    When the event uses event rsvp max, this field represents the remaining capacity for the whole event
    """
    remainingCapacity: Int
    """

    Period of time available
    This field can be represented through event timeslots or event sessions depending on if the event uses timeslots
    """
    timePeriod: HiringEventAvailablePeriod!
}

type HiringEventSchedulingConfig {
    """

    The maximum number of rsvps per event.
    This is used only for events where there are no 'interview slot caps/maximums'
    """
    maxRsvpsPerEvent: Int
    "The duration of the scheduling choices that the job-seeker sees (e.g. 30 minutes)"
    timeSlotDurationMs: Int!
    "Whether or not interview slots should be used (as opposed to having big time chunks)"
    useInterviewSlots: Boolean!
}

type HiringEventScreening {
    "Requirements for attending the interview. Not necessarily Yes/no, they will just get displayed as requirements"
    requirements: [String!]!
    "Yes/no screening questions to be used for jobseeker screening"
    screeningQuestions: [HiringEventScreeningQuestion!]!
}

"""

The internal Hiring Events screening question model.
This is a simple yes/no question model that is not intended for expansion.
We would rather use more sophisticated systems (e.g. Dradis job screening) to accomplish this going forward
"""
type HiringEventScreeningQuestion {
    "Whether the correct answer is yes or no"
    correctAnswer: Boolean!
    id: ID!
    "Whether the jobseeker should be permitted to rsvp if they provide an incorrect answer"
    isKnockout: Boolean!
    "The yes/no question"
    text: String!
}

type HiringEventVIPLocation implements HiringEventLocation {
    countryName: String!
    formattedLocation: String!
    isRemote: Boolean!
    "The ID corresponding to the external lobby ID (i.e. VIP lobby ID)"
    lobbyId: ID
    "A description of what tech requirements are needed to partake in the interview"
    technologyRequirements: String!
    timezone: String!
}

"Information about an employer."
type HostedEmployer {
    "Is this employer an ad agency? Default: false."
    adAgency: Boolean
    """

    The employer's attributes.
    Only attributes whose key is in argument keys will be shown, null keys will result in null attributes.
    """
    attributes(keys: [String!]): [KeyValuePair!]
    "The employer's billing information."
    billing: HostedEmployerBilling
    "Currency for billing. If this field is absent in employer creation, it will be the default currency of the employer country."
    billingCurrency: BillingCurrencyCode
    "The employer's company information."
    company: HostedEmployerCompany!
    "Country where this Employer is located. Default: US"
    country: CountryCode
    "Date this employer was created. Format: [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) international date time."
    dateCreated: DateTime
    "This employer's type."
    employerType: HostedEmployerType
    "Does this employer have hosted job apply URL?"
    hasHostedApplyUrl: Boolean
    "Has this employer hosted any jobs?"
    hasHostedJobs: Boolean
    "Returns true if employer has at least one verified job source."
    hasVerifiedSources: Boolean
    "Is this employer able to access, create and sponsor jobs?"
    hostedJobsEnabled: Boolean
    "The employer's id."
    id: ID!
    "Industry of employer."
    industry: HostedEmployerIndustry
    "Is the primary employer for the account?"
    isPrimary: Boolean!
    "Is this employer using sponsor-all budget plan."
    isSponsorAll: Boolean
    """

    Does the employer's verified job source's sitename start with "dradis_"?
    (Meaning this employer is using the dradis hack.)
    """
    isVerifiedSourceSiteNameDradis: Boolean
    "Language for billing. Default: en"
    language: LanguageCode
}

"Address of company."
type HostedEmployerAddress {
    "Primary street address"
    address1: String
    "Secondary address (suite/apt #)"
    address2: String
    "Province/state code"
    admin1Code: String
    "City name"
    city: String
    "Postal/zip code"
    postalCode: String
}

"An employer's billing information."
type HostedEmployerBilling {
    "The employer's state. I.e. waiting for approval, approved, or disabled."
    billingState: HostedEmployerBillingState
    "The employer's billing-contact email. Format: 'name@domain'. Maximum length should not exceed 200 characters."
    email: EmailAddress
    "The employer's payment method."
    paymentMethod: HostedEmployerPaymentMethod
}

"An employer's company information."
type HostedEmployerCompany {
    "The company's location."
    address: HostedEmployerAddress
    "The name of the company's primary context (a person)."
    contact: String
    "Approximate employee count."
    employeeCount: HostedEmployerEmployeeCount
    "The company's name."
    name: String
    "The phone number of the company's primary contxt. The minimum length is 5 digits."
    phone: String
    "The company's web site URL. Must begin with 'http://' or 'https://'."
    url: WebUrl
}

"This result type returend by a `hostedEmployers` query. Each result contains an employer object returned by the query."
type HostedEmployerResult {
    "The employer."
    hostedEmployer: HostedEmployer!
}

"This payload type returned by a `hostedEmployers` query."
type HostedEmployersPayload {
    "The list of results."
    results: [HostedEmployerResult!]!
    "Total number of results."
    totalCount: Int
}

type HostedJobMatchingStringsPayload {
    result: HostedJobMatchingStringsResult!
}

type HostedJobMatchingStringsResult {
    hostedJobMatchingString: [Matching]
}

type HostedJobMessagingTagPayload {
    "The result of Hosted job messaging tag."
    result: HostedJobMessagingTagResult!
}

type HostedJobMessagingTagResult {
    "Visibility of the job as determined by Wenda"
    estimatedVisibility: HostedJobPostVisibility
    "Whether this messagingTag data is estimated."
    isEstimated: Boolean!
    "Job Key"
    jobKey: String
    "Indication to the caller to exclude certain feature, example: 'APPEAL'"
    msgTagResultExclude: [HostedJobPostExcludeOption!]!
    "structured tags."
    structuredTags: [StructuredTag!]!
}

type HostedJobMessagingTagsPayload {
    result: HostedJobMessagingTagsResult!
}

type HostedJobMessagingTagsResult {
    jobMessagingTags: [HostedJobMessagingTagResult]!
}

type HostedJobPost implements EmployerJobPostCapabilityInterface & JobPostInterface {
    "List of advertising locations for this job."
    advertisingLocations: [PublishedAdvertisingLocation!]!
    """

    An apply method, look at specific implementation
    for details.
    """
    applyMethod: JobPostApplyMethodInterface!
    """

    List of extended job attributes.
    Only attributes whose key is in argument `keys` will be shown.
    """
    attributes(keys: [String!]): [KeyValuePair!]!
    """

    The hiring company name.
    The maximum length for the company name should not exceed 200
    characters.
    """
    company: String!
    "Country where this Job is located."
    country: CountryCode!
    "Is cover letter required?"
    coverLetterRequired: JobRequirement
    "Encrypted account ID of original author."
    createdByAccount: ID
    "Date this was created."
    dateCreated: DateTime!
    "Date this was most recently modified."
    dateLastModified: DateTime!
    """

    The job description.
    Markdown formatting may be used:
    For _italics_ use underscores: `_italics_`
    For emphasis use asterisks: `*bold*`
    For line breaks use: `\n`
    For bullets use an asterisk and a space: `* Item`
    The minimum length for the job description should be 30
    characters and the maximum length should not exceed 20000.
    """
    description: String!
    "The globally unique UUID for a job post."
    id: ID!
    isRecommendedJob: Boolean
    "The full street address where work will be performed."
    jobAddress: String
    "The jobKey for the first activce location of this HJP"
    jobKey: String
    "List of job types."
    jobTypes: [JobType!]!
    "The language in which this Job is presented to candidates."
    language: LanguageCode
    """

    The legacy ID (encrypted ATS Job ID) of a job post. This should only be used by applications that absolutely require
    the encrypted ATS Job ID. In all other cases, use `id`.
    """
    legacyId: ID @deprecated(reason: "Use `id`.")
    "The taxonomy UUID that identifies the job occupation."
    occupationUuid: String
    "Indicating the origin of this job."
    origin: JobPostOrigin!
    "Is phone required?"
    phoneRequired: JobRequirement
    "Is resume required?"
    resumeRequired: JobRequirement
    "Job salary period and range amounts."
    salary: JobSalary
    "Status of the job."
    status: HostedJobPostStatus!
    "List of taxonomy attributes"
    taxonomyAttributes: [JobPostTaxonomyCustomClassAttributes!]!
    """

    The job post title
    The maximum length for the job title should not exceed 75
    characters.
    """
    title: String!
}

"Response payload for HostedJobPostCounts"
type HostedJobPostCountsPayload {
    "Result for hosted job post counts"
    result: HostedJobPostCountsResult
}

"Result for HostedJobPostCounts"
type HostedJobPostCountsResult {
    "Count by status"
    countByStatus: CountByStatus
    "Total count of the HostedJobPost"
    totalCount: Int
}

type HostedJobPostPerformancePayload {
    "The result of the performance query"
    result: HostedJobPostPerformanceResult!
}

type HostedJobPostPerformanceResult {
    "The organic job performance statistics"
    organicPerformanceMetrics: PerformanceMetrics!
    "The sponsored job performance statistics"
    sponsoredPerformanceMetrics: PerformanceMetrics!
}

type HostedJobPostVisibilityPayload {
    "The result of job’s visibility"
    result: HostedJobPostVisibilityResult!
}

type HostedJobPostVisibilityResult {
    "Visibility level"
    level: HostedJobPostVisibility!
}

"Response payload from hostedJobPosts()"
type HostedJobPostsPayload {
    "Matching results. Maximum of 100."
    results: [HostedJobPostsResult!]!
    "Total number of results."
    totalCount: Int
}

"Hosted Job Post result."
type HostedJobPostsResult {
    "Hosted job post"
    hostedJobPost: HostedJobPost!
}

type HttpStatusReadable {
    "Http status code"
    code: Int!
    "Description of issue"
    description: String!
}

"""

Client State Details for ITA to be set on Client Side

Currently the state is recorded by most consumers in cookies
"""
type ITAHistoryClientState {
    "Client State Name"
    name: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Client State Time-to-Live"
    ttlSeconds: Int @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Client State Value"
    value: String @deprecated(reason: "targeted-content-service no longer supports ITA")
}

type IhpAggJobPost {
    aggJob: Job
    isRecommendedJob: Boolean
}

type IhpIsRecommendedJobPayload {
    job: IhpJobRecommendation
}

type IhpJobRecommendationEdge {
    cursor: String!
    node: IhpJobRecommendation!
}

type IhpJobRecommendationsConnection {
    edges: [IhpJobRecommendationEdge!]!
    pageInfo: PageInfo!
}

"Entity that holds information aboud the advertiser subscription status"
type IhpSubscription {
    "The externally-facing identifier for the advertiser that created this event"
    advertiserNumber: String!
    "Status of the subscription (ACTIVE / DISABLED)"
    status: IhpAdvertiserSubscriptionStatus!
}

"Wrapper for the result payload of advertiserSubscription"
type IhpSubscriptionPayload {
    "advertiserSubscription result list"
    result: [IhpSubscription!]!
}

type ImageBundle {
    "Link to CEO photo (400x400)"
    ceoPhotoUrl: String @deprecated(reason: "Use ceoPhotoUrls")
    "Links to CEO photos"
    ceoPhotoUrls: CeoPhotoUrlBundle
    "Link to a header image (980x200)"
    headerImageUrl: String @deprecated(reason: "Use headerImageUrls")
    "Links to header images"
    headerImageUrls: HeaderImageUrlBundle
    "Link to a wide logo (400x160)"
    rectangularLogoUrl: String
    "Link to a square logo (400x400)"
    squareLogoUrl: String @deprecated(reason: "Use squareLogoUrls")
    "Links to square logos"
    squareLogoUrls: SquareLogoUrlBundle
}

"""

Rules that specify when an [AvailabilityResource] is potentially available for
events to be scheduled.
"""
type IncludeAvailabilitySettings implements AvailabilitySettings {
    periods(after: String, endTime: DateTime, first: Int, includeOverlapping: Boolean = true, startTime: DateTime): AvailabilityPeriodConnection!
    week(input: WeekAvailabilityRulesFilterInput): WeekAvailabilityRules!
}

type IndeedApplyAssessment {
    "Estimated time to complete the assessment in minutes"
    estimatedDurationInMinutes: Int
    "Id of the assessment"
    id: String!
    "Name of the assessment"
    name: String!
}

type IndeedApplyAssessmentsExpectation implements IndeedApplyExpectation {
    "Details of assessments required for a given job"
    details: [IndeedApplyAssessment!]!
    "If jobSeeker is expected to take assessments"
    expected: Boolean!
}

type IndeedApplyCoverLetterExpectation implements IndeedApplyExpectation {
    "If job requires cover letter"
    expected: Boolean!
}

type IndeedApplyExpectations {
    "Assessment requirements for a given job and jobseeker"
    assessments: IndeedApplyAssessmentsExpectation
    "Cover Letter requirements for a given job and jobseeker"
    coverLetter: IndeedApplyCoverLetterExpectation
    "finishApp requirements for a given job and jobseeker"
    finishApp: IndeedApplyFinishAppExpectation
    "If resume is required to apply for a given job and jobseeker"
    resume: IndeedApplyResumeExpectation
    "Minimum and maximum questions that could be answered for this application"
    screenerQuestions: IndeedApplyScreenerQuestionsExpectation
}

type IndeedApplyFinishAppExpectation implements IndeedApplyExpectation {
    "If jobSeeker is supposed to submit more details after IA submission"
    expected: Boolean!
}

type IndeedApplyResumeExpectation implements IndeedApplyExpectation {
    "If job requires an resume but jobSeeker doesn't have a saved resume"
    expected: Boolean!
}

type IndeedApplyScreenerQuestionsExpectation implements IndeedApplyExpectation {
    "If the job requires questions to be answered."
    expected: Boolean!
    "Max questions that can be answered in a given job"
    maxQuestions: Int!
    "Min questions that can be answered in a given job"
    minQuestions: Int!
}

type IndeedJobData {
    "url to redirect to jobclick-daemon and then view job page"
    viewJobRedirectClickUrl: WebUrl!
}

type InterviewDifficultySummary {
    average: InterviewDifficulty!
    totalCount: Int!
}

type InterviewExperienceSummary {
    average: InterviewExperience!
    totalCount: Int!
}

type InterviewProcessLengthSummary {
    average: InterviewProcessLength!
    totalCount: Int!
}

type InterviewStats {
    difficulty: InterviewDifficultySummary!
    experience: InterviewExperienceSummary!
    processLength: InterviewProcessLengthSummary!
}

"IP Address"
type IpAddress {
    "Human-readable localized geo-location of the IP address"
    geoLocation: String
    """

    IP Address
    Note: marked as @deprecated until @hidden is implemented in APIPLAT-244
    """
    ipAddress: String! @deprecated(reason: "No longer supported")
}

type Job {
    """

    **Example:**

    Get attributes for job types or remote as a separate field

    ```
    jobTypes: attributes ( keys: ["DSQF7"] customClass: "BM62A" ) {
    key
    label
    }
    ```
    """
    attributes(
        """

        Provide a [custom class](https://wiki.indeed.com/display/MetadataTaxonomy/Custom+Classes) SUID to restrict which attributes are returned.

        Example: "BM62A" (Job Type)
        """
        customClass: ID,
        """

        Restrict attributes by specified [SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) keys.
        If multiple keys and/or customClass are provided, attributes matching at least one key/customClass are returned.
        If no keys and customClass are provided, all attributes are returned.

        Example: "DSQF7" (Remote)
        """
        keys: [ID!]
    ): [JobAttribute!]!
    compensation: JobCompensation
    "Last annotated date by JUA"
    dateLastAnnotated: Timestamp
    "The date this Job was made available on Indeed"
    dateOnIndeed: Timestamp!
    datePublished: Timestamp!
    description: JobDescription!
    employer: Employer
    expired: Boolean!
    feed: JobFeed!
    """

    Exposes URLs for glassdoor

    Value will be null if and only if we fail to generate valid URLs
    """
    glassdoor: GlassdoorJobData
    "Exposes information about Indeed applyabilty of the Job"
    indeedApply: JobIndeedApplyAttributes!
    """

    To request this field you have to have the allow-fraudulent-jobs role. See the Http Headers section in the jobData API schema documentation.

    In jobData and _entities, the value of this field is true if the job is confirmed fraudulent. Such a job does not appear in normal search results.

    In other APIs, the value of this field is always false.
    """
    isConfirmedFraudulent: Boolean!
    key: ID!
    "The detected language of the Job's description and title. Format: ISO-639 alpha-2 (Example: \"en\", \"fr\")"
    language: String!
    location: JobLocation!
    "A canonical title resolved by Indeed from the Job title."
    normalizedTitle: String
    occupations: [JobOccupation!]!
    savedJob: SavedJob
    source: JobSource!
    """

    Employer name associated with the job at the time of aggregation by Indeed

    This may differ from the `Employer.name` which represents the canonical employer identity

    See `Employer`
    """
    sourceEmployerName: String!
    title: String!
    url: String!
}

"""

A skill, experience, certification, benefit, work environment, work type, or other distinguishing characteristic of a job or jobseeker.

Reference: [Indeed Attributes](https://wiki.indeed.com/display/MetadataTaxonomy/Indeed+Attributes)
"""
type JobAttribute {
    "[SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) of attribute"
    key: ID!
    "Localized label to explain attribute"
    label: String!
}

"""

Facet representation of a `JobAttribute`

Results can be utilized in `keyword` filters with field "attributes" to the restrict search result set.

**Example**

```
filters: [
{
keyword: {
field: "attributes"
keys: [
"CF3CP", # Full-time
"75GKK"  # Part-time
]
operation: OR
}
}
]
```

See `filters.keyword` for usage in filters.
"""
type JobAttributeFacet {
    count: Int!
    "[SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) of attribute"
    key: ID!
    "Localized label to explain attribute"
    label: String!
}

"Client State Details for Relevant Job to be set on Client Side when job click triggers"
type JobClickClientState {
    "Client State Name"
    name: String
    "Client State Time-to-Live"
    ttlSeconds: Int
    "Client State Value"
    value: String
}

"""

Facet representation of company sectors

Results can be utilized in `keyword` filters with field "companySectors" to restrict the search result set.

**Example**

```
filters: [
{
keyword: {
field: "companySectors"
keys: [
"XRQMJ", # Food & Beverage Stores
"ABCS6"  # Shipping & Trucking
]
operation: OR
}
}
]
```

See `filters.keyword` for usage in filters.
"""
type JobCompanySectorFacet {
    count: Int!
    "[SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) of company sector"
    key: ID!
    "Localized label to explain company sector"
    label: String!
}

type JobCompensation {
    baseSalary: Salary
    currencyCode: String
    """

    Text summary of complete salary data. E.g. `$15 - $21 an hour`, `$55,000 a
    year`, and so on. The content is localized via the `locale` HTTP request
    parameter. E.g. `$12 - $13 por hora` when `locale=es-US`.

    Note also that the country part of the locale has to match the currency of
    the salary data represented by `key`. E.g. `US` matches `USD` and `JP`
    matches `JPY`. In the case of a mismatch the `JobCompensation` would be
    `null`.
    """
    formattedText: String
    key: ID!
    salarySource: String
}

type JobDataPayload {
    results: [JobDataResult!]!
}

type JobDataPrice {
    type: JobPricingModel!
    value: Int!
}

type JobDataResult {
    job: Job!
    """

    Globally unique tracking key for this `JobDataResult`. The type for this tracking key is currently set to 1.

    Tracking key format: {version}-{type}-{requestTrackingKey}-{jobSearchTrackingKey}-{jobKey}-{encodedAdData}
    """
    trackingKey: ID!
}

type JobDescription {
    hash32: Int
    html: String!
    text: String!
}

type JobFeed {
    """

    The source type associated to the feed. It may be null if the feed is tied to any other type defined in `JobSourceType`
    or it is a new feed whose information is not available yet.
    """
    feedSourceType: JobSourceType
    isDradis: Boolean!
    "An encrypted ID of the feed. Please follow https://wiki.indeed.com/x/YFcMFg if you have to get the raw ID."
    key: ID!
}

type JobIndeedApplyAttributes {
    "An ApplyLink representing the link to the Indeed Apply web-based apply flow."
    applyLink(
        """

        A URL that the user agent will be redirected to
        once the apply flow is completed.
        """
        continueUrl: String,
        """

        The ApplyDomainProperty specifying the type of location
        the link will be displayed on.
        """
        property: ApplyDomainProperty!
    ): ApplyLink
    "Provides the details of what jobseeker needs to do to complete an application for an IndeedApplyable job"
    expectations: IndeedApplyExpectations
    """

    The Base64-encoded JSON containing [Indeed Apply Button API](https://wiki.indeed.com/display/APPLY/Indeed+Apply+Button+API) parameters.

    Note that this does not contain every required parameter. At least the following parameters need to be added when calling Indeed Apply Button API.
    - `referer`

    Value will be `null` if the Job is not Indeed applyable.
    """
    key: ID
    """

    Indicates on which platform the Job is considered Indeed applyable. For example, if `scopes` only contains `MOBILE`,
    all applies to non mobile platforms "should" not be integrated with Indeed Apply.

    Will be empty if the Job is not considered Indeed applyable.
    """
    scopes: [JobIndeedApplyScope!]!
}

"""

Represents the location of the Job

It is advised to leverage the FormattedJobLocation fields for display purposes.
"""
type JobLocation {
    """

    Broadest administrative division under the countryCode.

    Examples:
    - US - 'WA' (State) or 'PR' (Territory)
    - JP - 'JPC' (Region)
    - GB - 'ENG' (Country)
    - AU - 'QLD' (State) or 'NT' (Territory)
    """
    admin1Code: String
    """

    Human readable version of the admin1Code.

    Examples:
    - US - 'Washington State' (State) or 'Puerto Rico' (Territory)
    - JP - '関東' (Region)
    - GB - 'England' (Country)
    - AU - 'Queensland' (State) or 'Northern Territory' (Territory)
    """
    admin1Name: String
    """

    2nd level administrative division under the countryCode.

    Examples:
    - US - '073' (County)
    - JP - 'J13' (Prefecture)
    - GB - 'NW' (Region)
    - AU - not set
    """
    admin2Code: String
    """

    Human readable version of the admin2Code.

    Examples:
    - US - 'Whatcom County' (County)
    - JP - '東京都' (Prefecture)
    - GB - 'North West' (Region)
    - AU - not set
    """
    admin2Name: String
    """

    3rd level administrative division under the countryCode.

    Examples:
    - US - not set
    - JP -'J3100174' (District) 'J4271004' (Seirei Shitei Toshi)
    - GB - 'MSY' (County)
    - AU - not set
    """
    admin3Code: String
    """

    Human readable version of the admin3Code.

    Examples:
    - US - not set
    - JP - '石川郡' (District) '大阪市' (Seirei Shitei Toshi)
    - GB - 'Merseyside' (County)
    - AU - not set
    """
    admin3Name: String
    """

    4th level administrative division under the countryCode.

    Examples:
    - US - not set
    - JP - 'J4131032' (Ward) 'J4252085' (City)
    - GB - not set
    - AU - not set
    """
    admin4Code: String
    """

    Human readable version of the admin4Code.

    Examples:
    - US - not set
    - JP - '港区' (Ward) '栗東市' (City)
    - GB - not set
    - AU - not set
    """
    admin4Name: String
    """

    Typically represents a city; however, in some markets like Japan may represent a station or district name.

    Examples:
    - US - 'Bellingham'
    - JP - '新宿駅' (Station) '赤坂' (District)
    - GB - 'Birkenhead'
    - AU - 'Brisbane'
    """
    city: String
    "Country code for which the job is located. Format: ISO 3166-1 alpha-2 (Example: \"CA\")"
    countryCode: String!
    """

    Full country name

    Examples:
    - US - 'United States'
    - JP - '日本'
    - GB - 'United Kingdom'
    - AU - 'Australia'
    """
    countryName: String
    formatted: FormattedJobLocation!
    "Point coordinate. This most commonly represents the geometric centroid of the most granular resolved layer (admin1-4, city, or postalCode)."
    latitude: Float!
    "Point coordinate. This most commonly represents the geometric centroid of the most granular resolved layer (admin1-4, city, or postalCode)."
    longitude: Float!
    """

    The location name of the neighborhood

    Examples:
    - US - 'Mid City'
    """
    neighborhood: String
    "ZIP code / Postal Code"
    postalCode: String
    """

    Street address

    Examples:
    - US - '3551 West Olympic Boulevard'
    """
    streetAddress: String
}

type JobLocationFacet {
    """

    Broadest administrative division under the countryCode.
    The meaning is the same as `JobLocation`.
    """
    admin1Code: String
    """

    2nd level administrative division under the countryCode.
    The meaning is the same as `JobLocation`.
    """
    admin2Code: String
    """

    3rd level administrative division under the countryCode.
    The meaning is the same as `JobLocation`.
    """
    admin3Code: String
    """

    4th level administrative division under the countryCode.
    The meaning is the same as `JobLocation`.
    """
    admin4Code: String
    """

    Typically represents a city; however, in some markets like Japan may represent a station or district name.
    The meaning is the same as `JobLocation`.
    """
    city: String
    count: Int!
    """

    Combination of admin codes and city delimited by '|'.
    Separate fields provide the actual values if they are not empty.
    """
    key: String!
}

"A conceptual representation of a group of jobs that share similar characteristics."
type JobOccupation {
    "[SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) of occupation"
    key: ID!
    "Localized label to explain occupation"
    label: String!
}

"""

Facet representation of a `JobOccupation`

Results can be utilized in `keyword` filters with field "occupations" to restrict the search result set.

**Example**

```
filters: [
{
keyword: {
field: "occupations"
keys: [
"C3XKZ", # Retail Associates & Cashiers
"KNBYF"  # Quick Service Servers
]
operation: OR
}
}
]
```

See `filters.keyword` for usage in filters.
"""
type JobOccupationFacet {
    count: Int!
    "[SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) of occupation"
    key: ID!
    "Localized label to explain occupation"
    label: String!
}

"""

Apply by email, example usage:
applyMethod {
... on JobPostEmailApplyMethod {
emails
}
}
"""
type JobPostEmailApplyMethod implements JobPostApplyMethodInterface {
    "List of email addresses"
    emails: [EmailAddress!]!
    "Enum indicating apply method"
    method: JostPostApplyMethodType
}

"""

Apply in person, example usage:
applyMethod {
... on JobPostInPersonApplyMethod {
address
instructions
latitude
longitude
}
}
"""
type JobPostInPersonApplyMethod implements JobPostApplyMethodInterface {
    "Address of place to apply in-person"
    address: String!
    "Instructions for how to apply in-person"
    instructions: String
    "Latitude of place to apply in-person"
    latitude: Float
    "Longitude of place to apply in-person"
    longitude: Float
    "Enum indicating apply method"
    method: JostPostApplyMethodType
}

type JobPostTaxonomyAttribute {
    """

    Text describing what the attribute represents. This may be the
    official taxonomy label or custom text.
    Required for all attribute types except for NONE.
    Limit of 255 characters.
    """
    label: String
    """

    The type of attribute being provided, which may be one of
    OFFICIAL, EXPERIMENTAL, OTHER, or NONE.
    """
    type: TaxonomyAttributeType!
    """

    The taxonomy identifier (UUID) for the attribute.
    Required for OFFICIAL and EXPERIMENTAL attribute types.
    """
    uuid: ID!
}

type JobPostTaxonomyCustomClassAttributes {
    "Taxonomy attributes associated with the custom class"
    attributes: [JobPostTaxonomyAttribute!]!
    "The taxonomy identifier (UUID) for the custom class."
    customClassUuid: String!
}

"""

Apply by website, example usage:
applyMethod {
... on JobPostWebsiteApplyMethod {
url
}
}
"""
type JobPostWebsiteApplyMethod implements JobPostApplyMethodInterface {
    "Enum indicating apply method"
    method: JostPostApplyMethodType
    """

    The URL must be a valid URL beginning with 'http://' or 'https://'.
    The maximum length for the url should not exceed 2000 characters.
    """
    url: WebUrl!
}

type JobSalary {
    "Maximum amount in LOCAL MINOR CURRENCY"
    maximumMinor: Int
    "Minimum amount in LOCAL MINOR CURRENCY"
    minimumMinor: Int
    "Period to pay"
    period: JobSalaryPeriod!
}

type JobSearchAuction {
    type: JobPricingModel!
    value: Int!
}

type JobSearchCompensationBaseAnnualSalaryFacet {
    "The count of jobs whose values of base salary are in this range."
    count: Int!
    """

    The minimum value of this range (exclusive upper bound).
    In the last range this value is null, and in other ranges it is identical to `min` in the next range.
    """
    max: Int
    """

    The minimum value of this range (inclusive lower bound).
    In the first range this value is null, and in other ranges it is identical to `max` in the previous range.
    """
    min: Int
}

type JobSearchCompensationBaseAnnualSalaryRanges {
    ranges: [JobSearchCompensationBaseAnnualSalaryFacet!]!
}

type JobSearchCompensationFacet {
    """

    Best available salary in local currency, sourced from extracted salary, estimated salary or override values.

    The returned list consists of ranges of salary which are dynamically determined from the distribution of salary.
    These ranges are distinct and sorted.
    The number of returned ranges is at most `maxNumRanges` but may be smaller depending on the distribution.

    **Note:** It is prohibited to request multiple `baseAnnualSalary` facets in a single search request.
    """
    baseAnnualSalary(
        "Maximum number of ranges to be returned. This must be between 1 and 50, inclusive."
        maxNumRanges: Int!,
        "The shortest possible width (i.e., `max` - `min`) of each range. Some default value is used if this is not provided."
        minRangeWidth: Int
    ): JobSearchCompensationBaseAnnualSalaryRanges!
    "[ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code"
    currencyCode: String!
}

"""

Represents a single date facet value.

Values for `label`, `start`, and `end` are sourced from respective `JobSearchDateFacetIntervalInput` values.

Results can be utilized in "date" filters with the same field to restrict search result set.

**Example**

```
filters: [
{
date: {
field: "dateOnIndeed",
start: "1d"
}
}
]
```

See `filters.date` for usage in filters.
"""
type JobSearchDateFacet {
    count: Int!
    end: String
    """

    Represents the absolute time for "end"

    Set to "now" when end is null
    """
    endTime: Timestamp!
    label: String!
    start: String
    """

    Represents the absolute time for "start"

    Set to 0 when start is null
    """
    startTime: Timestamp!
}

"""

A collection of search facets.

Useful for retrieving the number of job in the overall result set that match a certain criteria (e.g., number of
jobs new to Indeed in the last 7 days).

Reference: [Faceted Search](https://en.wikipedia.org/wiki/Faceted_search)
"""
type JobSearchFacets {
    """

    Provides facets resulted to the `Job.attributes` field

    Results are in descending order based on the `count`

    It is valid to specify any combination of the `top`, `keys`, and `customClass` fields. There result will be the
    union of all attributes matched by each field's behaviour

    **Examples:**
    - `top:5 customClass: "BM62A"` will return the top 5 most common attributes under the specified customClass.
    - `top:5 customClass: "BM62A" keys: [ "CF3CP", "75GKK" ]` will return the top 5 attributes under customClass "BM62A" AND well as counts for keys "CF3CP" and "75GKK".

    **Use case:** remote jobs faceting
    Currently, we support 2 SUIDs for remote jobs:
    - "DSQF7": Remote (A job that can be performed entirely remotely. May involve on-site training or an on-site interview.)
    - "VAMUB": Temporarily remote (COVID-19)

    Please use them for remote jobs faceting. Example:
    ```
    facets {
    remote: attributes ( keys: [ "DSQF7", "VAMUB"] ) {
    key
    label
    count
    }
    }
    ```

    You can also use these SUIDs in the keyword filter with field name "attributes". Example:
    ```
    filters: [
    {
    keyword: {
    field: "attributes"
    keys: ["DSQF7"]
    }
    }
    ]
    ```
    """
    attributes(
        """

        Used to restrict `top` job attributes to the specified custom class. For example return the top 5 job types
        (customClass: "BM62A").

        Note: no validation is made on value. If `customClass` does not exist 0 facets will be returned

        **Supported Values:**
        - BM62A : Job Types
        - YYMAS : Contract Types
        """
        customClass: ID,
        """

        Return facets for each of the specified [SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) keys.

        Will return counts for all specificed keys.
        Keys are limited to a maximum 25.

        Note: no validation is made on keys
        """
        keys: [ID!],
        """

        Return the top most frequent job attributes contained in the result set up to the number requested.

        Defaults to 5 if `keys` is null or empty; 0 otherwise.
        Must be at least 1 and at most 25 when specified.

        See `customClass`
        """
        top: Int
    ): [JobAttributeFacet!]!
    """

    Provides facets for company sectors

    Results are in descending order based on the `count`

    It is valid to specify any combination of the `top` and `keys` fields.
    There result will be the union of all company sectors matched by each field's behaviour

    **Examples:**
    - `top:5 keys: [ "XRQMJ", "ABCS6" ]` will return the top 5 company sectors as well as counts for keys "XRQMJ" and "ABCS6".

    You can also use these SUIDs in the keyword filter with field name "companySectors". Example:
    ```
    filters: [
    {
    keyword: {
    field: "companySectors"
    keys: ["XRQMJ"]
    }
    }
    ]
    ```
    """
    companySectors(
        """

        Return facets for each of the specified [SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) keys.

        Will return counts for all specificed keys.
        Keys are limited to a maximum 25.

        Note: no validation is made on keys
        """
        keys: [ID!],
        """

        Return the top most frequent job company sectors contained in the result set up to the number requested.

        Defaults to 5 if `keys` is null or empty; 0 otherwise.
        Must be at least 1 and at most 25 when specified.
        """
        top: Int
    ): [JobCompanySectorFacet!]!
    """

    Provides facets about compensation.

    **Example**

    ```
    compensation {
    currencyCode
    baseAnnualSalary (
    numRanges: 20
    minRangeWidth: 1000
    ) {
    ranges {
    min
    max
    count
    }
    }
    }
    ```
    """
    compensation: JobSearchCompensationFacet!
    "Provides facets related to the `Job.dateOnIndeed` field"
    dateOnIndeed(
        "Requests must include at least 1 interval and are limited to a maximum of 50"
        intervals: [JobSearchDateFacetIntervalInput!]!
    ): [JobSearchDateFacet!]!
    "Provides facets related to the Glassdoor fields"
    glassdoor: GlassdoorFacet!
    """

    Provides facets related to the `Job.location` field.

    **Example**

    ```
    location {
    city ( top: 5 ) {
    key
    count
    admin1Code
    admin2Code
    city
    }
    }
    ```
    """
    location: JobSearchLocationFacet!
    normalizedTitle(
        """

        Return the top most frequent normalized job titles contained in the result set up to the number requested.

        Defaults to 5.
        Must be at least 1 and at most 25 when specified.
        """
        top: Int
    ): [JobSearchKeywordFacet!]!
    """

    Provides facets resulted to the `Job.occupations` field

    Results are in descending order based on the `count`

    It is valid to specify any combination of the `top` and `keys` fields.
    There result will be the union of all occupations matched by each field's behaviour

    **Examples:**
    - `top:5 keys: [ "C3XKZ", "KNBYF" ]` will return the top 5 occupations as well as counts for keys "C3XKZ" and "KNBYF".

    You can also use these SUIDs in the keyword filter with field name "occupations". Example:
    ```
    filters: [
    {
    keyword: {
    field: "occupations"
    keys: ["C3XKZ"]
    }
    }
    ]
    ```
    """
    occupations(
        """

        Return facets for each of the specified [SUID](https://wiki.indeed.com/display/MetadataTaxonomy/Glossary+and+Terminology#GlossaryandTerminology-SUID) keys.

        Will return counts for all specificed keys.
        Keys are limited to a maximum 25.

        Note: no validation is made on keys
        """
        keys: [ID!],
        """

        Return the top most frequent job occupations contained in the result set up to the number requested.

        Defaults to 5 if `keys` is null or empty; 0 otherwise.
        Must be at least 1 and at most 25 when specified.
        """
        top: Int
    ): [JobOccupationFacet!]!
}

"The common facet for keyword."
type JobSearchKeywordFacet {
    count: Int!
    key: ID!
}

"""

Facet representation of a `JobLocation`

**Example**

```
facets {
location {
city ( top: 5) {
key
count
admin1Code
admin2Code
}
}
}
```

Results can be utilized in `keyword` filters with field "location.city" to restrict the search result set.

**Example**

```
filters: [
{
keyword: {
field: "location.city"
keys: [
"TX|453|||Austin",
"CA|037|||Los Angeles"
]
operation: OR
}
}
]
```

See `filters.keyword` for usage in filters.
"""
type JobSearchLocationFacet {
    """

    Facets on city level.

    Different countries can have different definitions of city, and the number of admin codes included in responses can also differ.
    If some admin codes or city represent smaller administrative divisions, they will be excluded.
    Therefore, the location value in facets can be different from the value of `Job.location`,
    but the value of each field should be the same if it is not empty.
    """
    city(
        """

        Return the top most frequent cities contained in the result set up to the number requested.

        Defaults to 5.
        Must be at least 1 and at most 25 when specified.
        """
        top: Int
    ): [JobLocationFacet!]!
}

type JobSearchMetadata {
    rankingConfiguration: [String!]!
}

type JobSearchPayload {
    """

    Reports the total number of matched results. This count is an estimate as precise counts are unavailable and may
    change due to user personalization.
    """
    estimatedTotalResultsCount: Int!
    facets: JobSearchFacets!
    """

    Provides meta information about performing searches.

    If the client does not have the access permission, no data is returned.
    """
    metadata: JobSearchMetadata!
    pageInfo: JobSearchPayloadPageInfo!
    results: [JobSearchResult!]!
    """

    If `lastSearchTime` in the argument is set, this value is the number of jobs which matched the given query and are yonger than `lastSearchTime`.
    Otherwise, this value is the total number of matched jobs of any age.
    """
    sinceLastSearchCount: Int!
    """

    Globally unique tracking key for this `JobSearchPayload`

    Tracking key format: {version}-{requestTrackingKey}-{jobSearchTrackingKey}
    """
    trackingKey: ID!
}

type JobSearchPayloadPageInfo {
    nextCursor: String
    nextPages: [JobSearchPayloadSinglePageInfo!]!
    prevCursor: String
    prevPages: [JobSearchPayloadSinglePageInfo!]!
}

type JobSearchPayloadSinglePageInfo {
    cursor: String!
    "0 based page number (i.e., pageNum is 0 for the first page)"
    pageNum: Int!
}

"The common facet for range."
type JobSearchRangeFacet {
    count: Int!
    label: String!
    "The maximum value of this range (exclusive upper bound)."
    max: Int
    "The minimum value of this range (inclusive lower bound)."
    min: Int
}

type JobSearchResult {
    auction: JobSearchAuction
    encodedAdData: String
    group: JobSearchResultGroup!
    job: Job!
    metadata: JobSearchResultMetadata!
    "Return a snippet from the job specified for use in job cards and other UI elements."
    snippet(
        "If 'true', keywords from JobSearchMetadata will be highlighted using text formatted tags in the html version of the snippet."
        highlight: Boolean! = false
    ): JobSearchResultSnippet
    """

    Globally unique tracking key for this `JobSearchResult`. The type for this tracking key is currently set to 0.

    Tracking key format: {version}-{type}-{requestTrackingKey}-{jobSearchTrackingKey}-{jobKey}-{encodedAdData}
    """
    trackingKey: ID!
}

type JobSearchResultGroup {
    "The count of jobs in the group (any value over 100 should be treated at 100+)"
    count: Int!
    """

    The key to use un-group this group of jobs.

    See `JobSearchGroupingInput.key`
    """
    key: String!
}

type JobSearchResultMetadata {
    keywords: [String!]!
    what: String!
}

type JobSearchResultSnippet {
    "The HTML form. If 'hightlight' is set to 'true', keywords from JobSearchMetadata will be highlighted."
    html: String!
    "The unformatted text form of the snippet."
    text: String!
}

"A Job Seeker's Profile contains information Indeed has collected for or been given by the Job Seeker."
type JobSeekerProfile {
    accountKey: String
    availableForAnyJob: Boolean
    availableImmediately: Boolean
    defaultInfo: JobSeekerProfileDefaultInfo
    fileInformation: [JobSeekerProfileFile!]!
    resume: [JobSeekerProfileResume!]!
}

"A Job Seeker's assignment."
type JobSeekerProfileAssignment {
    assignmentId: String
    dateUpdated: DateTime
    id: ID!
}

"A Job Seeker's association."
type JobSeekerProfileAssociation {
    dateRange: JobSeekerProfileDateRange
    description: String
    id: ID!
    title: String
}

"A Job Seeker's award."
type JobSeekerProfileAward {
    date: JobSeekerProfileDateType
    description: String
    id: ID!
    title: String
}

"A Job Seeker's certification."
type JobSeekerProfileCertification {
    dateRange: JobSeekerProfileDateRange
    description: String
    id: ID!
    taxonomyConceptTitle: JobSeekerProfileTaxonomyConcept
    title: String
}

"A Job Seeker's company sector ."
type JobSeekerProfileCompanySector {
    name: String
    taxonomyConceptName: JobSeekerProfileTaxonomyConcept
}

"A Job Seeker's default contact information, so we can store this data without a resume."
type JobSeekerProfileContactInformation {
    firstName: String
    lastName: String
    location: JobSeekerProfileLocationType
    phoneNumber: String
}

"Date range, start, end dates and isCurrent."
type JobSeekerProfileDateRange {
    fromDate: JobSeekerProfileDateType
    isCurrent: Boolean
    toDate: JobSeekerProfileDateType
}

"Date type that includes year, month and isCurrent."
type JobSeekerProfileDateType {
    isCurrent: Boolean
    month: JobSeekerProfileMonthType
    year: Int
}

"A Job Seeker's default information, so we can store this data without a resume."
type JobSeekerProfileDefaultInfo {
    contactInformation: JobSeekerProfileContactInformation
}

type JobSeekerProfileDegree {
    degreeName: String
    field: String
    id: ID!
    taxonomyConceptDegree: JobSeekerProfileTaxonomyConcept
    taxonomyConceptField: JobSeekerProfileTaxonomyConcept
}

"A Job Seeker's education details."
type JobSeekerProfileEducation {
    dateRange: JobSeekerProfileDateRange
    degree: [JobSeekerProfileDegree!]!
    id: ID!
    location: JobSeekerProfileLocationType
    school: String
}

"A Job Seeker's employment eligibility."
type JobSeekerProfileEmploymentEligibility {
    id: ID!
}

"A Job Seeker's File metadata, this file could be a resume, cover letter."
type JobSeekerProfileFile {
    clientApp: String
    extension: String
    fileDescription: String
    fileName: String
    fileType: JobSeekerProfileFileType
    hashCode: String
    id: ID!
    mediaType: String
    standardHashCode: String
    tags: [String!]!
    uploadTimestamp: Int64
}

"A Job Seeker's international fields."
type JobSeekerProfileInternational {
    citizenship: JobSeekerProfileInternationalCitizenship
    dateOfBirth: String
    disability: JobSeekerProfileInternationalDisability
    driversLicense: [JobSeekerProfileInternationalDriversLicense!]!
    educationDescription: String
    employmentEligibility: JobSeekerProfileInternationalEmploymentEligibility
    employmentEligibilityMultiCountries: [JobSeekerProfileInternationalEmploymentEligibilityMultiCountries!]!
    employmentStatus: JobSeekerProfileInternationalEmploymentStatus
    employmentSupportStatus: JobSeekerProfileInternationalEmploymentSupportStatus
    ethnicity: JobSeekerProfileInternationalEthnicity
    europeanUnionWorkPermit: JobSeekerProfileInternationalEuropeanUnionWorkPermit
    firstNameFurigana: String
    gender: JobSeekerProfileInternationalGender
    highestCareerLevel: JobSeekerProfileInternationalHighestCareerLevel
    highestLevelOfEducation: JobSeekerProfileInternationalHighestLevelOfEducation
    hobbiesAndInterests: String
    iDP: Boolean
    idNumber: String
    industry: [JobSeekerProfileInternationalIndustry!]!
    lastNameFurigana: String
    nYSCStatus: JobSeekerProfileInternationalNYSCStatus
    totalYearsOfExperience: Int64
    veteranStatus: JobSeekerProfileInternationalVeteranStatus
    willingToTravel: JobSeekerProfileInternationalWillingToTravel
}

"A Job Seeker's language skill."
type JobSeekerProfileLanguageSkill {
    language: String
    languageTaxonomyId: String
    proficiency: String
    proficiencyTaxonomyId: String
}

"A Job Seeker's license."
type JobSeekerProfileLicense {
    dateRange: JobSeekerProfileDateRange
    endorsements: [String!]!
    id: ID!
    location: JobSeekerProfileLocationType
    taxonomyConceptTitle: JobSeekerProfileTaxonomyConcept
    title: String
}

"A Job Seeker's links to webpages."
type JobSeekerProfileLink {
    id: ID!
    link: String
}

"A Job Seeker's location details."
type JobSeekerProfileLocationType {
    address: String
    address2: String
    admin1: String
    admin2: String
    admin3: String
    admin4: String
    city: String
    country: String
    formattedLocation: String
    geocodePrecision: JobSeekerProfileGeocodePrecision
    latitude: Float
    location: String
    longitude: Float
    postalCode: String
    state: String
    unknownLocation: String
}

"A Job Seeker's military service."
type JobSeekerProfileMilitary {
    branch: String
    commendations: String
    country: String
    dateRange: JobSeekerProfileDateRange
    description: String
    id: ID!
    rank: String
    serviceCode: String
}

"A Job Seeker's patent."
type JobSeekerProfilePatent {
    date: String
    description: String
    id: ID!
    patentNumber: String
    title: String
    url: String
}

"Payload that includes the profile of the jobseeker"
type JobSeekerProfilePayload {
    profile: JobSeekerProfile
}

"A Job Seeker's publication."
type JobSeekerProfilePublication {
    date: String
    description: String
    id: ID!
    title: String
    url: String
}

"A Job Seeker's Resume contains personal information used when applying to a job."
type JobSeekerProfileResume {
    additionalInfo: String
    anonymous: Boolean
    assignments: [JobSeekerProfileAssignment!]!
    associations: [JobSeekerProfileAssociation!]!
    awards: [JobSeekerProfileAward!]!
    careerLevel: JobSeekerProfileResumeCareerLevel
    certifications: [JobSeekerProfileCertification!]!
    contactInformation: JobSeekerProfileResumeContactInfo
    dateCreated: DateTime
    dateModified: DateTime
    dateTouched: DateTime
    defaultResume: Boolean
    educations: [JobSeekerProfileEducation!]!
    employmentEligibilities: [JobSeekerProfileEmploymentEligibility!]!
    firstName: String
    geoCountry: String
    groups: [String!]!
    headline: String
    id: ID!
    international: JobSeekerProfileInternational
    ipAddress: String
    ipCountry: String
    languageSkills: [JobSeekerProfileLanguageSkill!]!
    lastName: String
    licenses: [JobSeekerProfileLicense!]!
    links: [JobSeekerProfileLink!]!
    locale: String
    location: JobSeekerProfileLocationType
    military: [JobSeekerProfileMilitary!]!
    militaryCommendations: String
    originShard: String
    patents: [JobSeekerProfilePatent!]!
    phoneNumber: String
    profilePhotoUrl: String
    publicUntilEpochMillis: Int64
    publications: [JobSeekerProfilePublication!]!
    resumeNickname: String
    resumeType: JobSeekerProfileResumeType
    showPhoneNumber: Boolean
    skills: [JobSeekerProfileSkill!]!
    source: JobSeekerProfileResumeSource
    state: JobSeekerProfileResumeState
    summary: String
    tags: [String!]!
    testOnly: Boolean
    totalMonthsOfExperience: Int64
    wordCount: Int
    workExperiences: [JobSeekerProfileWorkExperience!]!
}

"A Job Seeker's resume contact information."
type JobSeekerProfileResumeContactInfo {
    canReceiveClickToCall: Boolean
    canReceiveSMS: Boolean
    countryCode: String
    isMobile: Boolean
    isValid: Boolean
}

"Taxonomy concept section id."
type JobSeekerProfileSectionIds {
    sectionId: String
}

"A Job Seeker's Skill details"
type JobSeekerProfileSkill {
    experience: Int64
    id: ID!
    taxonomyConceptTitle: JobSeekerProfileTaxonomyConcept
    text: String
    timeUnit: JobSeekerProfileTypeUnit
}

"Types"
type JobSeekerProfileStructuredDataAttributeMetadata {
    "JobSeekerProfileStructuredDataDataCategory information."
    dataCategory: JobSeekerProfileStructuredDataDataCategory!
    "Variant, currently provided by Niffler only."
    variant: String
}

type JobSeekerProfileStructuredDataCertification {
    "Certification Metadata."
    attributeMetadata: JobSeekerProfileStructuredDataAttributeMetadata
    "Certification Description."
    description: String
    "Certification Id."
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Certification Title."
    title: String
    "Certification Title TaxonomyConcept."
    titleTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "Certification Type."
    type: String
    "Certification Id."
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataCompany {
    "Company FCC ID."
    companyFccId: Int
    "Company name."
    companyName: String
    "Company Id."
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Company Id."
    uuid: String @deprecated(reason: "Use id instead")
}

type JobSeekerProfileStructuredDataCompanySector {
    "Company Sector Metadata."
    attributeMetadata: JobSeekerProfileStructuredDataAttributeMetadata
    "Company Sector."
    companySector: String
    "Company Sector TaxonomyConcept."
    companySectorTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "Company Sector Id."
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Company Sector Id."
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataEducation {
    "Education Metadata."
    attributeMetadata: JobSeekerProfileStructuredDataAttributeMetadata
    "Education Degree."
    degree: String
    "Education Degree TaxonomyConcept."
    degreeTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "Education Field of Study."
    fieldOfStudy: String
    "Education Field of Study TaxonomyConcept."
    fieldTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "Education Id."
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Education Id."
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataJobTitle {
    "Job Title Id"
    id: ID
    "Job title."
    jobTitle: String
    "Job title taxonomyConcept."
    jobTitleTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Job Title Id"
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataJobType {
    "Job Type Id"
    id: ID
    "Job Type."
    jobType: JobSeekerProfileStructuredDataJobTypeEnum
    "Shift TaxonomyConcept."
    jobTypeTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Job Type Id"
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataLicense {
    "License Metadata."
    attributeMetadata: JobSeekerProfileStructuredDataAttributeMetadata
    "List of endorsements."
    endorsements: [String!]!
    "License Id."
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "License Title."
    title: String
    "License title taxonomyConcept."
    titleTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "License Type."
    type: String
    "License Id."
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataLocation {
    "Admin 1."
    admin1: String
    "Admin 2."
    admin2: String
    "Admin 3."
    admin3: String
    "Admin 4."
    admin4: String
    "City."
    city: String
    "Country."
    country: String
    "Geohash 4."
    geoHash4: String
    "Geohash 5."
    geoHash5: String
    "Geohash 6."
    geoHash6: String
    "Location Id."
    id: ID
    "Location Latitude."
    latitude: Float
    "Show how accurate lat/lng has been calculated."
    latlngPrecision: JobSeekerProfileStructuredDataLatLngPrecision
    "Location Longtitude."
    longitude: Float
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "Postal Code."
    postalCode: String
    "Location Raw."
    raw: String
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Street Address."
    streetAddress: String
    "Location Id."
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataOccupation {
    "Occupation Metadata."
    attributeMetadata: JobSeekerProfileStructuredDataAttributeMetadata
    "Occupation Id."
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "Occupation."
    occupation: String
    "Occupation TaxonomyConcept."
    occupationTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Occupation Id."
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataPayload {
    "List of Certifications."
    certifications: [JobSeekerProfileStructuredDataCertification!]!
    "Current Salaries."
    currentSalaries: [JobSeekerProfileStructuredDataSalary!]!
    "Disliked preference"
    dislikedPreference: JobSeekerProfileStructuredDataPreference
    "List of Educations."
    educations: [JobSeekerProfileStructuredDataEducation!]!
    "List of Licenses."
    licenses: [JobSeekerProfileStructuredDataLicense!]!
    "List of Occupations."
    occupations: [JobSeekerProfileStructuredDataOccupation!]!
    "List of Preferences."
    preferences: [JobSeekerProfileStructuredDataPreference!]!
    "List of Skills."
    skills: [JobSeekerProfileStructuredDataSkill!]!
}

type JobSeekerProfileStructuredDataPreference {
    "Able to Relocate."
    ableToRelocate: Boolean
    "Preference Metadata."
    attributeMetadata: JobSeekerProfileStructuredDataAttributeMetadata
    "Desired list of companies."
    companies: [JobSeekerProfileStructuredDataCompany!]!
    "Desired list of Company Sectors."
    companySectors: [JobSeekerProfileStructuredDataCompanySector!]!
    "Preference Id."
    id: ID
    "Desired list of Job titles."
    jobTitles: [JobSeekerProfileStructuredDataJobTitle!]!
    "Desired list of Job Types."
    jobTypes: [JobSeekerProfileStructuredDataJobType!]!
    "Desired list of locations."
    locations: [JobSeekerProfileStructuredDataLocation!]!
    "Desired list of Occupations."
    occupations: [JobSeekerProfileStructuredDataOccupation!]!
    "List of prefered remote/In person work types."
    remoteWorkTypes: [JobSeekerProfileStructuredDataRemoteWorkType!]!
    "Desired Salary."
    salary: JobSeekerProfileStructuredDataSalary
    "Desired list of Shifts."
    shifts: [JobSeekerProfileStructuredDataShift!]!
    "Preference Id."
    uuid: String @deprecated(reason: "Use id instead")
}

type JobSeekerProfileStructuredDataRemoteWorkType {
    "Remote Work Type Id."
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "Remote work taxonomy fields"
    remoteWorkTypeTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "JobSeekerProfileSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Remote Work Type Id."
    uuid: String @deprecated(reason: "Use id instead")
}

type JobSeekerProfileStructuredDataSalary {
    "Salary Amount."
    amount: Float
    "Salary Metadata."
    attributeMetadata: JobSeekerProfileStructuredDataAttributeMetadata
    "Salary Currency."
    currency: String
    "Salary Id"
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "Salary Type."
    salaryType: JobSeekerProfileStructuredDataSalaryType
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Salary Id"
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataShift {
    "Shift Id"
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Shift."
    shift: String
    "Shift TaxonomyConcept."
    shiftTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "Shift Id"
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataSkill {
    "Skill Metadata."
    attributeMetadata: JobSeekerProfileStructuredDataAttributeMetadata
    "Skill Id."
    id: ID
    "Modified Timestamp."
    modifiedTime: Timestamp!
    "Months of experience."
    monthsOfExperience: Int
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Skill."
    skillName: String
    "Skill TaxonomyConcept."
    skillTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConcept
    "Skill Id."
    uuid: String @deprecated(reason: "Use id instead")
    "Weight (Currently provided by Niffler only)."
    weight: Float
}

type JobSeekerProfileStructuredDataTaxonomyConcept {
    "TaxonomyConcept Label."
    label: String!
    "Section Ids where the attribute is extracted from."
    sectionIds: [String!]!
    """

    Short TaxonomyConcept Id/Rosetta Id (recomended)
    example: W3WGD
    """
    suid: String
    "TaxonomyConcept Type."
    type: String
    """

    Long TaxonomyConcept Id/Rosetta Id.
    example: e76aac9a-1ee7-46cf-969e-683f01571cbd
    """
    uuid: String
}

"Taxonomy concept details."
type JobSeekerProfileTaxonomyConcept {
    label: String
    sectionIds: [JobSeekerProfileSectionIds!]!
    suid: String
    taxonomyConceptId: String
    type: String
    uuid: String
}

"A Job Seeker's work experience."
type JobSeekerProfileWorkExperience {
    commonSkills: String
    company: String
    companyFccid: Int64
    companySector: JobSeekerProfileCompanySector
    dateRange: JobSeekerProfileDateRange
    description: String
    id: ID!
    location: JobSeekerProfileLocationType
    normalizedTitle: String
    title: String
}

type JobSource {
    "An encrypted ID of the source. Please follow https://wiki.indeed.com/x/YFcMFg if you have to get the raw ID."
    key: ID!
}

type JobUpdateAdditionalData {
    countryCode: String!
}

type JobUpdateEvent {
    "Some additional data that are currently associated with the job. This may be null if the job is inactive."
    currentAdditionalData: JobUpdateAdditionalData
    "The type of this job update event. See the documentation of `JobUpdatePayload/updatedJobs` for details."
    eventType: JobUpdateEventType!
    "The updated job"
    job: Job!
    "Some additional data that were previously associated with the job. This may be null if the job is new."
    previousAdditionalData: JobUpdateAdditionalData
    "The job's current status. See the documentation of `JobUpdatePayload/updatedJobs` for details."
    status: JobUpdateStatus!
}

type JobUpdateForwardOnlyCursorInfo {
    """

    The string that you should provide in the next `jobUpdate` API call.

    Note that this cursor may be different from the previous response even if `updatedJobs` is empty.
    """
    endCursor: String!
    "If this value is true, there may be more job updates available now."
    hasNextPage: Boolean!
}

type JobUpdatePayload {
    pageInfo: JobUpdateForwardOnlyCursorInfo!
    """

    The unordered list of jobs that may have been updated. The keys of jobs in this list are distinct.

    - If `eventType` is NEW, it is a new job or a job whose status changed from inactive to active. In this case the `status` is ACTIVE.
    - If `eventType` is UPDATED, it is an active job data may have been updated. In this case the `status` is ACTIVE.
    - If `eventType` is DELETED, it is a job whose status changed from active to inactive. In this case the `status` is INACTIVE.
    """
    updatedJobs: [JobUpdateEvent!]!
}

type JobUpdateSnapshotUrlPayload {
    url: String!
}

" Jobs campaigns analytics metrics by campaign "
type JobsCampaignsAnalyticsByCmp {
    adName: String
    advertisementID: String
    avgACR: Float
    avgASR: Float
    avgCTR: Float
    avgCostPerApplyLocal: Float
    avgCostPerApplyStartLocal: Float
    avgCostPerClickLocal: Float
    currency: String
    sumApplies: Int
    sumApplyStarts: Int
    sumClicks: Int
    sumCostLocal: Float
    sumImpressions: Int
}

type JobsCampaignsAnalyticsByCmpPayload {
    result: [JobsCampaignsAnalyticsByCmp!]!
}

" Jobs campaigns analytics metrics by job "
type JobsCampaignsAnalyticsByJob {
    aggJobID: String
    avgACR: Float
    avgASR: Float
    avgCTR: Float
    avgCostPerApplyLocal: Float
    avgCostPerApplyStartLocal: Float
    avgCostPerClickLocal: Float
    currency: String
    sumApplies: Int
    sumApplyStarts: Int
    sumClicks: Int
    sumCostLocal: Float
    sumImpressions: Int
    title: String
}

type JobsCampaignsAnalyticsByJobPayload {
    result: [JobsCampaignsAnalyticsByJob!]!
}

" Jobs campaigns analytics metrics by location "
type JobsCampaignsAnalyticsByLoc {
    admin1: String
    admin2: String
    admin3: String
    admin4: String
    avgACR: Float
    avgASR: Float
    avgCTR: Float
    avgCostPerApplyLocal: Float
    avgCostPerApplyStartLocal: Float
    avgCostPerClickLocal: Float
    city: String
    country: String
    currency: String
    jobLocationID: String
    sumApplies: Int
    sumApplyStarts: Int
    sumClicks: Int
    sumCostLocal: Float
    sumImpressions: Int
}

type JobsCampaignsAnalyticsByLocPayload {
    result: [JobsCampaignsAnalyticsByLoc!]!
}

" Jobs campaigns analytics metrics for all jobs / campaigns "
type JobsCampaignsAnalyticsForAll {
    activityDate: String
    avgACR: Float
    avgASR: Float
    avgCTR: Float
    avgCostPerApplyLocal: Float
    avgCostPerApplyStartLocal: Float
    avgCostPerClickLocal: Float
    currency: String
    sumApplies: Int
    sumApplyStarts: Int
    sumClicks: Int
    sumCostLocal: Float
    sumImpressions: Int
}

type JobsCampaignsAnalyticsForAllPayload {
    result: [JobsCampaignsAnalyticsForAll!]!
}

" number of jobs per campaign "
type JobsCampaignsAnalyticsNJobCmp {
    advertisementID: String
    uniqueJobCount: Int
}

type JobsCampaignsAnalyticsNJobCmpPayload {
    result: [JobsCampaignsAnalyticsNJobCmp!]!
}

" Number of unique locations during a time period "
type JobsCampaignsAnalyticsNumCmpPayload {
    uniqueCount: Int
}

" Number of unique jobs during a time period "
type JobsCampaignsAnalyticsNumJobPayload {
    uniqueCount: Int
}

" Number of unique locations during a time period "
type JobsCampaignsAnalyticsNumLocPayload {
    uniqueCount: Int
}

type JobsPayload {
    result: [AggJob!]!
}

"Encapsulation of user generated employer metrics. Ratings, multiple-choice question answers etc"
type JobseekerUgcStats {
    "Answers to question: \"Do you approve of CEO?\""
    ceoApproval: YesNoCount
    "Total number of employer's reviews across the world"
    globalReviewCount: Int
    "Happiness statistics."
    happiness(filter: HappinessStatsFilterInput): HappinessStats
    "Interview related data Difficulty, Experience and Process Length"
    interview: InterviewStats
    "Number of reviews for each rating value from 1 to 5"
    ratingHistogram(filter: RatingHistogramFilterInput): [Int]
    "Overall and per-topic average ratings submitted by users"
    ratings(filter: RatingsFilterInput): RatingBundle
    "Answers to question: \"Would you recommend employer to a friend?\""
    recommendFriend: YesNoCount
    "Number of review in country used in employer query"
    reviewCountForCountry: Int
    "Number of reviews with language provided in employer query"
    reviewCountForLanguage: Int
    "Number of reviews for locale used in employer query"
    reviewCountForLocale: Int
    "Answers to question: \"Do you feel like your salary is enough for the cost of living in your area?\""
    salaryCostOfLiving(filter: MicrocontentFilterInput): YesNoCount
    "Answers to question: \"Are you satisfied with your salary?\""
    salarySatisfaction(filter: MicrocontentFilterInput): YesNoCount
}

"Simple string-based key-value pair."
type KeyValuePair {
    "Key for attribute pair"
    key: String!
    "Value for attribute pair"
    value: String!
}

" Type that holds an ISO 639-1 - alpha 2 encoded language code string as well as a display name in the corresponding language"
type LanguageAndDisplayName {
    " The name of the language in the language specified by the language field "
    displayName: String!
    " An ISO 639-1 - alpha 2 encoded language code "
    language: LanguageCode!
}

"""

The 'classic' Hiring Events Job model that is stored in Hiring Events and used for
exposing jobs to be aggregated in the Hiring Events feed
"""
type LegacyHiringEventJob implements HiringEventJob {
    aggregatedJobs: [AggregatedNativeHiringEventJob]!
    attributes: [HiringEventJobAttributeFacet!]!
    compensation: HiringEventCompensation!
    conductor_workflow_id: String!
    descriptionHTML: String! @deprecated(reason: "No longer supported")
    id: ID!
    "The physical locations of the Job"
    locations: [HiringEventPhysicalLocation!]!
    title: String! @deprecated(reason: "No longer supported")
}

"""

The Job model that is stored in Hiring Events but only contains a reference to an
existing indexed Job (e.g. an opted-in job)
"""
type LinkedHiringEventJob implements HiringEventJob {
    attributes: [HiringEventJobAttributeFacet!]! @deprecated(reason: "No longer supported")
    compensation: HiringEventCompensation! @deprecated(reason: "No longer supported")
    conductor_workflow_id: String!
    descriptionHTML: String! @deprecated(reason: "No longer supported")
    "Only present if the linked job is tied to a hosted job"
    hostedJobId: ID @deprecated(reason: "No longer supported")
    id: ID!
    job: Job!
    """

    The agg job key that this job corresponds to.
    Views on this job key will bring the user to this HiringEventJob's hiring event
    """
    jobKey: String @deprecated(reason: "No longer supported")
    "The location of the opted in job. There is only one location since indexed jobs only have one location"
    location: HiringEventPhysicalLocation!
    "Encrypted version of job source id"
    sourceKey: String @deprecated(reason: "No longer supported")
    title: String! @deprecated(reason: "No longer supported")
}

"""

The Job model that is stored in Hiring Events but only contains a reference to an
existing indexed Job hosted on Indeed
"""
type LinkedHostedHiringEventJob implements HiringEventJob {
    attributes: [HiringEventJobAttributeFacet!]! @deprecated(reason: "No longer supported")
    compensation: HiringEventCompensation! @deprecated(reason: "No longer supported")
    conductor_workflow_id: String!
    descriptionHTML: String! @deprecated(reason: "No longer supported")
    hostedJobId: ID!
    id: ID!
    job: Job!
    "The location of the opted in job. There is only one location since indexed jobs only have one location"
    location: HiringEventPhysicalLocation!
    title: String! @deprecated(reason: "No longer supported")
}

"A physical location."
type Location {
    admin1Code: String
    admin1Name: String
    admin2Code: String
    admin2Name: String
    admin3Code: String
    admin3Name: String
    admin4Code: String
    admin4Name: String
    city: String
    countryCode: CountryCode
    countryName: String
    formatted: FormattedLocation
    latitude: Float
    longitude: Float
    neighborhood: String
    postalCode: String
    streetAddress: String
}

type LocationsPayload {
    result: [AggJobLocation!]!
}

type MarketInsightsPayload {
    "hiring_tension_score in MarketInsightsReportResponse"
    competitiveScore: Float
    "ctks in MarketInsightsReportResponse"
    jobSeekers: Int
    "jobs in MarketInsightsReportResponse"
    jobs: Int
    "the month/year this report was generated for"
    reportDate: ReportDate!
    "total_employers in MarketInsightsReportResponse"
    totalEmployers: Int
}

type MarketInsightsRequest {
    "CountryCode for the job location."
    countryCode: CountryCode
    "Location of the job."
    jobLocation: String
    "Title of the job."
    jobTitle: String
    "LanguageCode for the job."
    languageCode: LanguageCode
}

type Matching {
    field: String!
    matchingText: String!
}

type MatchingResult {
    jobseekerInputType: String!
    jobseekerText: String!
    label: String!
    name: String!
    options: [SelectOption!]!
    predictAnswers: [String!]!
    questionId: String!
    required: Boolean!
    requirementMet: Boolean
}

type MatchingResultPayload {
    questions: [MatchingResult!]!
}

type MdsResponseStatus {
    errorMessage: String
    responseCode: MdsResponseCode!
}

type MessageTranslations {
    clientMessage: [Translation!]
    funnelMessage: [Translation!]
    generalMessage: [Translation!]
    jobsMessage: [Translation!]
    message: [Translation!]
    policyLink: [Translation!]
}

type Mutation {
    "Add time periods to a resource's availability rules."
    addAvailabilityPeriods(input: AddAvailabilityPeriodsInput!): AddAvailabilityPeriodsPayload
    "Add fields of a disliked preference."
    addFieldsJobSeekerProfileStructuredDataDislikedPreference(input: AddFieldsJobSeekerProfileStructuredDataDislikedPreferenceInput!): AddFieldsJobSeekerProfileStructuredDataDislikedPreferencePayload
    addJobSeekerProfileResumeAwards(input: AddJobSeekerProfileResumeAwardsInput!): AddJobSeekerProfileResumeAwardsPayload
    addJobSeekerProfileResumeCertifications(input: AddJobSeekerProfileResumeCertificationsInput!): AddJobSeekerProfileResumeCertificationsPayload
    addJobSeekerProfileResumeEducations(input: AddJobSeekerProfileEducationsInput!): AddJobSeekerProfileResumeEducationsPayload
    addJobSeekerProfileResumeLanguageSkills(input: AddJobSeekerProfileResumeLanguageSkillsInput!): AddJobSeekerProfileResumeLanguageSkillsPayload
    addJobSeekerProfileResumeLinks(input: AddJobSeekerProfileResumeLinksInput!): AddJobSeekerProfileResumeLinksPayload
    addJobSeekerProfileResumeMilitary(input: AddJobSeekerProfileResumeMilitaryInput!): AddJobSeekerProfileResumeMilitaryPayload
    addJobSeekerProfileResumeSkills(input: AddJobSeekerProfileResumeSkillsInput!): AddJobSeekerProfileResumeSkillsPayload
    addJobSeekerProfileResumeWorkExperiences(input: AddJobSeekerProfileResumeWorkExperiencesInput!): AddJobSeekerProfileResumeWorkExperiencesPayload
    "Add a new preference."
    addJobSeekerProfileStructuredDataPreference(input: AddJobSeekerProfileStructuredDataPreferenceInput!): AddJobSeekerProfileStructuredDataPreferencePayload
    " Provides mutations related to company settings "
    companySettings: CompanySettingsMutations
    "Confirm attribute like Skill, Certification."
    confirmJobSeekerProfileStructuredData(input: ConfirmJobSeekerProfileStructuredDataInput!): ConfirmJobSeekerProfileStructuredDataPayload
    "Create a new Draft Job Post"
    createDraftJobPost(input: CreateDraftJobPostInput!): CreateDraftJobPostPayload
    "Create a new DraftJobPost from a HostedJobPost"
    createDraftJobPostFromHostedJobPost(input: CreateDraftJobPostFromHostedJobPostInput!): CreateDraftJobPostFromHostedJobPostPayload
    """

    Create a new DraftJobPost from a HostedJobPost (identified by a legacy / encrypted ats job ID).
    This will eventually be deprecated only legacy IDs are not longer used to identify HostedJobPosts.
    """
    createDraftJobPostFromHostedJobPostByLegacyId(input: CreateDraftJobPostFromHostedJobPostInput!): CreateDraftJobPostFromHostedJobPostPayload
    createEventCalendar(input: CreateEventCalendarInput!): CreateEventCalendarPayload
    createHiringEventEnhancedScreening(input: CreateHiringEventEnhancedScreeningInput!): CreateHiringEventEnhancedScreeningPayload
    createHiringEventRsvp(input: CreateHiringEventRsvpInput!): CreateHiringEventRsvpPayload
    "Create a new Hosted Employer"
    createHostedEmployer(input: CreateHostedEmployerInput!): CreateHostedEmployerPayload
    "Create a new Hosted Job Post"
    createHostedJobPost(input: CreateHostedJobPostInput!): CreateHostedJobPostPayload
    createOffsiteCtkDeviceIdMap(input: OffsiteCtkDeviceIdMapInput!): OffsiteCtkDeviceIdMapPayload
    createOrUpdateTimePunch(input: CreateOrUpdateTimePunchInput!): CreateOrUpdateTimePunchPayload
    """

    Create a comment on a specified employer review.

    This requires authentication as the employer, using an account with a claim on the employer's company page.
    """
    createReviewComment(input: CreateReviewCommentInput!): CreateReviewCommentPayload
    createTimePunch(input: CreateOrUpdateTimePunchInput!): CreateOrUpdateTimePunchPayload
    deleteAppointment(input: DeleteAppointmentInput!): DeleteAppointmentPayload
    "Delete a Draft Job Post"
    deleteDraftJobPost(input: DeleteDraftJobPostInput!): DeleteDraftJobPostPayload
    "Deletes all unsubmitted (draft) verification info for the specified advertiserId"
    deleteDraftVerificationInfo(input: DeleteVerificationInfoInput!): DeleteDraftVerificationInfoPayload
    deleteEventCalendar(input: DeleteEventCalendarInput!): DeleteEventCalendarPayload
    "Delete fields of a disliked preference."
    deleteFieldsJobSeekerProfileStructuredDataDislikedPreference(input: DeleteFieldsJobSeekerProfileStructuredDataDislikedPreferenceInput!): DeleteFieldsJobSeekerProfileStructuredDataDislikedPreferencePayload
    deleteJobSeekerProfileFile(input: DeleteJobSeekerProfileFileInput!): DeleteJobSeekerProfileFilePayload
    deleteJobSeekerProfileResume(input: DeleteJobSeekerProfileResumeInput!): DeleteJobSeekerProfileResumePayload
    deleteJobSeekerProfileResumeAwards(input: DeleteJobSeekerProfileResumeAwardsInput!): DeleteJobSeekerProfileResumeAwardsPayload
    deleteJobSeekerProfileResumeCertifications(input: DeleteJobSeekerProfileResumeCertificationsInput!): DeleteJobSeekerProfileResumeCertificationsPayload
    deleteJobSeekerProfileResumeEducations(input: DeleteJobSeekerProfileResumeEducationsInput!): DeleteJobSeekerProfileResumeEducationsPayload
    deleteJobSeekerProfileResumeLanguageSkills(input: DeleteJobSeekerProfileResumeLanguageSkillsInput!): DeleteJobSeekerProfileResumeLanguageSkillsPayload
    deleteJobSeekerProfileResumeLinks(input: DeleteJobSeekerProfileResumeLinksInput!): DeleteJobSeekerProfileResumeLinksPayload
    deleteJobSeekerProfileResumeMilitary(input: DeleteJobSeekerProfileResumeMilitaryInput!): DeleteJobSeekerProfileResumeMilitaryPayload
    deleteJobSeekerProfileResumeSkills(input: DeleteJobSeekerProfileResumeSkillsInput!): DeleteJobSeekerProfileResumeSkillsPayload
    deleteJobSeekerProfileResumeWorkExperiences(input: DeleteJobSeekerProfileResumeWorkExperiencesInput!): DeleteJobSeekerProfileResumeWorkExperiencesPayload
    """

    Delete a comment's text on a specified employer review.

    This requires authentication as the employer, using an account with a claim on the employer's company page.
    """
    deleteReviewComment(input: DeleteReviewCommentInput!): DeleteReviewCommentPayload
    deleteUserCalendar(input: DeleteUserCalendarInput!): DeleteUserCalendarPayload
    highlightReview(input: HighlightReviewInput!): HighlightReviewPayload
    parseJobSeekerProfileFile(input: ParseJobSeekerProfileFileInput): ParseJobSeekerProfileFilePayload
    "Patch update a Draft Job Post"
    patchDraftJobPost(input: PatchDraftJobPostInput!): PatchDraftJobPostPayload
    "Patches a Hosted Employer"
    patchHostedEmployer(input: PatchHostedEmployerInput!): UpdateHostedEmployerPayload
    "Patch update a Hosted Job Post"
    patchHostedJobPost(input: PatchHostedJobPostInput!): PatchHostedJobPostPayload
    "Publish a DraftJobPost to a HostedJobPost"
    publishDraftJobPost(input: PublishDraftJobPostInput!): PublishDraftJobPostPayload
    """

    Record an Apply Start

    _HTTP Headers:_

    - **indeed-ctk** : Used for personalizing search results (e.g., ranking and matching)
    """
    recordApplyStart(input: RecordApplyStartInput!): RecordApplyStartPayload!
    recordCandidateContact(input: RecordCandidateContactInput!): RecordCandidateViewPayload!
    recordCandidateUpdate(input: RecordCandidateUpdateInput!): RecordCandidateViewPayload!
    recordCandidateView(input: RecordCandidateViewInput!): RecordCandidateViewPayload!
    """

    Record Javascript Detection

    _HTTP Headers:_

    - **indeed-ctk** : Used for collecting signals that whether a user can run javascript or not
    """
    recordJavascriptDetection(input: RecordJavascriptDetectionInput!): RecordJavascriptDetectionPayload
    """

    Record job click.

    _HTTP Headers:_

    - **indeed-ctk** : Used for personalizing search results (e.g., ranking and matching)
    """
    recordJobClick(input: RecordJobClickInput!): RecordJobClickPayload!
    """

    Record job data results shown.

    _HTTP Headers:_

    - **indeed-ctk** : Used for personalizing search results (e.g., ranking and matching)
    """
    recordJobDataResultsShown(input: RecordJobDataResultsShownInput!): RecordJobDataResultsShownPayload!
    """

    Record search results shown.

    _HTTP Headers:_

    - **indeed-ctk** : Used for personalizing search results (e.g., ranking and matching)
    """
    recordJobSearchResultsShown(input: RecordJobSearchResultsShownInput!): RecordJobSearchResultsShownPayload!
    """

    Record job seen.

    _HTTP Headers:_

    - **indeed-ctk** : Used for personalizing search results (e.g., ranking and matching)
    """
    recordJobSeen(input: RecordJobSeenInput!): RecordJobSeenPayload!
    """

    _HTTP Headers:_

    - **indeed-ctk** : Used for personalizing search results (e.g., ranking and matching)
    """
    recordMosaicOptOut(input: RecordMosaicOptOutInput!): RecordMosaicOptOutPayload
    """

    Mutation Endpoint to Record Targeted Content Click by the user

    _HTTP Headers:_

    - **indeed-ctk** : Used to track user-level interaction events
    """
    recordTargetedContentClick(input: RecordSingleTargetedContentUserInteractionInput!): RecordSingleTargetedContentUserInteractionPayload
    """

    Mutation Endpoint to Record Targeted Content Close by the user

    _HTTP Headers:_

    - **indeed-ctk** : Used to track user-level interaction events
    """
    recordTargetedContentClose(input: RecordSingleTargetedContentUserInteractionInput!): RecordSingleTargetedContentUserInteractionPayload
    """

    Mutation Endpoint to Record Targeted Content Seen by the user

    _HTTP Headers:_

    - **indeed-ctk** : Used to track user-level interaction events
    """
    recordTargetedContentSeen(input: RecordMultipleTargetedContentUserInteractionsInput!): RecordMultipleTargetedContentUserInteractionsPayload
    """

    Mutation Endpoint to Record Targeted Content Shown to the user

    _HTTP Headers:_

    - **indeed-ctk** : Used to track user-level interaction events
    """
    recordTargetedContentShown(input: RecordMultipleTargetedContentUserInteractionsInput!): RecordMultipleTargetedContentUserInteractionsPayload
    "Remove time periods from a resource's availability rules."
    removeAvailabilityPeriods(input: RemoveAvailabilityPeriodsInput!): RemoveAvailabilityPeriodsPayload
    "Remove an existing preference."
    removeJobSeekerProfileStructuredDataPreference(input: RemoveJobSeekerProfileStructuredDataPreferenceInput!): RemoveJobSeekerProfileStructuredDataPreferencePayload
    removeOffsiteCtkDeviceIdMap(input: OffsiteDeviceIdOptOutInput!): OffsiteDeviceIdOptOutPayload
    "Replace fields of a disliked preference."
    replaceFieldsJobSeekerProfileStructuredDataDislikedPreference(input: ReplaceFieldsJobSeekerProfileStructuredDataDislikedPreferenceInput!): ReplaceFieldsJobSeekerProfileStructuredDataDislikedPreferencePayload
    storeAnswerResult(input: StoreAnswerInput!): StoreAnswerResultPayload
    "Submits any stored verification info associated with the advertiserId to moderators"
    submitVerificationInfo: SubmitVerificationInfoPayload
    unhighlightReview(input: UnhighlightReviewInput!): UnhighlightReviewPayload
    updateAvailabilityResource(input: UpdateAvailabilityResourceInput!): UpdateAvailabilityResourcePayload
    "Updates a Draft Job Post"
    updateDraftJobPost(input: UpdateDraftJobPostInput!): UpdateDraftJobPostPayload
    "Updates (replaces) any provided verification info for the specified advertiserId"
    updateDraftVerificationInfo(input: VerificationInfoInput!): UpdateDraftVerificationInfoPayload
    updateJobSeekerProfile(input: UpdateJobSeekerProfileInput!): UpdateJobSeekerProfilePayload
    updateJobSeekerProfileResume(input: UpdateJobSeekerProfileResumeInput!): UpdateJobSeekerProfileResumePayload
    updateJobSeekerProfileResumeAwards(input: UpdateJobSeekerProfileResumeAwardsInput!): UpdateJobSeekerProfileResumeAwardsPayload
    updateJobSeekerProfileResumeCertifications(input: UpdateJobSeekerProfileResumeCertificationsInput!): UpdateJobSeekerProfileResumeCertificationsPayload
    updateJobSeekerProfileResumeEducations(input: UpdateJobSeekerProfileResumeEducationsInput!): UpdateJobSeekerProfileResumeEducationsPayload
    updateJobSeekerProfileResumeLanguageSkills(input: UpdateJobSeekerProfileResumeLanguageSkillsInput!): UpdateJobSeekerProfileResumeLanguageSkillsPayload
    updateJobSeekerProfileResumeLinks(input: UpdateJobSeekerProfileResumeLinksInput!): UpdateJobSeekerProfileResumeLinksPayload
    updateJobSeekerProfileResumeMilitary(input: UpdateJobSeekerProfileResumeMilitaryInput!): UpdateJobSeekerProfileResumeMilitaryPayload
    updateJobSeekerProfileResumeSkills(input: UpdateJobSeekerProfileResumeSkillsInput!): UpdateJobSeekerProfileResumeSkillsPayload
    updateJobSeekerProfileResumeWorkExperiences(input: UpdateJobSeekerProfileResumeWorkExperiencesInput!): UpdateJobSeekerProfileResumeWorkExperiencesPayload
    "Update an existing preference."
    updateJobSeekerProfileStructuredDataPreference(input: UpdateJobSeekerProfileStructuredDataPreferenceInput!): UpdateJobSeekerProfileStructuredDataPreferencePayload
    """

    Update a comment's text on a specified employer review.

    This requires authentication as the employer, using an account with a claim on the employer's company page.
    """
    updateReviewComment(input: UpdateReviewCommentInput!): UpdateReviewCommentPayload
    """

    Update the state of the current SavedJob to a different state. Note that the user
    for the SavedJob must be logged in for the mutation to take place.
    """
    updateSavedJobState(input: UpdateSavedJobStateInput!): UpdateSavedJobStatePayload
    uploadJobSeekerProfileFile(input: UploadJobSeekerProfileFileInput!): UploadJobSeekerProfileFilePayload
    upsertAppointment(input: UpsertAppointmentInput!): UpsertAppointmentPayload
    "Mutation Namespace for User Display Preference Mutations."
    userDisplayPreferenceMutations: UserDisplayPreferenceMutationsPayload
}

"Name output for VerificationInfo"
type Name {
    "First name"
    first: String
    "Last name"
    last: String
}

" Company email settings related to new candidate notifications "
type NewCandidateEmailSettings {
    " Determines whether or not the new candidate's resume will be attached to notification emails "
    attachResumes: Boolean!
    """

    Determines strategy used to send email notifications about new candidates
    true: Only sends email notifications for applications that match job details, such as job description
    false: Sends email notifications for all applications
    """
    prominentOptInEnabled: Boolean!
}

" Company email settings mutations related to new candidate notifications "
type NewCandidateEmailSettingsMutations {
    " Disables attachment of a new candidate's resume to email notifications "
    disableAttachResumes: DisableAttachNewCandidateResumesPayload
    " Enables attachment of a new candidate's resume to email notifications "
    enableAttachResumes(input: EnableAttachNewCandidateResumesInput): EnableAttachNewCandidateResumesPayload
    " Updates the filter strategy for new candidate email notifications "
    updateProminentOptIn(input: UpdateProminentOptInInput!): UpdateProminentOptInPayload
}

type OffsiteCtkDeviceIdMapPayload {
    ctk: ID!
    externalId: ID!
    externalIdType: OffsiteDeviceIdEnum!
}

type OffsiteDeviceIdOptOutPayload {
    externalId: ID!
}

type Optimization {
    "Optimization suggestions"
    newParam: OptimizationParameter!
    "State prior to optimization"
    oldParam: OptimizationParameter!
    "Reason for optimization"
    reason: String
    "Type of optimization"
    type: OptimizationType!
}

type OptimizationParameter {
    "Maximum range of salary"
    salaryMaximum: String
    "Minimum range of salary"
    salaryMinimum: String
    "Salary period justified for optimization"
    salaryPeriod: String
    "Title used in title normalization optimization"
    title: String
}

type OptimizationsPayload {
    "The resulting optimization"
    data: [Optimization!]!
}

type PageInfo {
    "Cursor for the last result edge or null for none."
    endCursor: String
    "True if there is a next page of results."
    hasNextPage: Boolean!
    "True if there is a previous page of results."
    hasPreviousPage: Boolean!
    "Cursor for the first result edge or null for none."
    startCursor: String
}

"""

Payload that includes:
1. file information for file that was just parsed.
(similar to file metadata returned by Profile API).
2. resume data extracted from parsing resume file
"""
type ParseJobSeekerProfileFilePayload {
    parseFileInformation: JobSeekerProfileFile
    resume: JobSeekerProfileResume
}

"Passport Account"
type PassportAccount implements Account {
    "User’s account email."
    emailAddress: String!
    "User's account ID"
    id: ID!
    "Account email confirmation status (confirmation email is sent after sign up)."
    isConfirmed: Boolean!
    """

    Whether the user is signed in or not. A user's session is not considered signed in unless
    they have confirmed their email address.
    """
    isSignedIn: Boolean!
}

type PatchDraftJobPostPayload {
    "The result of the patch update."
    result: UpdateDraftJobPostResult!
}

type PatchHostedJobPostPayload {
    "The result of the patch update."
    result: UpdateHostedJobPostResult!
}

" Used for both Performance Funnel and  Overall Engagement totals "
type PerformanceFunnel {
    activityDate: String
    sumApplies: Int
    sumApplyStarts: Int
    sumClicks: Int
    sumImpressions: Int
}

" Number of unique jobs during a time period "
type PerformanceFunnelNumJobsPayload {
    uniqueCount: Int
}

type PerformanceFunnelPayload {
    result: [PerformanceFunnel!]!
}

type PerformanceMetrics {
    "The number of job apply starts"
    applyStarts: Int!
    "The number of job clicks"
    clicks: Int!
    "The number of job apply starts"
    iaConversions: Int!
    "The number of job apply starts"
    impressions: Int!
    "The number of total job conversions"
    totalConversions: Int!
}

type PerformingJobsPayload {
    result: [SpendSummaryByJob!]!
}

"Information for a individual presigned document"
type PresignedDocumentUploadInfo {
    "The document ID"
    id: String!
    "The presigned URL to be used for file upload"
    url: URI!
}

"Results for presigned url request"
type PresignedUrlResult {
    "The list of documents"
    documents: [PresignedDocumentUploadInfo!]!
}

type PublishDraftJobPostPayload {
    "The result from PublishDraftJobPost."
    result: PublishDraftJobPostResult!
}

type PublishDraftJobPostResult {
    "The HostedJobPost result from PublishDraftJobPost."
    hostedJobPost: HostedJobPost!
}

"The advertising location of published job post."
type PublishedAdvertisingLocation {
    """

    At least one location must be active = true.
    A job may no longer be available at a location by setting to false.
    Default: false.
    """
    active: Boolean!
    """

    The minimum granularity of suggested locations.
    A default granularity will be used if this parameter is not given.
    """
    granularity: MinimumGranularity
    "The encrypted unique identifier of the job published in this location."
    jobKey: String
    """

    The job location is validated against our location service to return locations that are found and can be normalized.
    If location cannot be found, error returned.
    """
    location: String!
    "The public URL of this job."
    publicJobPageUrl: WebUrl
}

type Query {
    _drmxFedDraftJobsMutationApiPlaceholder: String
    _drmxFedHostedEmployerMutationApiPlaceholder: String
    _indeedApplyPlaceholder: String
    _jobSummaryServicePlaceholder: String
    """

    Returns all of the employers associated with the currently authenticated account.

    **Attributes**
    If employer attributes are required, the attribute keys must be explicitly specified. e.g.:
    ```
    query {
    allHostedEmployers {
    result {
    hostedEmployer {
    attributes(keys: ["key1", "key2"]) { key value }
    }
    }
    }
    }
    ```
    """
    allHostedEmployers: AllHostedEmployersPayload!
    appointment(input: AppointmentInput!): AppointmentPayload
    "Get an availability resource."
    availabilityResource(input: AvailabilityResourceInput!): AvailabilityResourcePayload
    """

    Retrieve information for countries available to the user. Country names is
    translated into the language of the current country. Information about the
    current country is the first list element in the response.

    _URL Parameters:_
    - **co** : Required country parameter passed from Federator.
    Format: [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
    (Example: "US", "JP", "CA")
    - **locale** : Used for localizing response data.
    Format: [BCP 47 language tag](https://tools.ietf.org/html/bcp47).
    (Example: "en-US")
    """
    availableCountrySites: AvailableCountrySitesPayload
    "Returns bulk for a list of market insights based on jobTitle and location."
    bulkMarketInsights(input: [MarketInsightsInput!]!): BulkMarketInsightsPayload
    " Campaigns "
    campaigns(input: FilteredNamesFetcherInput!): CampaignsPayload
    """

    Returns the best list of Occupations based on the input information.  Some scenarios will not return
    useful information, such as passing in only a company.
    """
    classifyOccupationsForJobDetails(input: ClassifyOccupationsForJobDetailsInput!): ClassifyOccupationsForJobDetailsPayload
    " Provides queries related to company settings "
    companySettings: CompanySettingsQueries
    """

    Returns the currently authenticated employer.

    **Attributes**
    If employer attributes are required, the attribute keys must be explicitly specified. e.g.:
    ```
    query {
    currentHostedEmployer {
    result {
    hostedEmployer {
    attributes(keys: ["key1", "key2"]) { key value }
    }
    }
    }
    }
    ```
    """
    currentHostedEmployer: CurrentHostedEmployerPayload!
    "Current user"
    currentUser: CurrentUserPayload
    " Device Clicks "
    deviceClicks(input: CommonInput!): DeviceClicksPayload
    dossier(country: String!, key: ID!, language: String!): EmployerDossier
    downloadJobSeekerProfileFile(input: DownloadJobSeekerProfileFileInput!): DownloadJobSeekerProfileFilePayload
    "Returns a list of draft job posts by IDs."
    draftJobPosts(ids: [ID!]!): DraftJobPostsPayload
    "Returns the verification info associated with the advertiserId"
    draftVerificationInfo: DraftVerificationInfoPayload
    "Query employer data given a list of employer keys. Country and language are for localizing some content."
    employers(country: String, keys: [ID!]!, language: String): [Employer]
    "Estimate the salary for given job details"
    estimateSalaryForJobDetails(input: EstimateSalaryForJobDetailsInput!): EstimateSalaryForJobDetailsPayload!
    "Get an availability resource of type [EventCalendar]."
    eventCalendar(input: EventCalendarInput!): EventCalendarPayload
    "Returns a list of draft job posts. Advanced search with filtering by multiple criteria, sorting and pagination."
    findDraftJobPosts(input: FindDraftJobPostsInput!): FindDraftJobPostsPayload
    "Finds employer jobs. Supports filtering, sorting, and pagination."
    findEmployerJobs(input: FindEmployerJobsInput!): FindEmployerJobsPayload
    "Search for employers"
    findEmployers(input: FindEmployersInput): FindEmployersPayload
    "Get RSVP info by many-to-one identifers (e.g. account key)."
    findHiringEventRsvps(input: FindHiringEventRsvpsInput!): FindHiringEventRsvpsPayload
    findHiringEvents(input: FindHiringEventsInput!): FindHiringEventsPayload
    "Queries for published Hosted Job Posts with filter, pagination and sort"
    findHostedJobPosts(input: FindHostedJobPostsInput!): FindHostedJobPostsPayload
    """

    Retrieve relevant jobs for a user

    _HTTP Headers:_

    - **indeed-ctk** : User CTK used for personalization.
    - **indeed-fed-account-id** : User Account Id used for personalization.
    - **indeed-fed-ad-format** : Used to identify surfaces. Effects ranking and encoded ad data.
    - **indeed-fed-request-tk** : Used for logging and in encoded ad data.
    - **indeed-prforce-groups** : Used to force proctor groups for downstream services. Format: [Forcing Groups](https://opensource.indeedeng.io/proctor/docs/using-groups/#forcing-groups)

    _URL Parameters:_

    - **co** : Target country for search. Format: [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (Example: "CA")
    - **locale** : Used for localizing response data. Format: [BCP 47 language tag](https://tools.ietf.org/html/bcp47). Language portion can influence search matching (Example: "en-US")

    **Example query**

    ```
    Query:
    {
    findRelevantJobs (input: {
    limit: 3
    isMobile: true
    lastVisitTime: 0
    context: "iOSWidget"
    }
    )
    {
    trackingKey
    results {
    matchReason {
    __typename
    ... on DefaultRelevantJobsMatchInfo {
    reason
    }
    ... on RecentQueryRelevantJobsMatchInfo {
    query
    location
    reason
    }
    }
    job {
    title,
    sourceEmployerName,
    employer {
    key
    }
    location {
    formatted {
    short
    }
    }
    compensation {
    key
    }
    indeedApply {
    scopes
    }
    datePublished
    description {
    text
    }
    }
    indeedJobData {
    viewJobRedirectClickUrl
    }
    }
    }
    }

    Headers:
    ```
    {
    "authorization": "Basic dGVzdENsaWVudDp0ZXN0QXBpS2V5",
    "indeed-ctk": "1f2n1ul1g011q800",
    "indeed-fed-account-id":1171387598,
    "indeed-fed-ad-format":"mob",
    "indeed-fed-client-name": "graphQLPlayground",
    "indeed-fed-user-ip": "207.191.44.146"
    }
    ```
    """
    findRelevantJobs(
        "Maximum number of results to be returned. Must be at least 1 and at most 200."
        input: FindRelevantJobsInput!
    ): FindRelevantJobsPayload
    """

    Query Endpoint to Find and Retrieve Targeted Content

    _HTTP Headers:_

    - **indeed-ctk** : Used for personalizing targeted content results (e.g., ITA)
    - **indeed-prforce-groups** : Used to force proctor groups for TargetedContentService requests.
    Format: [Forcing Groups](https://opensource.indeedeng.io/proctor/docs/using-groups/#forcing-groups)

    _URL Parameters:_

    - **co** : User's country. Format: [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (Example: "CA")
    - **locale** : Used for localizing response data. Format: [BCP 47 language tag](https://tools.ietf.org/html/bcp47). Language portion can influence search matching (Example: "en-US")
    """
    findTargetedContent(input: FindTargetedContentInput!): FindTargetedContentPayload
    "findUserDisplayPreferences is used to find the high level userDisplayPreference document that corresponds to the given accountId."
    findUserDisplayPreference: FindUserDisplayPreferencePayload
    "findUserDisplayPreferenceById is used for testing and data drop requests to identify documents were removed successfully."
    findUserDisplayPreferenceById(input: FindUserDisplayPreferenceByIdInput): FindUserDisplayPreferenceByIdPayload
    "Returns business data based on business name, street address, lat/lon coordinates, postal code, and country"
    findYelpBusiness(input: FindYelpBusinessInput): FindYelpBusinessPayload
    "Returns matching businesses based on business name, street address, lat/lon coordinates, postal code, and country"
    findYelpBusinesses(input: [FindYelpBusinessInput!]!): FindYelpBusinessesPayload
    "Returns a list of businesses that match provided ids"
    findYelpBusinessesByIds(input: FindYelpBusinessesByIdsInput): FindYelpBusinessesByIdsPayload
    """

    Get IHP subsctiptions for advertisers.
    If not subscription is found for an Id the entry will be missing on the response list
    """
    getIhpAdvertiserSubscriptionsByAdvertiser(input: GetIhpAdvertiserSubscriptionsByAdvertiserInput!): IhpSubscriptionPayload!
    """

    Count the number of organic jobs that match given filters. The response consists of country codes with non-zero counts.

    **Note:** Because of a technical reason, the URL parameter **co** must be "US".

    _HTTP Headers:_

    - **indeed-prforce-groups** : Used to force proctor groups for JobRetrievalService and JobSearchService requests. Format: [Forcing Groups](https://opensource.indeedeng.io/proctor/docs/using-groups/#forcing-groups)
    - **indeed-fed-client-roles** : Used to present the roles of the client. This is a multi-value header. Currently, the following roles are supported:
    - _**allow-glassdoor-data**_ - This must be set.
    - **indeed-fed-client-flags** : Used for enabling client-specific behavior. This is a multi-value header. Currently, the following flags are supported:
    - _**return-sponsored-jobs-as-organic**_ - Count sponsored jobs too. Any sponsored-specific logic such as auction is not taken into account.

    _URL Parameters:_

    - **co** : This must be "US".

    **Example query:**

    ```
    {
    globalJobCount(
    input: {
    filters: [
    {
    keyword: {
    field: "glassdoor.employerKey"
    keys: ["xxx", "yyy"]
    operation: OR
    }
    }
    ]
    grouping: {
    type: EMPLOYER_LOCATION
    }
    }
    ) {
    results {
    countryCode
    count
    }
    }
    }
    ```

    **Example response:**

    ```
    {
    "data": {
    "globalJobCount": {
    "results": [
    {
    "countryCode": "CA"
    "count": 123
    }
    {
    "countryCode": "US"
    "count": 456
    }
    ]
    }
    }
    }
    ```
    """
    globalJobCount(input: GlobalJobCountInput!): GlobalJobCountPayload
    highlightedReview(countryCode: String!, employerKey: String!, languageCode: String!): [HighlightedReview!]!
    "Get client intake info by one-to-one identifiers (e.g. client intake UUID)."
    hiringEventClientIntakes(input: HiringEventClientIntakesInput!): HiringEventClientIntakesPayload
    "Get hiring event contact information such as emails."
    hiringEventContactInfos(input: HiringEventContactInfosInput!): HiringEventContactInfosPayload
    "Get RSVP info by one-to-one identifiers (e.g. RSVP UUID)."
    hiringEventRsvps(input: HiringEventRsvpsInput!): HiringEventRsvpsPayload
    """

    Returns a list of employers given a list of employer ids.
    If the id list is empty or null, this query will return the currently authenticated employer.

    **Attributes**
    If employer attributes are required, the attribute keys must be explicitly specified. e.g.:
    ```
    query {
    hostedEmployers(ids:["abc", "def"]) {
    result {
    hostedEmployer {
    attributes(keys: ["key1", "key2"]) { key value }
    }
    }
    }
    }
    ```
    """
    hostedEmployers(
        """

        A list of employer IDs to match.
        If the id list is null, this query will return the currently authenticated employer.
        """
        ids: [ID!]!
    ): HostedEmployersPayload!
    "Get Hosted Job Post counts"
    hostedJobPostCounts(input: HostedJobPostCountsInput!): HostedJobPostCountsPayload
    "Get the performance of the job in specific date range"
    hostedJobPostPerformance(input: HostedJobPostPerformanceInput!): HostedJobPostPerformancePayload!
    "Simple queries for Hosted Job Posts by IDs"
    hostedJobPosts(ids: [ID!]!): HostedJobPostsPayload
    "Simple queries for Hosted Job Posts by legacy IDs"
    hostedJobPostsByLegacyIds(ids: [ID!]!): HostedJobPostsPayload
    ihpFindRecommendedJobs(input: IhpFindRecommendedJobsInput!): IhpJobRecommendationsConnection
    ihpIsRecommendedJob(input: IhpIsRecommendedJobInput!): IhpIsRecommendedJobPayload
    jobCompensation(keys: [ID!]!): [JobCompensation]!
    """

    Retrieve job data for input jobKeys. If a jobKey is not found no data is returned

    _HTTP Headers:_

    - **indeed-prforce-groups** : Used to force proctor groups for JobRetrievalService and JobSearchService requests. Format: [Forcing Groups](https://opensource.indeedeng.io/proctor/docs/using-groups/#forcing-groups)
    - **indeed-fed-client-roles** : Used to present the roles of the client. This is a multi-value header. Currently, the following roles are supported:
    - _**allow-glassdoor-data**_ - Allow the client to access Glassdoor filters, facets in jobSearch and glassdoor field in jobData.
    - _**allow-nowhere-jobs**_ - Allow the client to include nowhere jobs in the results. This role is the prerequisite for getting nowhere jobs in the jobData query.
    - _**allow-fraudulent-jobs**_ - Allow the client to include jobs that are confirmed fraudulent in the results. This role is the prerequisite for getting `isConfirmedFraudulent` field in the `Job`.


    _URL Parameters:_

    - **locale** : Used for localizing response data. Format: [BCP 47 language tag](https://tools.ietf.org/html/bcp47) (Example: "en-US")
    """
    jobData(
        input: JobDataInput,
        """

        This field is deprecated in favor of `input` - however, if `jobKeys` is set,
        requests must include at least 1 jobKey and are limited to a maximum of 500 jobKeys.

        If `jobs` is set, requests must include at least one `JobDataKeyInput` and are limited to a maximum of
        500 `JobDataKeyInput`.

        Also, only one of 'jobKeys' or 'input' can be specified in the query - not both.
        """
        jobKeys: [ID!]
    ): JobDataPayload!
    """

    Search for jobs

    _Count Only Requests:_
    To execute "count" only request, either specify a `limit` of 0 or do not request the `JobSearchPayload.results`

    _HTTP Headers:_

    - **indeed-ctk** : Used for personalizing search results (e.g., ranking and matching)
    - **indeed-prforce-groups** : Used to force proctor groups for JobRetrievalService and JobSearchService requests. Format: [Forcing Groups](https://opensource.indeedeng.io/proctor/docs/using-groups/#forcing-groups)
    - **indeed-fed-client-roles** : Used to present the roles of the client. This is a multi-value header. Currently, the following roles are supported:
    - _**allow-job-search-metadata**_ - Allow the client to include job search metadata in the results. This role is the prerequisite for the `metadata` field in the `JobSearchPayload`.
    - _**allow-sponsored-jobs**_ - Allow the client to include sponsored jobs in the results. This role is the prerequisite for using the 'includeSponsoredResults' field in the jobSearch query.
    - _**allow-glassdoor-data**_ - Allow the client to access Glassdoor filters, facets in jobSearch and glassdoor field in jobData.
    - **indeed-fed-client-flags** : Used for enabling client-specific behavior. This is a multi-value header. Currently, the following flags are supported:
    - _**return-sponsored-jobs-as-organic**_ - Handle sponsored jobs as if they are organic. Any sponsored-specific logic such as auction is skipped. The 'allow-sponsored-jobs' client role is ignored.


    _URL Parameters:_

    - **co** : Target country for search. Format: [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (Example: "CA")
    - **locale** : Used for localizing response data. Format: [BCP 47 language tag](https://tools.ietf.org/html/bcp47). Language portion can influence search matching (Example: "en-US")
    """
    jobSearch(
        """

        Allow clients to page through results. Leave unset for first page results

        To page forward set cursor to JobSearchPayload pageInfo.nextCursor
        To page back set cursor to JobSearchPayload pageInfo.prevCursor
        To page forward or backward more than one page, use cursor in JobSearchPayload pageInfo.nextPages or pageInfo.prevPages
        """
        cursor: String,
        "Specify filters to narrow down search results"
        filters: [JobSearchFilterInput!]! = [],
        grouping: JobSearchGroupingInput! = {type: EMPLOYER_TITLE},
        """

        Include sponsored results or not in the results. Do not return any sponsored job if this field is not specified.

        **Note:** In order to include sponsored jobs, clients need to apply for the access to this field.
        Please refer to this [wiki](https://wiki.indeed.com/pages/viewpage.action?spaceKey=JSAPI&title=Jobseeker+GraphQL+API+Documentation#JobseekerGraphQLAPIDocumentation-HowdoIgetaccesstosponsoredjobcontentviathejobSearchAPI?)
        to get the permission.

        If the client does not have the access permission, no sponsored job is returned regardless of what value is
        specified for this field. In addition, if 'return-sponsored-jobs-as-organic' client flag is specified,
        this field is ignored.
        """
        includeSponsoredResults: JobSearchIncludeSponsoredResults! = NONE,
        """

        Time of last search in milliseconds. This is used to determine `sinceLastSearchCount` in `JobSearchPayload`.
        This parameter does not affect the age of jobs returned in results.
        """
        lastSearchTime: Timestamp,
        """

        Maximum number of results to be returned. Must be at least 1 and at most 100

        A request fails if this field is modified during pagination, that is, this field does not match the limit in a valid "cursor"

        The value for `limit` is ignored when `JobSearchPayload.results` field is not requested; defaults to 10 otherwise
        """
        limit: Int! = 10,
        "Search location"
        location: JobSearchLocationInput! = {where: "", radius: 0, radiusUnit: KILOMETERS},
        "Maximum number of pages to be returned in `JobSearchPayloadPageInfo` for next pages (`nextPages`). Must be at least 1 and at most 5"
        numNextPages: Int! = 1,
        "Maximum number of pages to be returned in `JobSearchPayloadPageInfo` for previous pages (`prevPages`). Must be at least 1 and at most 5"
        numPrevPages: Int! = 1,
        "A serialized representation of the job search"
        searchCriteria: String,
        "Order to sort search results"
        sort: JobSearchSortOrder! = RELEVANCE,
        """

        Search query

        **Examples:**
        - "nurse"
        - "part-time"
        """
        what: String! = ""
    ): JobSearchPayload!
    jobSeekerProfile: JobSeekerProfilePayload
    jobSeekerProfileStructuredData(input: JobSeekerProfileStructuredDataInput): JobSeekerProfileStructuredDataPayload
    """

    An API that returns the list of jobs that may be new, updated, or deleted
    from the last `jobUpdate` API call indicated by `cursor`.
    This API will not return jobs that are no longer available in the data center.

    Note that in order to avoid gateway timeout we may terminate collecting job updates and
    return a fewer number of results than `maxNumJobs` even if there are more updates available now.
    Please make sure to check the `pageInfo/hasNextPage` to identify if you should make another `jobUpdate` API call.

    **Note:** This API is currently supported in CMH data center only. If your request is routed to other data centers,
    this API will result in an error of code **UNAVAILABLE_IN_THIS_DATA_CENTER**

    _HTTP Headers:_

    - **indeed-fed-client-name** : Used to identify the client. The behavior of this API may be different per client. This must be one of the following:
    - glassdoor-google-for-jobs
    - glassdoor-google-for-jobs-qa
    - job-index-push-daemon
    - jobseeker-graphql-playground
    - zion-federator-test-automation

    **Example query**

    ```
    {
    jobUpdate(
    input: {
    cursor: "XXXXX"
    countryCodes: ["US"]
    }
    ) {
    pageInfo {
    endCursor
    hasNextPage
    }
    updatedJobs {
    status
    job {
    key
    title
    }
    }
    }
    }
    ```

    **Example response**

    ```
    {
    "data": {
    "jobUpdate": {
    "pageInfo": {
    "endCursor": "YYYYY",
    "hasNextPage": true
    },
    "updatedJobs": [
    {
    "status": "INACTIVE",
    "job": {
    "key": "abcd1234",
    "title": "Engineer"
    }
    },
    {
    "status": "ACTIVE",
    "job": {
    "key": "cdef5678",
    "title": "Manager"
    }
    }
    ]
    }
    }
    }
    ```

    **Example response during data center failover**

    ```
    {
    "errors": [
    {
    "message": "Exception while fetching data (/jobUpdate) : This data center does not support jobUpdate API",
    "locations": [
    {
    "line": 2,
    "column": 3
    }
    ],
    "path": [
    "jobUpdate"
    ],
    "extensions": {
    "code": "UNAVAILABLE_IN_THIS_DATA_CENTER",
    "classification": "DataFetchingException"
    }
    }
    ]
    }
    ```
    """
    jobUpdate(input: JobUpdateInput!): JobUpdatePayload
    """

    An API to return the URL of snapshot of active jobs. From the URL you can download a tar file compressed in gzip format.
    It is recommended to access the URL within 5 minutes after this API call.

    The tar file consists of the following files.
    - `cursor.json`: This contains the information of the cursor you should provide in the next `jobUpdate` API call.
    - `snapshot_${countryCode}.json`: This contains the list of jobs in the country. Each job consists of a subset of `Job` and at least contains `key`.
    The contents may differ per client. Please reach out to the Job Search Backend team to make sure it contains every field you need.

    **Note:** This API is currently supported in CMH data center only. If your request is routed to other data centers,
    this API will result in an error of code **UNAVAILABLE_IN_THIS_DATA_CENTER***

    _HTTP Headers:_

    - **indeed-fed-client-name** : Used to identify the client. This must be one of the following:
    - glassdoor-google-for-jobs
    - glassdoor-google-for-jobs-qa
    - jobseeker-graphql-playground
    - zion-federator-test-automation

    **Example query**

    ```
    {
    jobUpdateSnapshotUrl {
    url
    }
    }
    ```

    **Example response**

    ```
    {
    "data": {
    "jobUpdateSnapshotUrl": {
    "url": "https://example.com/snapshot.tar.gz"
    }
    }
    }
    ```

    **Example response during data center failover**

    ```
    {
    "errors": [
    {
    "message": "Exception while fetching data (/jobUpdateSnapshotUrl) : This data center does not support jobUpdateSnapshotUrl API",
    "locations": [
    {
    "line": 2,
    "column": 3
    }
    ],
    "path": [
    "jobUpdateSnapshotUrl"
    ],
    "extensions": {
    "code": "UNAVAILABLE_IN_THIS_DATA_CENTER",
    "classification": "DataFetchingException"
    }
    }
    ]
    }
    """
    jobUpdateSnapshotUrl: JobUpdateSnapshotUrlPayload
    " Jobs "
    jobs(input: FilteredNamesFetcherInput!): JobsPayload
    " Jobs & Campaigns Analytics By Campaign "
    jobsCampaignsAnalyticsByCmp(input: JobCampaignDetailsInput!): JobsCampaignsAnalyticsByCmpPayload
    " Jobs & Campaigns Analytics By Job "
    jobsCampaignsAnalyticsByJob(input: JobCampaignDetailsInput!): JobsCampaignsAnalyticsByJobPayload
    " Jobs & Campaigns Analytics By Location "
    jobsCampaignsAnalyticsByLoc(input: JobCampaignDetailsInput!): JobsCampaignsAnalyticsByLocPayload
    " Jobs & Campaigns Analytics For All Jobs "
    jobsCampaignsAnalyticsForAll(input: JobCampaignDetailsInput!): JobsCampaignsAnalyticsForAllPayload
    " Jobs & Campaigns Analytics Number of Job per Campaign "
    jobsCampaignsAnalyticsNJobCmp(input: NumJobPerCampaignInput): JobsCampaignsAnalyticsNJobCmpPayload
    " Jobs & Campaigns Analytics Number of Campaigns "
    jobsCampaignsAnalyticsNumCmp(input: JobCampaignDetailsInput!): JobsCampaignsAnalyticsNumCmpPayload
    " Jobs & Campaigns Analytics Number of Jobs "
    jobsCampaignsAnalyticsNumJob(input: JobCampaignDetailsInput!): JobsCampaignsAnalyticsNumJobPayload
    " Jobs & Campaigns Analytics Number of Locations "
    jobsCampaignsAnalyticsNumLoc(input: JobCampaignDetailsInput!): JobsCampaignsAnalyticsNumLocPayload
    " Locations "
    locations(input: FilteredNamesFetcherInput!): LocationsPayload
    "Returns market insights based on jobTitle and location."
    marketInsights(input: MarketInsightsInput!): MarketInsightsPayload
    matchingResult(input: FetchSQInput!): MatchingResultPayload
    """

    Query the current user's approved claims on company pages.

    This requires authentication.
    """
    myEmployerClaims(
        "Optional filter for specific employer keys"
        employerKeys: [ID!],
        "The max number of items to return"
        limit: Int! = 100
    ): EmployerClaimsResult!
    "Returns a list of optimizations for an advertiserId and jobId"
    optimizations(input: OptimizationsInput!): OptimizationsPayload
    " Performance Funnel "
    performanceFunnel(input: CommonInput!): PerformanceFunnelPayload
    " Performance Funnel Number of Jobs "
    performanceFunnelNumJobs(input: CommonInput!): PerformanceFunnelNumJobsPayload
    " Performing Jobs "
    performingJobs(input: SpendInput!): PerformingJobsPayload
    "Query local average of ratings for a job title in a location"
    ratings(country: String!, jobTitle: String!, language: String!, location: String): RatingBundle
    "Returns the current health status of the service"
    recommendationStatus: RecommendationStatusPayload
    "Returns a list of recommendations filtered according to the authorised advertiserIds or the authorised masqueraded users"
    recommendations(input: RecommendationsInput!): RecommendationsPayload
    "Get related concepts to a given concept in a given relationship."
    relatedTaxonomyConcepts(input: RelatedTaxonomyConceptsInput!): RelatedTaxonomyConceptsPayload
    """

    Returns an RequirementMatchPayload containing a PropertyMatch representing the matching/mismatching
    requirements for the provided jobseeker and all provided jobs. Result[i] corresponds to the
    PropertyMatch between the jobseeker and the job at jobs[i]
    """
    requirementMatches(requirementMatchInput: RequirementMatchInput!): RequirementMatchPayload!
    " Resume "
    resumeDetails(input: CommonInput!): ResumeDetailsPayload
    resumeSummary(input: CommonInput!): ResumeSummaryPayload
    "Query the reviews of a given employer, identified by key"
    reviews(filter: ReviewFilterParams, key: ID!, paging: PagingParams, sort: [ReviewSortParams]): [Review]
    "Query salaries. Country code must be provided, but can also be filtered on `jobTitle` or `key`. Location, jobTitle and key fields are deprecated. Use filter instead."
    salaries(
        filter: SalaryInput,
        "Deprecated. Use recommended filter instead."
        jobTitle: String,
        "Deprecated. Use recommended filter instead."
        key: ID,
        "Deprecated. Use recommended filter instead."
        location: String
    ): SalaryInfo
    "Given the locale, return the salary format"
    salaryFormatForLocale(input: SalaryFormatForLocaleInput!): SalaryFormatForLocalePayload!
    """

    Retrieve SavedJobs associated with the user, filtering by those in the specified state.
    Paging is supported by specifying the paging parameter. When omitted the first page of
    a maximum of 100 results is returned.
    """
    savedJobs(paging: SavedJobPaging, state: SavedJobState!): SavedJobsResult
    "Retrieve SavedJob state for the current user for the given job keys. Up to 500 keys can be provided."
    savedJobsByKey(keys: [ID!]!): [SavedJob]
    " Spend Summary "
    spendSummary(input: CommonInput!): SpendSummaryPayload
    "Provide experimental sponsorship queries"
    sponsorshipExperimentals: SponsorshipExperimentals
    "Returns company info that can be used to auto-populate advertiser fields"
    suggestCompanyAutofill(input: SuggestCompanyAutofillInput): SuggestCompanyAutofillPayload
    "Returns details about the given TaxonomyConcepts by multiple filters."
    taxonomyConcepts(input: TaxonomyConceptsInput!): TaxonomyConceptsPayload
    templatesByAdvertiser(advertiserId: Int!): [HiringEventInterviewConfig!]!
    timepunches(after: String, before: String, first: Int, last: Int, offset: Int, workerExternalId: String): TimePunchNodeConnection
    toByPassSchemaLoadingError: String
    "Get an availability resource of type [UserCalendar]."
    userCalendar(input: UserCalendarInput!): UserCalendarPayload
    "Add userInteractionLoggingURL as a field here to bypass schema loading error in federation 'Syntax Error: Expected Name, found }'"
    userInteractionLogging: String
    "Generate and return short lived pre-signed URL for document upload"
    verificationDocumentUploadUrls: VerificationDocumentUploadUrlsPayload
    "Returns the verification status of the associated advertiserId"
    verificationStatus: VerificationStatusPayload
}

type Range {
    max: Float!
    min: Float!
}

type RatingBundle {
    "Average rating of employer provided compensation and benefits"
    compensationAndBenefitsRating: AverageRating
    "Average rating of employer's culture and values"
    cultureAndValuesRating: AverageRating
    "Average rating of employer's job security and career advancement prospects"
    jobSecurityAndAdvancementRating: AverageRating
    "Average rating of employer's management"
    managementRating: AverageRating
    "Overall global rating"
    overallRating: AverageRating
    "Average rating assessing work-life balance at employer"
    workLifeBalanceRating: AverageRating
}

type RecentQueryRelevantJobsMatchInfo {
    "The original \"where\" in the search query that resulted in the match, only relevant to search driven match provider"
    location: String
    "The original \"what\" in the search query that resulted in the match, only relevant to search driven match provider"
    query: String
    "see MatchReasonId on https://go.indeed.com/GLYK6YA6M"
    reason: String!
}

type Recommendation {
    "Categories the recommendation belongs to"
    categories: [RecommendationFilter!]!
    "Date of the recommendation"
    date: Date!
    "Unique identifier of the Recommendation"
    id: String!
    "Targets of the recommendation"
    targets: [RecommendationTarget!]!
    "RecommendationType of the recommendation"
    type: RecommendationType!
}

type RecommendationMapTuple {
    "Filter category"
    key: RecommendationFilter!
    "The number of recommendations found in this category"
    value: Int
}

type RecommendationStatus {
    "Http status of the service"
    httpStatus: HttpStatusReadable!
    "Name of the service"
    serviceName: String!
}

type RecommendationStatusPayload {
    "List of statuses from the various services"
    RecommendationStatuses: [RecommendationStatus!]!
}

type RecommendationTarget {
    "Id of the Recommendation Target"
    id: String!
    "Name of the Recommendation Target"
    name: String
    "Type of the Target of the Recommendation"
    type: RecommendationTargetType!
}

type RecommendationsPayload {
    "Counts per category for filter section."
    recommendationTotals: [RecommendationMapTuple!]!
    "The resulting recommendation."
    recommendations: [Recommendation!]!
}

type RecordApplyStartPayload {
    "Job Result Tracking Key for the job for which the apply process was started."
    jobResultTrackingKey: ID!
}

type RecordCandidateContactPayload {
    success: Boolean!
}

type RecordCandidateUpatePayload {
    success: Boolean!
}

type RecordCandidateViewPayload {
    success: Boolean!
}

type RecordJavascriptDetectionPayload {
    "Cookie tracking key."
    ctk: String!
}

type RecordJobClickPayload {
    "Cookie tracking key."
    ctk: String!
    "Clicked Job Key"
    jobResultTrackingKey: ID!
}

type RecordJobDataResultsShownPayload {
    "The tracking keys for the jobs that were shown - expected to be encoded with type information"
    trackingKeys: [ID!]!
}

type RecordJobSearchResultsShownPayload {
    "Cookie tracking key."
    ctk: String!
}

type RecordJobSeenPayload {
    "Cookie tracking key."
    ctk: String!
}

type RecordMosaicOptOutPayload {
    "Cookie tracking key."
    ctk: String!
}

"Payload with return data with the result of recording user interaction (Content Shown/Content Seen)"
type RecordMultipleTargetedContentUserInteractionsPayload {
    "Mutation result"
    results: [TargetedContentUserInteractionResult!]!
}

"Payload with return data with the result of recording user interaction (Content Click/Content Close)"
type RecordSingleTargetedContentUserInteractionPayload {
    "Mutation result"
    result: TargetedContentUserInteractionResult!
}

type RelatedTaxonomyConceptsPayload {
    responseStatus: MdsResponseStatus!
    "TaxonomyConepts details."
    taxonomyConcepts: [TaxonomyConcept!]
}

type RelevantJobsResult {
    indeedJobData: IndeedJobData
    job: Job!
    key: ID!
    matchReason: RelevantJobsMatchInfo!
}

type RemoveAvailabilityPeriodsPayload {
    "Ids of availability periods that were removed."
    keys: [String!]!
    "ID of the [AvailabilityResource] periods were removed from."
    resourceId: ID!
}

type RemoveJobSeekerProfileStructuredDataPreferencePayload {
    "Preference."
    preference: JobSeekerProfileStructuredDataPreference
}

type RemoveUDPAllConfirmedSectionsPayload {
    "Document of userDisplayPreference payload."
    userDisplayPreference: UserDisplayPreferencePayload!
}

type RemoveUDPConfirmedSectionsPayload {
    "Document of userDisplayPreference payload."
    userDisplayPreference: UserDisplayPreferencePayload!
}

type RemoveUDPSkippedQuestionsPayload {
    "Document of userDisplayPreference payload."
    userDisplayPreference: UserDisplayPreferencePayload!
}

type RemoveUserDisplayPreferencePayload {
    "ID of the User Display Preference that has been deleted."
    deletedUserDisplayPreference: ID!
}

type ReplaceFieldsJobSeekerProfileStructuredDataDislikedPreferencePayload {
    "Disliked Preference."
    dislikedPreference: JobSeekerProfileStructuredDataPreference
}

type ReportDate {
    "Report month"
    month: Int!
    "Report year"
    year: Int!
}

type RequirementMatchPayload {
    propertyMatches: [RequirementsMatch!]!
}

"An object capturing the lists of Properties that are shared and different for a particular job-resume pair"
type RequirementsMatch {
    "The jobKey associated with these matches"
    jobKey: ID!
    """

    Each list below contains some properties that are found either only in the job, the jobseeker, or
    both
    """
    jobOnlyProperties: [RequirementsMatchProperty!]!
    jobSeekerOnlyProperties: [RequirementsMatchProperty!]!
    matchingProperties: [RequirementsMatchProperty!]!
}

"""

A property of some object like a job or resume
This consists of an attribute, and a relation
Relation is not yet supported,
so existing users of this representation infer the type of relation from the context
"""
type RequirementsMatchProperty {
    "The display text of the attribute associated with this property"
    attributeDisplayText: String!
    "The id of the attribute associated with this property"
    attributeId: ID!
}

"""

Availability settings for an [AvailabilityResource].

The availability settings specify the times when a resource is available to schedule
events. The actual calendar availability is calculated with these steps:

1. The default state for a particular time is unavailable
2. Add time periods that match the [include] settings
3. Remove time periods that match [exclude] settings
4. Remove time periods that are not in the availability [window]
5. Remove any events scheduled on the resource
6. Remove any holds registered on the resource

The remaining time periods determine when the resource is available.
"""
type ResourceAvailabilitySettings {
    "Settings that specify time the resource is explicitly unavailable."
    exclude: ExcludeAvailabilitySettings!
    "Settings that specify time the resource is potentially available."
    include: IncludeAvailabilitySettings!
    "Window in the future that events can be scheduled on the resource."
    window: AvailabilityWindow!
}

" Resume Details "
type ResumeDetails {
    accountID: Int
    allContacts: Int
    allResponsesCount: Int
    freeContacts: Int
    overallResponseRate: Float
    positiveResponsesCount: Int
    searches: Int
    sharedContacts: Int
    views: Int
}

type ResumeDetailsPayload {
    result: [ResumeDetails!]!
}

" Resume Summary "
type ResumeSummary {
    activityDate: String
    allResponsesCount: Int
    positiveResponsesCount: Int
}

type ResumeSummaryPayload {
    result: [ResumeSummary!]!
}

"The details of a given review"
type Review {
    "Review author's account ID"
    accountId: String @deprecated(reason: "Comments are meant to be shown anonymously. Will only return -1 until removed.")
    "List of comments"
    comments: [ReviewComment]
    "Compensation / Benefits employer rating dimension for form input when rating a company."
    compensationAndBenefitsRating: Int
    "Cons given in the review"
    cons: String
    "The country code of the review"
    countryCode: String
    "Culture / Values employer rating dimension for form input when rating a company."
    cultureAndValuesRating: Int
    "The date when review was created, in ISO8601 format"
    dateCreated: String
    "The end year of the reviewed employment"
    employmentEndYear: Int
    "An excerpt from the full text of the review"
    employmentStartYear: Int
    "The number of votes that thought the review was helpful"
    helpfulVotesCount: Int
    "The ID of review"
    id: ID @deprecated(reason: "Review IDs are for internal use only. Use the review key in field `key` instead.")
    "Job category ID"
    jobCategoryId: String
    "Job Security / Advancement employer rating dimension for form input when rating a company."
    jobSecurityAndAdvancementRating: Int
    "The review key, which uniquely identifies the review"
    key: ID
    "The language code of the review"
    languageCode: String
    "Management employer rating dimension for form input when rating a company."
    managementRating: Int
    "Normalized `rawJobTitle`"
    normalizedJobTitle: String
    "Normalized `rawJobLocation`"
    normalizedLocation: String
    "Overall rating of employer of one to five starts"
    overallRating: Int
    "Pros given in the review"
    pros: String
    "Job title as it was submitted in the review"
    rawJobTitle: String
    "Job location as it was submitted in the review"
    rawLocation: String
    "The full text of the review"
    text: String
    "The title of the review"
    title: String
    "The number of votes that thought the review was unhelpful"
    unhelpfulVotesCount: Int
    "Work / Life Balance employer rating dimension for form input when rating a company."
    workAndLifeBalanceRating: Int
}

"A comment posted in reply to a review"
type ReviewComment {
    "Comment author's account ID"
    accountId: Int @deprecated(reason: "Reviews are meant to be shown anonymously. Will only return -1 until removed.")
    "The country code of the comment"
    countryCode: String!
    "The date when comment was created. ISO8601 format"
    dateCreated: String
    "The comment identifier"
    key: ID!
    "The language code of the comment"
    languageCode: String!
    "Content of comment"
    text: String
}

type Salary {
    range: RangeType
    unitOfWork: UnitOfWork
}

type SalaryDistribution {
    highlight: Boolean
    "This is the maximum salary with unit being standard main unit like dollar or yen"
    maximum: Float
    "This is the minimum salary with unit being standard main unit like dollar or yen"
    minimum: Float
    probability: Float
}

type SalaryFormatForLocalePayload {
    result: SalaryFormatForLocaleResult!
}

type SalaryFormatForLocaleResult {
    country: CountryCode!
    currency: CurrencyCode!
    currencySignAfterNumber: Boolean!
    currencySymbol: String!
    defaultExampleFormattedValue: String!
    defaultSalaryPeriod: EstimationJobSalaryPeriod!
    defaultValidationErrorMessage: String!
    formattedSalaryExampleMobile: [FormattedJobSalaryExample!]!
    formattedSalaryExampleNonMobile: [FormattedJobSalaryExample!]!
    majorToMinorMultiplier: Int!
}

"A histogram of salaries"
type SalaryHistogram {
    "The values of the histogram"
    counts: [Int!]!
    "Max value of the histogram, useful for charting y-axis max"
    maxValue: Int!
    "Min value of the histogram, useful for charting y-axis min"
    minValue: Int!
}

"Top level salary object"
type SalaryInfo {
    "Salary information for given constraints"
    salary: SalaryStatsOverview
    "Salary information for given constraint grouped by job title, location or employer ID"
    salaryGroups(groupBy: SalaryGroupBy!, limit: Int, offset: Int, sortBy: SalarySortBy): [SalaryStatsGroup!]!
}

type SalaryStats {
    "Number of salary data points of the given type"
    count: Int
    "ISO8601 formatted datetime"
    latestTimestamp: String
    "Average of salary data points"
    mean: Float
    "The type of salary information"
    type: SalaryType
}

"A grouping of salary stats based on a given grouping (jobtitle, location or employer key)"
type SalaryStatsGroup {
    "Depending on grouping type, it might be Job Title, Location or Employer key"
    name: String!
    "The salary stats overview"
    salary: SalaryStatsOverview
}

"Contains SalaryStats grouped by type (`MONTHLY`, `YEARLY`, etc)"
type SalaryStatsOverview {
    "Stats for biweekly salary data points"
    biweekly: SalaryStats
    "Stats for daily salary data points"
    daily: SalaryStats
    "Stats for hourly salary data points"
    hourly: SalaryStats
    "Salary stats for the type that has biggest number of data points."
    main: SalaryStats
    "Stats for monthly salary data points"
    monthly: SalaryStats
    "Number of data points relevant to the query"
    totalCount: Int
    "Stats for weekly salary data points"
    weekly: SalaryStats
    "Stats for yearly salary data points"
    yearly: SalaryStats
}

"Representation of a Job that a user has interacted with in some way."
type SavedJob {
    "The Unix Time Stamp in milliseconds of the last time the user applied for the job."
    applyTime: Timestamp
    job: Job!
    "The unique id for the Job referenced by the SavedJob."
    jobKey: ID! @deprecated(reason: "Use `job.key`")
    "The Unix Time Stamp in milliseconds of the last time that the state was changed."
    lastUpdateTime: Timestamp!
    "String representation of the new state of the job. SAVED or UNSAVED or some other valid state."
    state: SavedJobState!
}

type SavedJobsResult {
    "The page token for the next page."
    pageToken: String
    "The SavedJobs that match the query."
    savedJobs: [SavedJob]
    "The total number of saved jobs."
    totalCount: Int!
}

"This contains only localized label for a sector, but uuid, suid also can be returned."
type SectorResult {
    "Localized label for requested country/language pair"
    localizedLabel: String!
}

type SelectOption {
    label: String!
    value: String!
}

type SimilarEmployersPayload {
    results: [SimilarEmployersResult!]!
}

type SimilarEmployersResult {
    employer: Employer!
}

type SkippedQuestionMutations {
    "Adds and/or updates the skipped questions list associated with the userDisplayPreference of the given accountId."
    addOrUpdateUDPSkippedQuestions(input: AddOrUpdateUDPSkippedQuestionsInput!): AddOrUpdateUDPSkippedQuestionsPayload
    "Removes skipped questions from userDisplayPreference that has matching accountId."
    removeUDPSkippedQuestions(input: RemoveUDPSkippedQuestionsInput!): RemoveUDPSkippedQuestionsPayload
}

"Sorting of results"
type SortByDateTime {
    "Sort by field"
    field: DateSortField!
    "Sort direction"
    sort: SortDirection!
}

" Spend summary "
type SpendSummary {
    activityDate: String
    avgCostPerApplyLocal: Float
    avgCostPerApplyStartLocal: Float
    avgCostPerClickLocal: Float
    currency: String
    sumCostLocal: Float
}

" This will be used for all of top performing N sponsored jobs, underperfrming N sponsored jobs "
type SpendSummaryByJob {
    admin1: String
    admin2: String
    admin3: String
    admin4: String
    aggJobID: String
    avgACR: Float
    avgASR: Float
    avgCTR: Float
    avgCostPerApplyLocal: Float
    avgCostPerApplyStartLocal: Float
    avgCostPerClickLocal: Float
    city: String
    country: String
    currency: String
    title: String
}

type SpendSummaryPayload {
    result: [SpendSummary!]!
}

"Namespace for sponsorship experiment queriess"
type SponsorshipExperimentals {
    """

    Cpo Eligibility query
    Returns if job is eligible for given CPO outcome
    """
    cpoEligibility(input: CpoEligibilityInput!): CpoEligibilityPayload
}

type SquareLogoUrlBundle {
    "Link to a square logo (128x128)"
    url128: String!
    "Link to a square logo (256x256)"
    url256: String!
    "Link to a square logo (64x64)"
    url64: String!
    "Link to a square logo (96x96)"
    url96: String!
}

type StoreAnswerResultPayload {
    questions: [MatchingResult!]!
}

type StructuredTag {
    clientMessage: String
    funnelMessage: String
    generalMessage: String
    jobKey: String
    jobsMessage: String
    matchingStrings: [Matching!]
    notification: Boolean!
    policyLink: String
    structuredTagMessage: String
    tagId: Int!
    tagName: String
    translations: MessageTranslations
}

"Output result for submitVerificationInfo"
type SubmitVerificationInfoPayload {
    "Whether or not the transaction succeeded"
    results: Boolean!
}

type SuggestCompanyAutofillPayload {
    "suggest autofill based on company name"
    basedOnCompanyName: CompanyAutofillPayload
    "suggested autofill based on emailDomain specified in the input or deduced from user authentication"
    basedOnEmailDomain: CompanyAutofillPayload
}

"Account Create Content, used to return Account Create Targeted Content"
type TargetedContentAccountCreateDisplayData implements TargetedContentDisplayData {
    "Content to render"
    contentsInHtml: String!
    "Text for the Sign Up Action of the Targeted Content"
    goText: String!
    "Header Image Url: Indeed logo by default"
    headerImageUrl: String!
    "URL to use for the Sign Up Action of the Targeted Content"
    landingUrl: String!
    "Text for the Sign In Action of the Targeted Content"
    signInText: String
    "URL to use for the Sign In Action of the Targeted Content"
    signInUrl: String
    "Content Title"
    title: String!
}

"Account Create Result, contains data for Account Create Targeted Content"
type TargetedContentAccountCreateResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentAccountCreateDisplayData!
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID!
}

"Company Content, used to return Relevant Employer Targeted Content"
type TargetedContentEmployerDisplayData implements TargetedContentDisplayData {
    "Content to render"
    contentsInHtml: String!
    "Employer data results"
    employerData: [TargetedEmployerData!]
    "Text for the Go Action of the Targeted Content"
    goText: String!
    "Header Image Url: Indeed logo by default"
    headerImageUrl: String!
    "URL to use for the Go Action of the Targeted Content"
    landingUrl: String!
    "Content Title"
    title: String!
}

"Targeted Relevant Company Result, contains Company data from ACME API"
type TargetedContentEmployerResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentEmployerDisplayData!
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID!
}

"Homepage Content, used to return Homepage Targeted Content"
type TargetedContentHomepageDisplayData implements TargetedContentDisplayData {
    "Content to render"
    contentsInHtml: String!
    "Text for the Go Action of the Targeted Content"
    goText: String!
    "Header Image Url: Indeed logo by default"
    headerImageUrl: String!
    "URL to use for the Go Action of the Targeted Content"
    landingUrl: String!
    "Content Title"
    title: String!
}

"Homepage Result, contains data for Homepage Targeted Content"
type TargetedContentHomepageResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentHomepageDisplayData!
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID!
}

"ITA Apply Content, used to return ITA Apply Targeted Content"
type TargetedContentITAApplyDisplayData implements TargetedContentDisplayData {
    "Close Text sent by ITA"
    closeText: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Company Name sent by ITA"
    companyName: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Body in HTML sent by ITA"
    contentsInHtml: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Action Text sent by ITA"
    goText: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Header Image Url sent by ITA"
    headerImageUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Headline Text sent by ITA"
    headlineText: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Indeed UID, AD ID sent by ITA"
    itaId: ID! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Job Location sent by ITA, data formatted on ITA Side"
    jobFormattedLocation: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Job Title sent by ITA"
    jobTitle: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Action URL sent by ITA"
    landingUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Logo Image Url sent by ITA"
    logoImageUrl: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Ad close event tracking url sent by ITA."
    onCloseUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Ad visible event tracking url sent by ITA."
    onSeenUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Title sent by ITA"
    title: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
}

"ITA Apply Result, contains data for ITA Targeted Content"
type TargetedContentITAApplyResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentITAApplyDisplayData! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Updated ITA Client State"
    itaHistory: ITAHistoryClientState @deprecated(reason: "targeted-content-service no longer supports ITA")
}

"ITA Branded Content, used to return ITA Branded Targeted Content"
type TargetedContentITABrandedDisplayData implements TargetedContentDisplayData {
    "Body in HTML sent by ITA"
    contentsInHtml: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Action Text sent by ITA"
    goText: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Header Image Url sent by ITA"
    headerImageUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Headline Text sent by ITA"
    headlineText: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Indeed UID, AD ID sent by ITA"
    itaId: ID! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Third-party tracking pixel url sent by ITA."
    itaTrackingPixelUrl: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Job Location sent by ITA, data formatted on ITA Side"
    jobFormattedLocation: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Action URL sent by ITA"
    landingUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Logo Image Url sent by ITA"
    logoImageUrl: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Click tracking url sent by ITA. Fire this url when the ITAB ad is clicked."
    onClickUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    """

    Impression tracking url sent by ITA.
    Fire this url when the ITAB ad is fully displayed in the view for the first time.
    """
    onSeenUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Title sent by ITA"
    title: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
}

"ITA Branded Result, contains data for ITA Targeted Content"
type TargetedContentITABrandedResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentITABrandedDisplayData! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID! @deprecated(reason: "targeted-content-service no longer supports ITA")
}

"ITA Content, used to return Resume CTA Targeted Content"
type TargetedContentITADisplayData implements TargetedContentDisplayData {
    "Close Text sent by ITA"
    closeText: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Company Name sent by ITA"
    companyName: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Body in HTML sent by ITA"
    contentsInHtml: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Action Text sent by ITA"
    goText: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Header Image Url sent by ITA"
    headerImageUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Headline Text sent by ITA"
    headlineText: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Indeed UID, AD ID sent by ITA"
    itaId: ID! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Job Location sent by ITA, data formatted on ITA Side"
    jobFormattedLocation: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Job Title sent by ITA"
    jobTitle: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Action URL sent by ITA"
    landingUrl: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Logo Image Url sent by ITA"
    logoImageUrl: String @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Title sent by ITA"
    title: String! @deprecated(reason: "targeted-content-service no longer supports ITA")
}

"ITA Result, contains data for ITA Targeted Content"
type TargetedContentITAResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentITADisplayData! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID! @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Updated ITA Client State"
    itaHistory: ITAHistoryClientState @deprecated(reason: "targeted-content-service no longer supports ITA")
}

"Relevant Job Content, used to return Relevant Job Targeted Content"
type TargetedContentJobDisplayData implements TargetedContentDisplayData {
    "Content to render"
    contentsInHtml: String!
    "Text for the Go Action of the Targeted Content"
    goText: String!
    "Header Image Url: Indeed logo by default"
    headerImageUrl: String!
    "Job data results"
    jobData: [TargetedJobData!]
    "URL to use for the Go Action of the Targeted Content"
    landingUrl: String!
    "Content Title"
    title: String!
}

"Targeted Relevant Job Result, contains Job data from JobSearch API"
type TargetedContentJobResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentJobDisplayData!
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID!
}

"Job Search Content, used to return Job Search Targeted Content"
type TargetedContentJobSearchDisplayData implements TargetedContentDisplayData {
    "Content to render"
    contentsInHtml: String!
    "Text for the Go Action of the Targeted Content"
    goText: String!
    "Header Image Url: Indeed logo by default"
    headerImageUrl: String!
    "URL to use for the Go Action of the Targeted Content"
    landingUrl: String!
    "Content Title"
    title: String!
}

"Job Search Result, contains data for Job Search Targeted Content"
type TargetedContentJobSearchResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentJobSearchDisplayData!
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID!
}

"Resume CTA Content, used to return Resume CTA Targeted Content"
type TargetedContentResumeCTADisplayData implements TargetedContentDisplayData {
    "Content to render"
    contentsInHtml: String!
    "Text for the Go Action of the Targeted Content"
    goText: String!
    "Header Image Url: Indeed logo by default"
    headerImageUrl: String!
    "URL to use for the Go Action of the Targeted Content"
    landingUrl: String!
    "Content Title"
    title: String!
}

"Resume CTA Result, contains data for Resume CTA Targeted Content"
type TargetedContentResumeCTAResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentResumeCTADisplayData!
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID!
}

"Resume Review Content, used to return Resume Review Targeted Content"
type TargetedContentResumeReviewDisplayData implements TargetedContentDisplayData {
    "Content to render"
    contentsInHtml: String!
    "Text for the Go Action of the Targeted Content"
    goText: String!
    "Header Image Url: Indeed logo by default"
    headerImageUrl: String!
    "URL to use for the Go Action of the Targeted Content: CollectorID pa-client-name appended by default"
    landingUrl: String!
    "Content Title"
    title: String!
}

"Resume Review Result, contains data for Resume Review Targeted Content"
type TargetedContentResumeReviewResult implements TargetedContentResult {
    "Content to display"
    content: TargetedContentResumeReviewDisplayData!
    "Indeed UID, unique id per content that is being returned"
    contentTk: ID!
}

"Result of the Mutation request for the Content ID"
type TargetedContentUserInteractionResult {
    "Name of the custom field that will be logged in logrepo"
    contentTk: ID!
    "Type will be used to know how to treat and validate the value being passed"
    status: String!
}

type TargetedEmployerData {
    "Job-Seeker API's Employer type"
    employer: Employer!
}

type TargetedJobData {
    "URL to Indeed viewjob page"
    indeedViewJobUrl: String!
    "Job-Seeker API's Job type"
    job: Job!
    "Updated Relevant Job Client State"
    jobClickClientStates: [JobClickClientState]
    "Globally unique tracking key for this JobSearchResult sent by JobSearch API"
    trackingKey: ID!
}

"""

Taxonomy Concept.
Has 3 types now, ATTRIBUTE, OCCUPATION and COMPANY_SECTION.
"""
type TaxonomyConcept {
    "Alternative Labels of TaxonomyConcept."
    alternativeLabels: [String!]!
    "List of direct children of the TaxonomyConcept in the Taxonomy Tree."
    children: [TaxonomyConcept!]!
    "List of CustomClasses that this TaxonomyConcept belongs to."
    customClasses: [CustomTaxonomyClass!]!
    "Definitions of TaxonomyConcept."
    definitions: [String!]!
    """

    Indicates whether this TaxonomyConcept is a verified attribute for Job.
    This field should only be requested for ATTRIBUTE concept type.
    """
    isVerifiedJobAttribute: Boolean!
    """

    Indicates whether this TaxonomyConcept is a verified attribute for Resume.
    This field should only be requested for ATTRIBUTE concept type.
    """
    isVerifiedResumeAttribute: Boolean!
    """

    SUID(Short UID) of TaxonomyConcept.
    Used as the primary key.
    """
    key: ID!
    "Preferred label of TaxonomyConcept."
    label: String!
    "Return a path from the TaxonomyConcept itself to the root in the Taxonomy Tree."
    pathToRoot: [TaxonomyConcept!]!
    """

    Type of TaxonomyConcept.
    Consider removing this field if there is no obvious usage right now.
    """
    taxonomyConceptType: TaxonomyConceptType!
    """

    UUID of TaxonomyConcept.
    Will be finally replaced with SUID.
    """
    uuid: ID!
}

type TaxonomyConceptsPayload {
    responseStatus: MdsResponseStatus!
    "TaxonomyConepts details."
    taxonomyConcepts: [TaxonomyConcept!]
    "Unique transaction Id for the request used for debug and analysis usage."
    transactionId: ID!
}

type TimePunchNode implements Node {
    clientExternalId: String!
    comment: String!
    created: DateTime!
    id: ID!
    jobsiteExternalId: String!
    jobsiteTimezone: String
    lastModified: DateTime!
    lastModifyingUserId: String
    punchCode: String!
    punchIn: DateTime!
    punchOut: DateTime!
    shiftExternalId: String!
    slug: String!
    workerExternalId: ID
}

type TimePunchNodeConnection {
    edges: [TimePunchNodeEdge]!
    pageInfo: PageInfo!
}

type TimePunchNodeEdge {
    cursor: String!
    node: TimePunchNode
}

type Translation {
    locale: String!
    translatedText: String!
}

type UDPConfirmedParsedSection {
    "Resume sections that the jobseeker has confirmed as correctly parsed."
    confirmedSections: [String!]!
    "Resume id associated with resume sections that the jobseeker has confirmed as correctly parsed."
    resumeId: ID!
    "Deprecated: effectively same as resumeId, but deprecating due to bad naming convention."
    rezId: ID
}

type UDPSkippedQuestion {
    "Id of question skipped; sent by the client."
    questionId: ID!
    "UTC time, in milliseconds, when this request to save skipped question was received by the api."
    timestamp: Timestamp!
}

"Result Payload for the `unhighlight review` mutation"
type UnhighlightReviewPayload {
    highlightedReview: HighlightedReview
}

type UpdateAvailabilityResourcePayload {
    id: ID!
}

" Return type for updateCurrentLanguage "
type UpdateCurrentLanguagePayload {
    " Reference to company settings to use for subsequent calls "
    companySettings: CompanySettingsQueries
    " The new language to use.  It must be one of the available languages. "
    language: LanguageCode!
}

type UpdateDraftJobPostPayload {
    "The result."
    result: UpdateDraftJobPostResult!
}

type UpdateDraftJobPostResult {
    "The updated DraftJobPost."
    draftJobPost: DraftJobPost!
}

"Output result for updateDraftVerificationInfo"
type UpdateDraftVerificationInfoPayload {
    "Whether or not the transaction succeeded"
    results: Boolean!
}

type UpdateHostedEmployerPayload {
    "The update result."
    result: UpdateHostedEmployerResult!
}

type UpdateHostedEmployerResult {
    "The updated Hosted Employer."
    hostedEmployer: HostedEmployer!
}

type UpdateHostedJobPostResult {
    "The updated HostedJobPost."
    hostedJobPost: HostedJobPost!
}

"Payload that includes the profile of the jobseeker"
type UpdateJobSeekerProfilePayload {
    profile: JobSeekerProfile
}

"Payload that includes awards that were updated"
type UpdateJobSeekerProfileResumeAwardsPayload {
    awards: [JobSeekerProfileAward!]!
}

"Payload that includes the certifications that are updated"
type UpdateJobSeekerProfileResumeCertificationsPayload {
    certifications: [JobSeekerProfileCertification!]!
}

"Payload that includes the educations that are updated"
type UpdateJobSeekerProfileResumeEducationsPayload {
    educations: [JobSeekerProfileEducation!]!
}

"Payload that includes the language skills that are updated"
type UpdateJobSeekerProfileResumeLanguageSkillsPayload {
    languageSkills: [JobSeekerProfileLanguageSkill!]!
}

type UpdateJobSeekerProfileResumeLinksPayload {
    links: [JobSeekerProfileLink!]!
}

type UpdateJobSeekerProfileResumeMilitaryPayload {
    military: [JobSeekerProfileMilitary!]!
}

type UpdateJobSeekerProfileResumePayload {
    resume: JobSeekerProfileResume
}

"Payload that includes the skills that are updated"
type UpdateJobSeekerProfileResumeSkillsPayload {
    skills: [JobSeekerProfileSkill!]!
}

"Payload that includes work experiences that were updated"
type UpdateJobSeekerProfileResumeWorkExperiencesPayload {
    workExperiences: [JobSeekerProfileWorkExperience!]!
}

type UpdateJobSeekerProfileStructuredDataPreferencePayload {
    "Preference."
    preference: JobSeekerProfileStructuredDataPreference
}

" Return type for updateMonthlyBudgetAlerts "
type UpdateMonthlyBudgetAlertsPayload {
    " Reference to company settings to use for subsequent calls "
    companySettings: CompanySettingsQueries
    " Flag for whether or not monthly budget alerts have been enabled "
    monthlyBudgetAlertsEnabled: Boolean!
}

" Return type for updateProminentOptIn "
type UpdateProminentOptInPayload {
    " Reference to company settings to use for subsequent calls "
    companySettings: CompanySettingsQueries
    " New strategy being used "
    prominentOptInEnabled: Boolean!
}

"Result payload for the `updateReviewComment` mutation"
type UpdateReviewCommentPayload {
    "Available details of the updated comment, including its ID"
    comment: ReviewComment!
}

type UpdateSavedJobStatePayload {
    "The job after the update. If the update fails, this will add an error to the errors list."
    savedJob: SavedJob!
}

"""

Payload that includes:
1. file information for file that was just uploaded.
(similar to file metadata returned by Profile API).
2. resume data extracted from parsing resume file
"""
type UploadJobSeekerProfileFilePayload {
    resume: JobSeekerProfileResume
    uploadedFileInformation: JobSeekerProfileFile
}

"The details for an individual uploaded document"
type UploadedDocumentStatusInfo {
    "The document ID"
    id: String!
    "The original name of the file from the user"
    originalFileName: String!
}

type UpsertAppointmentPayload {
    id: CalendarEventId!
}

type UserCalendar implements AvailabilityResource & Node {
    availabilitySettings: ResourceAvailabilitySettings!
    available(after: String, availabilityWindow: AvailabilityWindowFilter, endTime: DateTime, eventUuid: String, first: Int, outputFormat: AvailabilitySlotFormat = CONSISTENT_SLOTS, requiredDuration: Duration!, startInterval: StartInterval, startTime: DateTime, timeZone: ZoneID): AvailabilitySlotConnection!
    "External calendars that are connected to this calendar."
    connectedCalendars: ConnectedCalendars!
    id: ID!
}

"Response from the [userCalendar] query to retrieve an availability resource of type [UserCalendar]."
type UserCalendarPayload {
    "User Calendar that was retrieved."
    result: UserCalendar!
}

type UserDisplayPreferenceMutationsPayload {
    "Adds a new high level userDisplayPreference document based on input received."
    addUserDisplayPreference(input: AddUserDisplayPreferenceInput!): AddUserDisplayPreferencePayload
    "Mutation Namespace for confirmed parsed section mutations."
    confirmedSectionMutations: ConfirmedParsedSectionsMutations!
    "Removes the high level userDisplayPreference document that has matching accountId."
    removeUserDisplayPreference(input: RemoveUserDisplayPreferenceInput!): RemoveUserDisplayPreferencePayload
    "Mutation Namespace for skipped question mutations."
    skippedQuestionMutations: SkippedQuestionMutations!
}

type UserDisplayPreferencePayload {
    "Jobseeker Account Id."
    accountId: Int!
    "List of parsed resume sections that jobseeker has confirmed as correct."
    confirmedParsedSections: UDPConfirmedParsedSection
    "List of microcontent questions jobseeker has skipped."
    skippedQuestions: [UDPSkippedQuestion!]!
}

"Output for signedUploadUrl"
type VerificationDocumentUploadUrlsPayload {
    "The presigned url information"
    results: PresignedUrlResult!
}

"Data for VerificationInfo, used as results in draftVerificationInfo for draftVerificationInfo"
type VerificationInfo {
    "Company phone number"
    companyPhoneNumber: String
    "Timestamp of when the draft verification info was created"
    createdTimestampSeconds: Int!
    "A list of available presigned document URLs"
    documents: [UploadedDocumentStatusInfo!]!
    "Company headquarters mailing address"
    headquartersMailingAddress: Address
    "The user's personal name"
    name: Name
}

"Output for verificationStatus"
type VerificationStatusPayload {
    "The verification status of the given advertiser"
    results: VerificationStatus!
}

"Rule that defines a repeating availability period for a specific day of the week."
type WeekAvailabilityRule {
    "Day of the week that this rule applies to."
    dayOfWeek: DayOfWeek!
    """

    End time of the availability.

    The value ranges from 00:00-24:00, where 00:00 represents the beginning of the day and
    24:00 represents the end of the day.

    Value is greater than [startTime]. Resolution is 1 minute.
    """
    endTime: Time!
    """

    Start time of the availability.

    The value ranges from 00:00-24:00, where 00:00 represents the beginning of the day and
    24:00 represents the end of the day.

    Resolution is 1 minute.
    """
    startTime: Time!
}

"Repeating availability rules that apply to days of the week."
type WeekAvailabilityRules {
    """

    Week day rule definitions.

    The time periods do not overlap and are not empty.

    The periods may be consecutive.
    For example: rule1=Monday, 10:00-11:00; rule2=Monday, 11:00-12:00
    """
    rules: [WeekAvailabilityRule!]!
    "Time zone to interpret the availability rules with."
    timezone: ZoneID!
}

type YelpAmbience {
    casual: Boolean
    classy: Boolean
    divey: Boolean
    hipster: Boolean
    intimate: Boolean
    romantic: Boolean
    touristy: Boolean
    trendy: Boolean
    upscale: Boolean
}

type YelpAttributes {
    alcohol: String
    ambience: YelpAmbience
    delivery: Boolean
    menuUrl: WebUrl
    noiseLevel: String
    priceRange: Int
    takeout: Boolean
}

type YelpBusinessCoordinates {
    latitude: Float
    longitude: Float
}

type YelpBusinessData {
    alias: String!
    attributes: YelpAttributes
    hours: [YelpBusinessHours!]!
    id: ID!
    isClosed: Boolean
    name: String!
    yelpUrl: WebUrl!
}

type YelpBusinessHours {
    close: Time
    day: String
    open: Time
}

type YesNoCount {
    noCount: Int!
    yesCount: Int!
}

"The location type on which the Indeed Apply form will be rendered."
enum ApplyDomainProperty {
    INDEED
    THIRD_PARTY
}

" Reasons that user wishes to attach a new candidate resume to an email notification "
enum AttachResumeUsageReason {
    " Resumes are used in another tool or ATS "
    IN_ANOTHER_TOOL_OR_ATS
    " Resumes are used in another way "
    OTHER_NOT_LISTED
}

enum AvailabilitySlotFormat {
    "Generate non-overlapping slots with length equal to the requiredDuration that won't change over time."
    CONSISTENT_SLOTS
    "Generate contiguous available periods that are a minimum length of the requiredDuration."
    PERIODS
}

"An enumeration of [ISO-4217](https://www.iso.org/iso-4217-currency-codes.html) 3-letter currency codes."
enum BillingCurrencyCode {
    AUD
    BRL
    CAD
    CHF
    EUR
    GBP
    INR
    JPY
    MXN
    SGD
    UNKNOWN_CURRENCY_CODE
    USD
}

enum CandidateSentiment {
    MAYBE
    NEGATIVE
    POSITIVE
    UNKNOWN_CANDIDATE_SENTIMENT
}

enum CandidateStatus {
    HIRED
    INTERVIEWING
    NEW
    REJECTED
    REVIEWED
    UNKNOWN_CANDIDATE_STATUS
}

"Types of external calendar services."
enum ConnectedCalendarProviderType {
    "Apple iCloud."
    APPLE
    "Microsoft Exchange."
    EXCHANGE
    "Google."
    GOOGLE
    "Microsoft Windows Live."
    LIVE_CONNECT
    """

    The underlying calendar provider is currently unknown to the availability service.

    This is not a value that will normally be returned by the availability service. It will only
    be returned if the type of calendar provider is new to the service in that it has not yet
    been added as an entry in the enum.
    """
    UNKNOWN
}

enum ContactMethod {
    EMAIL
    PHONE
    UNKNOWN_CONTACT_METHOD
}

"Reason job is not for eligible"
enum CpoIneligibilityReason {
    NOT_IN_TEST_POPULATION
    NO_ELIGIBLE_RECOMMENDATIONS_FOUND
}

enum CustomClassFilterOperation {
    AND
    OR
}

"Sorting fields"
enum DateSortField {
    DATE_CREATED
}

"The days of the week! As an enum!"
enum DayOfWeek {
    FRIDAY
    MONDAY
    SATURDAY
    SUNDAY
    THURSDAY
    TUESDAY
    WEDNESDAY
}

enum DeviceType {
    DESKTOP
    MOBILE
    UNKNOWN
}

"Ordering fields"
enum DraftJobPostsSortField {
    DATE_CREATED
    JOB_ADDRESS
    TITLE
}

enum EmployerTier {
    "This is an enterprise company, being granted all things enterprise-y"
    ENTERPRISE
    "The company is in the free tier"
    FREE
    "The company with no specific tier"
    UNSPECIFIED
}

enum EstimationJobSalaryPeriod {
    DAY
    HOUR
    MILE
    MONTH
    WEEK
    YEAR
}

enum FieldSource {
    EXTERNAL_ATS
    INDEED_ATS
}

"Specifies whether a sort key should sort results in an \"ascending\" or \"descending\" direction."
enum FindEmployerJobsSortDirection {
    "An ascending sort -- from the lowest value to highest value."
    ASC
    "A descending sort -- from the highest value to the lowest value."
    DESC
}

"Matched type of search term"
enum FindEmployersWhatType {
    EMPLOYER_NAME
    JOB_CATEGORY
    JOB_TITLE
}

"Matched type of location term"
enum FindEmployersWhereType {
    ADMIN1
    ADMIN2
    ADMIN3
    ADMIN4
    CITY
    COUNTRY
}

enum Granularity {
    DAY
    MONTH
    NULL
    QUARTER
    WEEK
    YEAR
}

"Represents the interpreted grade or level of happiness."
enum HappinessGrade {
    EXCELLENT
    FAIR
    GOOD
    GREAT
    POOR
}

enum HiringEventClientIntakeType {
    INDEED_INTERVIEW
    INTERVIEW_CAMPAIGN
    IN_PERSON
    NONE @deprecated(reason: "Only used for legacy client intakes.")
    PHONE
    VIRTUAL
}

enum HiringEventCurrency {
    AUD
    CAD
    EUR
    GBP
    INR
    JPY
    USD
}

enum HiringEventEnhancedScreeningRejectedReasonCode {
    EVENT_CANCELLED
    EVENT_EXPIRED
}

enum HiringEventGenericPerk {
    COMPANY_SWAG
    COUPONS_OR_VOUCHERS
    SNACKS_AND_REFRESHMENTS
}

enum HiringEventRsvpRejectedReasonCode {
    EVENT_CANCELLED
    EVENT_EXPIRED
    SCREENING_REJECTED
}

enum HiringEventRsvpStatus {
    CANCELLED_BY_CANDIDATE
    CANCELLED_BY_EMPLOYER
    CANCELLED_BY_JOBSEEKER
    COMPLETED
    SCHEDULED
    UNDEFINED
}

enum HiringEventScreeningAnswerValue {
    NO
    YES
}

enum HiringEventStatus {
    ACTIVE
    CANCELLED
    COMPLETE
    PENDING
    SCHEDULED
}

enum HostedEmployerAttributesPatchSetOperationType {
    ADD
}

"An enumeration of an employer's possible billing states."
enum HostedEmployerBillingState {
    AWAITING_AUTHORIZATION
    BILLING_APPROVED
    BILLING_DISABLED
}

"An enumeration of company's employee counts."
enum HostedEmployerEmployeeCount {
    EMPLOYEE_1000_MORE
    EMPLOYEE_150_249
    EMPLOYEE_1_49
    EMPLOYEE_250_499
    EMPLOYEE_500_749
    EMPLOYEE_50_149
    EMPLOYEE_750_999
    EMPLOYEE_NULL
}

"An enumeration of industry types."
enum HostedEmployerIndustry {
    ACCOUNTING_CONSULTING
    ADVERTISING_MARKETING
    AGRICULTURE
    ARTS_ENTERTAINMENT_RECREATION
    AUTOMOTIVE
    BEAUTY_WELLNESS
    CONSTRUCTION_ENGINEERING
    DEFENSE_SECURITY
    EDUCATION
    ENERGY_UTILITIES
    FINANCIAL_SERVICES_BANKING
    FOOD_BEVERAGE_SERVICES
    FRAUD_SCAM
    GOVERNMENT_MILITARY
    HEALTH_CARE_MEDICAL
    HOSPITALITY
    INSURANCE
    JOB_BOARD_GENERAL
    JOB_SEEKER
    LEGAL
    MANUFACTURING
    MEDIA_NEWSPAPER
    NON_PROFIT_ASSOCIATION
    OTHER
    REAL_ESTATE
    RETAIL_CONSUMER_PRODUCTS
    SPAM
    STAFFING_FIRM_GENERAL
    TECHNOLOGY_INFORMATION
    TELECOM
    TRANSPORTATION_LOGISTICS
    UNASSIGNED
    WORK_AT_HOME
    XO_S_JS
}

"An enumeration of an employer's possible payment methods."
enum HostedEmployerPaymentMethod {
    CREDITS
    MANUAL
    POSTPAY_CC
    POSTPAY_INVOICE
    POSTPAY_IO
    PREPAY_INVOICE
}

"An enumeration of employer types."
enum HostedEmployerType {
    DIRECT_EMPLOYER
    JOB_BOARD
    NONE
    OTHER
    SANDBOX
    STAFFING_AGENCY
    TEST
}

"Hosted Job campaign type"
enum HostedJobPostCampaignType {
    FREE
    SPONSORED
}

enum HostedJobPostExcludeOption {
    APPEAL
}

enum HostedJobPostStatus {
    ACTIVE
    DELETED
    PAUSED
}

enum HostedJobPostVisibility {
    HIDDEN
    "Available in job search results"
    ORGANIC
    "Requires sponsorship to be visible in job search results"
    SPONSORED_ONLY
    UNKNOWN
    UNRESTRICTED
}

"Ordering fields"
enum HostedJobPostsSortField {
    ADVERTISING_LOCATION
    DATE_CREATED
    TITLE
}

enum IhpAdvertiserSubscriptionStatus {
    ACTIVE
    DISABLED
}

enum IhpHostedStatus {
    EXTERNAL
    HOSTED
}

enum IhpRecommendedJobSortByOption {
    RECOMMENDED_JOB_SCORE
}

enum InterviewDifficulty {
    EASY
    HARD
    INSUFFICIENT_DATA
    MEDIUM
}

enum InterviewExperience {
    AVERAGE
    EXCELLENT
    INSUFFICIENT_DATA
    POOR
}

enum InterviewProcessLength {
    A_DAY_OR_TWO
    A_MONTH
    A_WEEK
    INSUFFICIENT_DATA
    MORE_THAN_ONE_MONTH
    TWO_WEEKS
}

"  members to be used in building filters for measures "
enum JobCampaignMeasureFilterMember {
    AVG_ACR
    AVG_ASR
    AVG_CPA
    AVG_CPAS
    AVG_CPC
    AVG_CTR
    SUM_APPLIES
    SUM_APPLY_STARTS
    SUM_CLICKS
    SUM_COST_LOCAL
    SUM_IMPRESSIONS
}

"Scope in which Indeed Apply is supported."
enum JobIndeedApplyScope {
    "Indeed Apply is available for desktop platforms"
    DESKTOP
    "Indeed Apply is available for mobile platforms"
    MOBILE
}

enum JobPostCampaignType {
    FREE
    SPONSORED
}

enum JobPostOrigin {
    CLAIMED
    HOSTED
    UNCLAIMED
}

enum JobPricingModel {
    PPC
}

enum JobRequirement {
    NO
    OPTIONAL
    YES
}

enum JobSalaryPeriod {
    DAY
    HOUR
    MILE
    MONTH
    WEEK
    YEAR
}

enum JobSearchDistanceUnit {
    KILOMETERS
    MILES
}

enum JobSearchIncludeSponsoredResults {
    """

    Request returning only sponsored jobs.

    **Caveat**: This value is trying the best effort to return only sponsored jobs. Results could possibly contain
    organic jobs. Clients must be able to handle organic jobs in the results.
    """
    ALL
    "Return a mix of organic and sponsored jobs in the results."
    MIXED
    "Do not return any sponsored job."
    NONE
}

enum JobSearchKeywordFilterMatch {
    MUST
    MUST_NOT
}

enum JobSearchKeywordFilterOperation {
    AND
    OR
}

enum JobSearchResultGroupByRelation {
    """

    Group by employer and location and count unique titles.
    Other differences, such as shift, are ignored.
    """
    EMPLOYER_LOCATION
    """

    Group by employer and title and count unique locations.
    Other differences, such as shift, are ignored.
    """
    EMPLOYER_TITLE
    """

    Disable grouping.
    For jobSearch typically used when setting `grouping.key` to show all job positions regardless of unique company, location, and title.
    """
    NONE
}

enum JobSearchSortOrder {
    """

    Most recently published jobs first. When a single search result contains jobs with equivalent publish dates (see
    datePublished) these jobs are sorted by relevance.

    Sorting by relevance takes effect when jobs are
    - less than or equal to 6 hours : are considered equal
    - less than 1 day               : are sorted by 6 hour buckets
    - greater than 1 week           : are sorted by day
    """
    DATE
    "Most relevant jobs based on search criteria and user personalization"
    RELEVANCE
}

"Type of file uploaded to Job Seeker's profile (like a resume)"
enum JobSeekerProfileFileType {
    COVER_LETTER
    RESUME
    RESUME_CONVERTED
}

"A location geocode precision for example COUNTRY, CITY."
enum JobSeekerProfileGeocodePrecision {
    ADDRESS
    ADMIN1
    ADMIN2
    ADMIN3
    ADMIN4
    CITY
    COUNTRY
    POSTAL
}

"Citizenship type of this job seeker"
enum JobSeekerProfileInternationalCitizenship {
    CITIZEN
    FILIPINO
    NONE_OF_THE_ABOVE
    NON_FILIPINO
    NOT_CITIZEN_NO_WORK_PERMIT
    NOT_CITIZEN_WITH_WORK_PERMIT
    SG_NATIONAL
    SG_PERMANENT_RESIDENT
}

"Types of disabilities this job seeker wants to include in their resume"
enum JobSeekerProfileInternationalDisability {
    COGNITIVE
    MULTIPLE
    NO
    OTHER
    PHYSICAL
    SPEECH
    VISION
    YES
}

"A job seeker's driver's license listed in their resume"
enum JobSeekerProfileInternationalDriversLicense {
    A
    A1
    A2
    ADR
    ADR_CISTERNAS
    ADR_EXPLOSIVOS
    ADR_RADIOACTIVAS
    AGRICULTURE_VEHICLES
    AM
    B
    B1
    BE
    BUSES
    B_AUTO
    B_PLUS_E
    C
    C1
    C1E
    C1_PLUS_E
    CAP
    CARGO_OR_TRUCKS
    CARS
    CE
    CFP
    CQC
    C_PLUS_E
    D
    D1
    D1E
    D1_PLUS_E
    DE
    D_PLUS_E
    E
    F
    G
    H
    INDUSTRIAL_VEHICLES
    INTERNATIONAL_DRIVERS_LICENSE
    K
    LARGE_VEHICLES
    LCM
    LIGHT_VEHICLES
    LVA
    MEDIUM_VEHICLES
    MINIBUSES
    MOPEDS
    MOTORCYCLES
    NO
    NONE
    OTHER
    P
    Q
    REGULAR_DRIVERS_LICENSE
    T
    TB
    TM
    Truckkort
    YES
}

"Describes the eligibility for employment of this job seeker"
enum JobSeekerProfileInternationalEmploymentEligibility {
    NO
    YES
}

"A list of country codes used to denote employment eligibility"
enum JobSeekerProfileInternationalEmploymentEligibilityMultiCountries {
    AD
    AE
    AF
    AG
    AI
    AL
    AM
    AN
    AO
    AQ
    AR
    AS
    AT
    AU
    AW
    AX
    AZ
    BA
    BB
    BD
    BE
    BF
    BG
    BH
    BI
    BJ
    BL
    BM
    BN
    BO
    BQ
    BR
    BS
    BT
    BV
    BW
    BY
    BZ
    CA
    CC
    CD
    CF
    CG
    CH
    CI
    CK
    CL
    CM
    CN
    CO
    CR
    CU
    CV
    CW
    CX
    CY
    CZ
    DE
    DJ
    DK
    DM
    DO
    DZ
    EC
    EE
    EG
    EH
    ER
    ES
    ET
    FI
    FJ
    FK
    FM
    FO
    FR
    GA
    GB
    GD
    GE
    GF
    GG
    GH
    GI
    GL
    GM
    GN
    GP
    GQ
    GR
    GS
    GT
    GU
    GW
    GY
    HK
    HM
    HN
    HR
    HT
    HU
    ID
    IE
    IL
    IM
    IN
    IO
    IQ
    IR
    IS
    IT
    JE
    JM
    JO
    JP
    KE
    KG
    KH
    KI
    KM
    KN
    KP
    KR
    KW
    KY
    KZ
    LA
    LB
    LC
    LI
    LK
    LR
    LS
    LT
    LU
    LV
    LY
    MA
    MC
    MD
    ME
    MF
    MG
    MH
    MK
    ML
    MM
    MN
    MO
    MP
    MQ
    MR
    MS
    MT
    MU
    MV
    MW
    MX
    MY
    MZ
    NA
    NC
    NE
    NF
    NG
    NI
    NL
    NO
    NP
    NR
    NU
    NZ
    OM
    PA
    PE
    PF
    PG
    PH
    PK
    PL
    PM
    PN
    PR
    PS
    PT
    PW
    PY
    QA
    RE
    RO
    RS
    RU
    RW
    SA
    SB
    SC
    SD
    SE
    SG
    SH
    SI
    SJ
    SK
    SL
    SM
    SN
    SO
    SR
    SS
    ST
    SV
    SX
    SY
    SZ
    TC
    TD
    TF
    TG
    TH
    TJ
    TK
    TL
    TM
    TN
    TO
    TR
    TT
    TV
    TW
    TZ
    UA
    UG
    UM
    US
    UY
    UZ
    VA
    VC
    VE
    VG
    VI
    VN
    VU
    WF
    WS
    YE
    YT
    ZA
    ZM
    ZW
}

"Employment status of a job seeker listed in their resume"
enum JobSeekerProfileInternationalEmploymentStatus {
    NO
    YES
}

"Employment support status of a job seeker listed in their resume"
enum JobSeekerProfileInternationalEmploymentSupportStatus {
    APPLICABLE
    NOT_APPLICABLE
}

"Ethnicity of the job seeker included in the resume"
enum JobSeekerProfileInternationalEthnicity {
    AFRICAN
    ASIAN
    COLOURED
    INDIAN
    WHITE
}

enum JobSeekerProfileInternationalEuropeanUnionWorkPermit {
    NO
    YES
}

"Gender of the job seeker listed in their resume"
enum JobSeekerProfileInternationalGender {
    FEMALE
    MALE
    NONE
}

"Highest career level of a job seeker listed in their resume"
enum JobSeekerProfileInternationalHighestCareerLevel {
    EXECUTIVE
    EXPERIENCED
    NEW_GRAD
    NO_EXPERIENCE
    STUDENT
}

"A job seeker's highest level of education listed in their resume"
enum JobSeekerProfileInternationalHighestLevelOfEducation {
    EIGHT
    EIGHTEEN
    ELEVEN
    FIFTEEN
    FIVE
    FOUR
    FOURTEEN
    NINE
    NINETEEN
    SEVEN
    SEVENTEEN
    SIX
    SIXTEEN
    TEN
    THIRTEEN
    TWELVE
    TWENTY
    TWENTY_FIVE
    TWENTY_FOUR
    TWENTY_ONE
    TWENTY_SEVEN
    TWENTY_SIX
    TWENTY_THREE
    TWENTY_TWO
    ZERO
}

"A job seeker's industry listed in their resume"
enum JobSeekerProfileInternationalIndustry {
    ACCOUNTING
    ADMINISTRATIVE_ASSISTANCE
    ADVERTISING_PR_MR_EVENT_MANAGEMENT
    AEROSPACE_AND_AVIATION
    AGRICULTURE_AND_FORESTRY
    ANALYTICS
    ARCHITECTURE
    ARCHITECTURE_INTERIOR_DESIGN
    ARTS_AND_ENTERTAINMENT
    AUTOMOBILE_AUTO_ANCILIARY
    AUTOMOTIVE
    BANKING_AND_FINANCE
    BEAUTY_AND_WELLNESS
    BUSINESS_OPERATIONS
    CALL_CENTER
    CHEMICAL_ENGINEERING
    CHILDCARE
    CIVIL_ENGINEERING
    CLEANING_AND_SANITATION
    COMMUNITY_AND_SOCIAL_SERVICE
    CONSTRUCTION
    CUSTOMER_SERVICE
    DENTAL
    EDUCATION_AND_INSTRUCTION
    ELECTRICAL_ENGINEERING
    EXPORT_IMPORT
    FOOD_PREPARATION_AND_SERVICE
    GOVERNMENT_DEFENCE
    HEALTHCARE
    HOSPITALITY_AND_TOURISM
    HUMAN_RESOURCES
    INDUSTRIAL_ENGINEERING
    INFORMATION_DESIGN_AND_DOCUMENTATION
    INSTALLATION_AND_MAINTENANCE
    INSURANCE
    INTERNET_ECOMMERCE
    IT_HARDWARE_AND_NETWORKING
    IT_OPERATIONS_AND_HELPDESK
    KPO_RESEARCH_ANALYTICS
    LABORATORY
    LEGAL
    LIBRARY
    LOADING_AND_STOCKING
    LOGISTIC_SUPPORT
    MANAGEMENT
    MARKETING
    MATHEMATICS
    MECHANICAL_ENGINEERING
    MEDIA_AND_COMMUNICATIONS
    MEDICAL_INFORMATION
    MEDICAL_TECHNICIAN
    MEDICAL_THERAPY
    MILITAIRE
    MINING_AND_OIL
    NGO_SOCIAL_SERVICES_REGULATORS_INDUSTRY_ASSOCIATIONS
    NURSING
    OIL_AND_GAS_ENERGY_POWER_INFRASTRUCTURE
    OTHER
    PERSONAL_CARE_AND_HOME_HEALTH
    PHARMACY
    PHYSICIANS_AND_SURGEONS
    PHYSICIAN_ASSISTANTS
    PRODUCTION_AND_MANUFACTURING
    PROJECT_MANAGEMENT
    PUBLISHING
    QUALITY_ASSURANCE
    REAL_ESTATE
    RETAIL
    SALES
    SCIENTIFIC_RESEARCH_AND_DEVELOPMENT
    SECURITY_AND_PUBLIC_SAFETY
    SOCIAL_SCIENCE
    SOFTWARE_DEVELOPMENT
    SPORTS
    STRATEGY_MANAGEMENT_CONSULTING_FIRMS
    TECHNOLOGY
    TRANSPORTATION_SERVICES
    TRAVEL_AIRLINES_RAILWAYS
    TYRES
    VETERINARY
    WATER_TREATMENT_WASTE_MANAGEMENT
}

"National Youths Service Corps (NYSC) status of a job seeker listed in their resume"
enum JobSeekerProfileInternationalNYSCStatus {
    COMPLETED
    NOT_APPLICABLE
    ONGOING
}

"Veteran status of a job seeker listed in their resume"
enum JobSeekerProfileInternationalVeteranStatus {
    APPLICABLE
    NOT_APPLICABLE
}

"Describes if the job seeker is willing to travel for a job"
enum JobSeekerProfileInternationalWillingToTravel {
    DEPENDS_ON_OPPORTUNITY
    NO
    YES
}

"Month type, e.g. JANUARY. Month type of NOT_SPECIFIED is used to update month to null."
enum JobSeekerProfileMonthType {
    APRIL
    AUGUST
    DECEMBER
    FEBRUARY
    JANUARY
    JULY
    JUNE
    MARCH
    MAY
    NOT_SPECIFIED
    NOVEMBER
    OCTOBER
    SEPTEMBER
}

"A Job Seeker's resume career level, for example EXPERIENCED."
enum JobSeekerProfileResumeCareerLevel {
    EXPERIENCED
    FRESHER
    NOT_SPECIFIED
}

"A Job Seeker's resume source, for example DOCUMENT_UPLOAD or INDEED_APPLY."
enum JobSeekerProfileResumeSource {
    BASIC_PROFILE_ONLY
    BASIC_PROFILE_UPLOAD
    BLANK_TEMPLATE
    DOCUMENT_UPLOAD
    DROPBOX_UPLOAD
    DUPLICATE
    FACEBOOK_PROFILE
    GOOGLE_DOC
    INDEED_APPLY
    LINKEDIN_PROFILE
    MESSAGING_APP
    MICRO_CONTENT
    MICRO_CONTENT_CAROUSEL
    MICRO_CONTENT_JP
    NATIVE_CREATE
    NATIVE_UPLOAD
    OWAIN
    UNIVERSAL_RESUME
    UNKNOWN
}

"A Job Seeker's resume state, for example PUBLIC or HIDDEN."
enum JobSeekerProfileResumeState {
    DELETED
    HIDDEN
    PUBLIC
}

"A Job Seeker's resume type, for example INDEED_RESUME or PARSED_RESUME."
enum JobSeekerProfileResumeType {
    GLASSDOOR
    INDEED_RESUME
    PARSED
    SIMPLYHIRED
}

enum JobSeekerProfileStructuredDataDataCategory {
    CONFIRMED_BY_USER
    EXTRACTED_FROM_RESUME
    INFERRED_FROM_USER_ACTIVITY
}

enum JobSeekerProfileStructuredDataJobTypeEnum {
    APPRENTICESHIP
    CASUAL
    COMMISSION
    CONTRACT
    CUSTOM_1
    FLYIN_FLYOUT
    FULLTIME
    INTERNSHIP
    NEW_GRAD
    NONPROFIT
    PARTTIME
    PERMANENT
    RECRUITER
    SPAM
    SUBCONTRACT
    TELECOMMUTE
    TEMPORARY
    VOLUNTEER
}

enum JobSeekerProfileStructuredDataLatLngPrecision {
    ADMIN1
    ADMIN2
    ADMIN3
    ADMIN4
    CITY
    COUNTRY
    PLACE
    STATION
    UNKNOWN
    ZIPCODE
}

enum JobSeekerProfileStructuredDataSalaryType {
    BIWEEKLY
    DAILY
    HOURLY
    MONTHLY
    WEEKLY
    YEARLY
}

"Enumerations"
enum JobSeekerProfileStructuredDataSentiment {
    NEGATIVE
    POSITIVE
}

"Time unit like Years, Months."
enum JobSeekerProfileTypeUnit {
    Days
    Months
    Weeks
    Years
}

enum JobSourceType {
    AGGREGATOR
    EMPLOYER
    JOB_BOARD
    RECRUITER
}

enum JobType {
    APPRENTICESHIP
    CASUAL
    COMMISSION
    CONTRACT
    CUSTOM_1 @deprecated(reason: "Unsupported")
    FLYIN_FLYOUT
    FULL_TIME
    INTERNSHIP
    NEW_GRAD
    NONPROFIT @deprecated(reason: "Unsupported")
    OTHER @deprecated(reason: "Unsupported")
    PART_TIME
    PERMANENT
    RECRUITER
    SPAM @deprecated(reason: "Unsupported")
    SUBCONTRACT
    TELECOMMUTE @deprecated(reason: "Unsupported")
    TEMPORARY
    VOLUNTEER
}

enum JobUpdateEventType {
    DELETED
    NEW
    UPDATED
}

enum JobUpdateStatus {
    ACTIVE
    INACTIVE
}

enum JostPostApplyMethodType {
    EMAIL
    IN_PERSON
    WEBSITE
}

"Standard GraphQL error code described in https://wiki.indeed.com/display/Microservices/API+Recommendations#APIRecommendations-229"
enum MdsResponseCode {
    """

    The value of an input parameter is invalid.
    This error code applies to input validation performed beyond the standard
    GraphQL client and server libraries Non-Null and type checking.
    """
    BAD_USER_INPUT
    """

    Valid authentication credentials are present but insufficient to perform the associated operation.
    This error code is the GraphQL equivalent of the HTTP response status 403 Forbidden.
    """
    FORBIDDEN
    """

    The server encountered an unexpected failure and did not provide a response.
    Use this generic error only for failures that the server cannot handle.
    """
    INTERNAL_SERVER_ERROR
    OK
    """

    It's partial-success if the response contains only part of successful response
    because of some failures.
    """
    PARTIAL_SUCCESS
    "The query exceeded the allowed complexity for a single request."
    QUERY_TOO_COMPLEX
    """

    The operation was not attempted because the request did not
    include sufficient authentication credentials for the operation.
    This error code is the GraphQL equivalent of the HTTP response status 401 Unauthorized.
    """
    UNAUTHENTICATED
}

" Operators to be used in building filters for measures "
enum MeasureFilterOperator {
    EQ
    GT
    GTE
    LT
    LTE
    NE
}

enum MinimumGranularity {
    ADMIN1
    ADMIN2
    ADMIN3
    ADMIN4
    CITY
    COUNTRY
}

enum MosaicOptOutTrackingKeyType {
    HOMEPAGE
}

enum OffsiteDeviceIdEnum {
    AAID
    IDFA
}

enum OptimizationType {
    ADD_COMPANY_DESCRIPTION
    GENDER_DECODER
    SALARY_OPT
    TITLE_NORM
}

" Order for response according to specific measure "
enum OrderDirection {
    ASC
    DESC
}

enum PatchSetOperationType {
    ADD
    REMOVE
}

enum PunchCode {
    BERV
    HOLS
    JURY
    REG
    SICK
    TIMEOFF
    TRAIN
}

enum RecommendationFilter {
    ALL
    BEST_PRACTICE
    DISMISSED
    JOB_QUALITY
    TOP_PERFORMERS
    UNDER_PERFORMERS
    UNUSUAL_ACTIVITY
}

enum RecommendationTargetType {
    ADVERTISER
    CAMPAIGN
    JOB
}

enum RecommendationType {
    CLICKS_ENABLE_BALANCING
    CONVERSION_HIGH
    CONVERSION_LOW
    CPA_SUDDEN_DECREASE
    CPC_SUDDEN_DECREASE
    INDEED_APPLY_ENABLE
    NON_IA_SAS_HIGH
    NON_IA_SAS_LOW
    OBJECTIVE_NON_GENERIC
    SPONSORED_ONLY_JOBS_NOT_SPONSORED
}

"Reviews support set of sort types. This enum contains their ids"
enum ReviewSortType {
    "Sort by character length of all text fields: `text`, `title`, `pros`, `cons`"
    BODY_LENGTH
    "Sort by `compensationAndBenefitsRating` field"
    COMPENSATION_AND_BENEFITS_RATING
    "Sort by `cultureAndValuesRating` field"
    CULTURE_AND_VALUES_RATING
    "Sort by `helpfulCount` field (Number of users who voted review as helpful)"
    HELPFULNESS
    "Sort by `jobSecurityAndAdvancementRating` field"
    JOB_SECURITY_AND_ADVANCEMENT_RATING
    "Sort by `managementRating` field"
    MANAGEMENT_RATING
    "Sort by `overallRating` field"
    OVERALL_RATING
    "Sort by `dateCreated` field (review submission time)"
    REVIEW_DATE
    "Sort by aggregated score of topic rating fields: `compensationAndBenefitsRating`, `cultureAndValuesRating`, `jobSecurityAndAdvancementRating`, `managementRating`, `workLifeBalanceRating`"
    TOPIC_RATINGS
    "Sort by `workLifeBalanceRating` field"
    WORK_AND_LIFE_BALANCE_RATING
}

"Reviews can belong to one or more topics. Enum represents available topics or its absence"
enum ReviewTopic {
    "Job Security & Advancement"
    ADVANCEMENT_TOPIC
    "Pay & Benefits"
    BENEFITS_TOPIC
    "Culture"
    CULTURE_TOPIC
    "Management"
    MANAGEMENT_TOPIC
    "Topic is absent"
    NO_TOPIC
    "Work-Life Balance"
    WORK_LIFE_TOPIC
}

"Value to determine how to group salary information"
enum SalaryGroupBy {
    "Group by employer key"
    EMPLOYER_KEY
    "Group by job title"
    JOB_TITLE
    "Group by job location"
    LOCATION
}

enum SalarySortBy {
    ALPHABETICAL
    AVERAGE_SALARY
    COUNT
}

"The type of salary"
enum SalaryType {
    "Biweekly"
    BIWEEKLY
    "Daily"
    DAILY
    "Hourly"
    HOURLY
    "Monthly"
    MONTHLY
    "Weekly"
    WEEKLY
    "Yearly"
    YEARLY
}

"The valid states that a SavedJob can have. Note that VISITED is deprecated, and will be stored as UNSAVED."
enum SavedJobState {
    APPLIED
    HIRED
    INTERVIEW
    INTERVIEWING @deprecated(reason: "Use INTERVIEW instead")
    OFFER
    OFFERED @deprecated(reason: "Use OFFER instead")
    SAVED
    UNSAVED
    VISITED @deprecated(reason: "Use UNSAVED instead")
}

enum Segment {
    L
    M
    S
    XL
}

"Sort direction"
enum SortDirection {
    ASC
    DESC
}

enum SortOrder {
    "Sort in Ascending value order"
    ASC
    "Sort in Descending value order"
    DESC
}

" order by criteria in spend views "
enum SpendOrderBy {
    ACR
    ASR
    CTR
}

" Job sponosoring event type "
enum SponsoredEvent {
    COMBINED
    ORGANIC
    SPONSORED
}

enum StartInterval {
    "Availability periods start at any time (e.g. 10:00, 10:01, 10:02, etc)."
    MINUTE_1
    "Availability periods start at every 10 minute boundary (e.g. 10:00, 10:10, 10:20, etc)."
    MINUTE_10
    "Availability periods start at every 15 minute boundary (e.g. 10:00, 10:15, 10:30, etc)."
    MINUTE_15
    "Availability periods start at every 20 minute boundary (e.g. 10:00, 10:20, 10:30, etc)."
    MINUTE_20
    "Availability periods start at every 30 minute boundary (e.g. 10:00, 10:30, 11:00, etc)."
    MINUTE_30
    "Availability periods start at every 5 minute boundary (e.g. 10:00, 10:05, 10:10, etc)."
    MINUTE_5
    "Availability periods start at every hour (e.g. 10:00, 11:00, 12:00, etc)."
    MINUTE_60
}

"""

Supported Content Types

_Note: Anything not mentioned in the order will be randomly shuffled on the tail-end_
"""
enum TargetedContentDeterminationType {
    """

    Input Defined Order

    This determination type is very naive and uses the order of input `allowedContentTypes`
    to generate the content. It is intended for testing and should be used in production.

    eg:
    allowedContentTypes = [JOB_SEARCH, RESUME_CTA]

    The order of output contents will be [JOB_SEARCH, RESUME_CTA]
    """
    INPUT_DEFINED_ORDER
    """

    ITA First Content Determination (deprecated, no longer supported)

    ITA > ACCOUNT_CREATE > JOB_SEARCH > INDEED_HOMEPAGE > RESUME_CTA
    """
    ITA_FIRST @deprecated(reason: "targeted-content-service no longer supports ITA")
    """

    JOB First Content Determination

    JOB > ACCOUNT_CREATE > JOB_SEARCH > INDEED_HOMEPAGE > RESUME_CTA
    """
    JOB_FIRST
    """

    Random-order Content Determination using a subset of TargetedContentType values

    Random order of everything excluding RESUME_CTA
    """
    RANDOM_SUBSET @deprecated(reason: "This determination type will be cleaned up soon.")
}

"""

Allowed types of values for Content Metadata.
This list will be enlarged when more types are needed.
"""
enum TargetedContentMetadataType {
    "Job Title"
    JOB_TITLE
    "Occupation"
    OCCUPATION
}

"Supported Content Types"
enum TargetedContentType {
    "Account Create Targeted Content via Passport"
    ACCOUNT_CREATE
    "Employer Targeted Content via Company Search Service API"
    EMPLOYER
    "Indeed home page Targeted Content"
    INDEED_HOMEPAGE
    """

    ITA Targeted Content
    Includes both ITA Apply and ITA Branded Targeted Content
    """
    ITA @deprecated(reason: "targeted-content-service no longer supports ITA")
    "Job Targeted Content via JobSearch API"
    JOB
    "Job Search Targeted Content"
    JOB_SEARCH
    "Resume Call-to-Action Targeted Content"
    RESUME_CALL_TO_ACTION
    "Resume Review Targeted Content"
    RESUME_REVIEW
}

"Allowed types of values for Custom Logging Field"
enum TargetedContentUserInteractionCustomLogFieldType {
    "Boolean type value"
    BOOLEAN
    "Float type value"
    FLOAT
    "Integer type value"
    INT
    "String type value"
    STRING
}

enum TaxonomyAttributeType {
    EXPERIMENTAL
    NONE
    OFFICIAL
    OTHER
}

enum TaxonomyConceptType {
    ATTRIBUTE
    COMPANY_SECTOR
    CUSTOM_CLASS
    OCCUPATION
}

enum UnitOfWork {
    BIWEEK
    DAY
    HOUR
    MONTH
    QUARTER
    WEEK
    YEAR
}

"Uploaded files status types"
enum UploadedDocumentStatus {
    DELETED
    UPLOADED
}

enum UserInteractionCustomLogFieldType {
    ARRAY_BOOLEAN
    ARRAY_FLOAT
    ARRAY_INT
    ARRAY_STRING
    BOOLEAN
    FLAG
    FLOAT
    INT
    STRING
}

"Verification status types"
enum VerificationStatus {
    UNCONCERNED
    VERIFIED_PHONE_REQUIRED
}

enum ViewContent {
    APPLICATION
    COVER_LETTER
    NOTIFICATION
    RESUME
    UNKNOWN_VIEW_CONTENT
}

"""

Advertiser identifier.

Serialized as a string.
"""
scalar AdvertiserId

scalar CountryCode

scalar Ctk

"3-Letter currency code. The value should be encoded as a 3-character string conforming to the ISO_4217 specification"
scalar CurrencyCode

scalar Date

"""

ISO8601 date/time value with an offset (formatted YYYY-MM-DDThh:mm:ss±hh:mm. Example: 2020-04-13T10:00:00+06:00)

Serialized as a string.
"""
scalar DateTime

"""

ISO8601 duration string (e.g. P<date>T<time> => PnYnMnDTnHnMnS)

Serialized as a string.
"""
scalar Duration

"An RFC-822 compliant email address string."
scalar EmailAddress

"""

Indeed account identifier.

Serialized as a string.
"""
scalar IndeedAccountId

scalar Int64

scalar LanguageCode

scalar Long

"""

ISO8601 time value (formatted hh:mm:ss.mmmm. Example: 10:30:15.1234)

When used as input, missing milliseconds are assumed to be zero.

When used as output, if the milliseconds are zero, they are not included in the
string value.

Serialized as a string.
"""
scalar Time

scalar Timestamp

"An RFC-2396/RFC-2732 compliant URI string."
scalar URI

scalar Upload

"Well-formed URL. Specifcation: [RFC 2396/2732](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)"
scalar WebUrl

"""

Time zone name (e.g. America/Chicago) or offset (i.e. +hh:mm or -hh:mm).

Serialized as a string.
"""
scalar ZoneID

input AddAvailabilityPeriodsInput {
    "Periods to add to the resource exclude availability rules."
    exclude: [AvailabilityPeriodInput!]
    "Periods to add to the resource include availability rules."
    include: [AvailabilityPeriodInput!]
    "ID of the [AvailabilityResource] to add availability periods to."
    resourceId: ID!
}

input AddFieldsJobSeekerProfileStructuredDataDislikedPreferenceInput {
    "List of disliked companies."
    companies: [JobSeekerProfileStructuredDataCompanyInput!]
    "List of disliked company sectors."
    companySectors: [JobSeekerProfileStructuredDataCompanySectorInput!]
    "List of disliked job titles."
    jobTitles: [JobSeekerProfileStructuredDataJobTitleInput!]
    "List of disliked job types."
    jobTypes: [JobSeekerProfileStructuredDataJobTypeInput!]
    "List of locations that user will prefer not to work at."
    locations: [JobSeekerProfileStructuredDataLocationInput!]
    "List of disliked occupations."
    occupations: [JobSeekerProfileStructuredDataOccupationInput!]
    "List of disliked remote/In person work types."
    remoteWorkTypes: [JobSeekerProfileStructuredDataRemoteWorkTypeInput!]
    "Salary Input."
    salary: JobSeekerProfileStructuredDataSalaryInput
    "List of disliked shifts."
    shifts: [JobSeekerProfileStructuredDataShiftInput!]
}

"Input for award to be added"
input AddJobSeekerProfileAwardInput {
    "The day the award was won, e.g. Janary of 2021"
    date: JobSeekerProfileDateTypeInput
    "A Job Seeker's award description, e.g. \"Award for the best programmer, is an award that is given in Indeed to the best programmer.\""
    description: String
    "A Job Seeker's award title, e.g. \"The best programmer award\""
    title: String!
}

input AddJobSeekerProfileCertificationInput {
    "The date range of the certification"
    dateRange: JobSeekerProfileDateRangeInput
    "The description of the certification"
    description: String
    "The taxonomy concept of the certification"
    taxonomyConceptTitle: AddJobSeekerProfileTaxonomyConceptInput
    "The title of the certification"
    title: String!
}

"Input for adding Job Seeker's company sector"
input AddJobSeekerProfileCompanySectorInput {
    "company sector name"
    name: String!
    "company sector name taxonomy concept"
    taxonomyConceptName: AddJobSeekerProfileTaxonomyConceptInput
}

"Job seeker profile degree input to be added."
input AddJobSeekerProfileDegreeInput {
    "The degree name"
    degreeName: String!
    "The degree field e.g. Biology, Computer Science"
    field: String
    "The taxonomy concepts for degree"
    taxonomyConceptDegree: AddJobSeekerProfileTaxonomyConceptInput
    "The taxonomy concepts for degree's field"
    taxonomyConceptField: AddJobSeekerProfileTaxonomyConceptInput
}

"A Job Seeker's education details input to be added."
input AddJobSeekerProfileEducationInput {
    "The date range of the certification"
    dateRange: JobSeekerProfileDateRangeInput
    "The degrees details of the education"
    degree: AddJobSeekerProfileDegreeInput!
    "The location where the degrees was obtained"
    location: JobSeekerProfileLocationTypeInput
    "The school in which the degree was obtained"
    school: String
}

"A Job Seeker's education details list input to be added."
input AddJobSeekerProfileEducationsInput {
    "List of educations"
    educations: [AddJobSeekerProfileEducationInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input AddJobSeekerProfileLinkInput {
    link: String!
}

"Job seeker profile awards input to be added."
input AddJobSeekerProfileResumeAwardsInput {
    "List of award items to be added"
    awards: [AddJobSeekerProfileAwardInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input AddJobSeekerProfileResumeCertificationsInput {
    "List of certifications"
    certifications: [AddJobSeekerProfileCertificationInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input AddJobSeekerProfileResumeLanguageSkillsInput {
    "List of language skills"
    languageSkills: [JobSeekerProfileLanguageSkillInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input AddJobSeekerProfileResumeLinksInput {
    "Links on this job seeker's resume"
    links: [AddJobSeekerProfileLinkInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input AddJobSeekerProfileResumeMilitaryInput {
    "List of military items to be added"
    military: [AddJobSeekerProfileResumeMilitaryItemInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input AddJobSeekerProfileResumeMilitaryItemInput {
    "Branch"
    branch: String!
    "Military service commendations"
    commendations: String
    "Military service country"
    country: String
    "Military service period"
    dateRange: JobSeekerProfileDateRangeInput
    "Description for military service"
    description: String
    "Military rank"
    rank: String!
    "Military service code"
    serviceCode: String
}

input AddJobSeekerProfileResumeSkillsInput {
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
    "List of skills"
    skills: [AddJobSeekerProfileSkillInput!]!
}

"Input that includes work experiences to be added"
input AddJobSeekerProfileResumeWorkExperiencesInput {
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
    "List of work experience items to be added"
    workExperiences: [AddJobSeekerProfileWorkExperienceInput!]!
}

input AddJobSeekerProfileSkillInput {
    "The experience time, the number of the TimeUnit e.g. 10 of 10 years"
    experience: Int64
    "The the taxonomy concept object"
    taxonomyConceptTitle: AddJobSeekerProfileTaxonomyConceptInput
    "Description"
    text: String!
    "The experience time unit"
    timeUnit: JobSeekerProfileTypeUnit
}

input AddJobSeekerProfileStructuredDataPreferenceInput {
    "Show if user is willing to relocate."
    ableToRelocate: Boolean
    "List of preferred companies."
    companies: [JobSeekerProfileStructuredDataCompanyInput!]
    "List of preferred company sectors."
    companySectors: [JobSeekerProfileStructuredDataCompanySectorInput!]
    "Preference Id."
    id: ID
    "List of preferred job titles."
    jobTitles: [JobSeekerProfileStructuredDataJobTitleInput!]
    "List of preferred job types."
    jobTypes: [JobSeekerProfileStructuredDataJobTypeInput!]
    "List of locations that user will prefer to work at."
    locations: [JobSeekerProfileStructuredDataLocationInput!]
    "List of preferred occupations."
    occupations: [JobSeekerProfileStructuredDataOccupationInput!]
    "List of prefered remote/In person work types."
    remoteWorkTypes: [JobSeekerProfileStructuredDataRemoteWorkTypeInput!]
    "Resume Id"
    rezId: ID
    "Salary Input."
    salary: JobSeekerProfileStructuredDataSalaryInput
    "List of preferred shifts."
    shifts: [JobSeekerProfileStructuredDataShiftInput!]
}

input AddJobSeekerProfileTaxonomyConceptInput {
    "The label of the taxonomy concept"
    label: String!
    "List of section ids of the taxonomy concept"
    sectionIds: [JobSeekerProfileSectionIdsInput!]
    "The suid (5-character String) of the taxonomy concept. e.g. GR7R8"
    suid: ID!
    "The type of the taxonomy concept"
    type: String
}

"Input for work experience to be added"
input AddJobSeekerProfileWorkExperienceInput {
    "job common skills"
    commonSkills: String
    "job company name"
    company: String
    "job company FccId"
    companyFccid: Int64
    "job company sector"
    companySector: AddJobSeekerProfileCompanySectorInput
    "job date range"
    dateRange: JobSeekerProfileDateRangeInput
    "job desciption"
    description: String
    "job location"
    location: JobSeekerProfileLocationTypeInput
    "normalized job title"
    normalizedTitle: String
    "job title"
    title: String!
}

input AddOrUpdateUDPConfirmedSectionsInput {
    confirmedSections: [String!]! = []
    resumeId: ID
}

input AddOrUpdateUDPSkippedQuestionsInput {
    skippedQuestionIds: [String!]! = []
}

input AddUDPSkippedQuestionsInput {
    skippedQuestionIds: [String!]! = []
}

input AddUserDisplayPreferenceInput {
    confirmedSections: [String!]! = []
    resumeId: ID
    skippedQuestionIds: [ID!]! = []
}

"AddressUpdate input for VerificationInfoInput"
input AddressInput {
    "Country code (ISO 3166-1 - alpha 2 encoded country code string)"
    countryCode: CountryCode!
    "Locality (ie. city)"
    locality: String
    "Postal code (ie. zip code)"
    postalCode: String
    "Region name (eg. name of state, territory, or province)"
    region: String
    "Street address, line 1"
    streetAddressLine1: String
    "Street address, line 2 (optional, for things like apartment or unit numbers)"
    streetAddressLine2: String
}

"The advertising location of draft job post."
input AdvertisingLocationInput {
    """

    At least one location must be active = true.
    A job may no longer be available at a location by setting to false.
    Default: true.
    """
    active: Boolean = true
    """

    The minimum granularity of suggested locations.
    A default granularity will be used if this parameter is not given.
    """
    granularity: MinimumGranularity
    "The normalized job location"
    location: String!
}

"Patch operation for Advertising Location."
input AdvertisingLocationPatchInput {
    "Type of patch operation to apply to set."
    operation: PatchSetOperationType!
    "Value to ADD or REMOVE."
    value: AdvertisingLocationInput!
}

input AnswerEntityInput {
    questionId: String!
    values: [String!]!
}

"Apply method input. Specify one and only one."
input ApplyMethodInput {
    email: EmailMethodInput
    inPerson: InPersonMethodInput
    website: WebsiteMethodInput
}

input AppointmentInput {
    id: CalendarEventIdInput!
}

input AvailabilityPeriodInput {
    """

    End time of the rule period.

    Value must be greater than [startTime].
    Resolution is 1 minute. Any sub-minute portion of the value is dropped.
    """
    endTime: DateTime!
    """

    The String that uniquely identifies the available period within an availability resource.
    The first request made for an Id will create an available period for the account and subsequent requests will update its details.

    Usually this will be an internal ID for the available period, encoded as an ASCII-only String of up to 64 characters.
    """
    key: String!
    """

    Start time of the rule period.

    Resolution is 1 minute. Any sub-minute portion of the value is dropped.
    """
    startTime: DateTime!
}

"Input to the [availabilityResource] query to retrieve an availability resource."
input AvailabilityResourceInput {
    id: ID!
}

"""

Specifies the time window in the future an event can be scheduled.

Example: If the minimum is one hour and the maximum is two weeks, only events that occur
later than one hour and less than two weeks from now should be scheduled on the calendar.

If all fields in the filter are null, the availability window starts from the current time and is
unbounded.

The window can be specified in this filter with either specific start and end time
(startTime/endTime) or with an offset from the current time (minimum/maximum). For example,
it is an error to set minimum and startTime.
"""
input AvailabilityWindowFilter {
    """

    End time of the availability window.

    Value must be greater than or equal to startTime or null if unbounded.
    Resolution is 1 minute. Any sub-minute portion of the value is dropped.
    """
    endTime: DateTime
    """

    Maximum amount of time in the future an event can be scheduled.

    Value must be greater than or equal to [minimum] or null if unbounded.
    Resolution is 1 minute. Any sub-minute portion of the value is dropped.
    """
    maximum: Duration
    """

    Minimum amount of time in the future an event can be scheduled.

    The default value is zero. The value must be greater than or equal to zero.
    Resolution is 1 minute. Any sub-minute portion of the value is dropped.
    """
    minimum: Duration
    """

    Start time of the availability window.

    Default value is the current time.
    Resolution is 1 minute. Any sub-minute portion of the value is dropped.
    """
    startTime: DateTime
}

input AvailabilityWindowInput {
    """

    Maximum amount of time in the future an event can be scheduled.

    Value is greater than or equal to [minimum] or null if unbounded.
    """
    maximum: Duration
    """

    Minimum amount of time in the future an event can be scheduled.

    Value is greater than or equal to zero.
    """
    minimum: Duration!
}

"A way of identifying a calendar event."
input CalendarEventIdInput {
    "The calendar this event belongs to."
    calendarId: CalendarIdInput!
    "Key that will be used to uniquely identify this calendar event within a calendar. Must be unique per calendar."
    key: String!
}

"Exactly one of indeedAccountId or availabilityResourceId is required."
input CalendarIdInput {
    "The availability resource id."
    availabilityResourceId: ID
    "The account id for the user."
    indeedAccountId: IndeedAccountId
}

input ClassifyOccupationsForJobDetailsInput {
    "Company name"
    companyName: String
    "A 2-character country code. The value is encoded as an ISO_3166-1 - alpha 2 formatted string"
    countryCode: CountryCode
    """

    Job description
    Either description or job title should be non-empty
    """
    description: String
    """

    Job title
    Either description or job title should be non-empty
    """
    jobTitle: String
    "A 2-character language code. The value is encoded as an ISO_639 formatted string"
    languageCode: LanguageCode
}

input CommonInput {
    advertiserID: Int = 0
    dateRanges: [DateRangeInput!]!
    granularity: Granularity
    jobType: SponsoredEvent = COMBINED
    limit: Int = 100
    offset: Int = 0
}

input ConfirmJobSeekerProfileStructuredDataInput {
    "Ceritification TaxonomyConcept."
    certificationTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput
    "Degree TaxonomyConcept."
    degreeTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput
    "Field of Study TaxonomyConcept."
    fieldOfStudyTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput
    "License TaxonomyConcept."
    licenseTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput
    "Occupation TaxonomyConcept."
    occupationTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput
    "Salary Input"
    salary: JobSeekerProfileStructuredDataSalaryInput
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment
    "Skill TaxonomyConcept ."
    skillTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput
}

"Input to Cpo Eligibility"
input CpoEligibilityInput {
    "Encrypted job id"
    legacyJobId: String!
}

input CreateDraftJobPostFromHostedJobPostInput {
    "Legacy ID (encrypted ats job ID)"
    id: ID!
    """

    `true` will create a DraftJobPost from the HostedJobPost, and link it to the originating HostedJobPost by ID.
    A subsequent call to `publishDraftJobPost()` will publish the DraftJobPost to the originating HostedJobPost (updating it).

    `false` will create a DraftJobPost from the HostedJobPost, not linked to the originating HostedJobPost.
    A subsequent call to `publishDraftJobPost()` will publish a *new* HostedJobPost.
    """
    linkToOriginatingHostedJobPost: Boolean!
}

"Input to createDraftJobPost"
input CreateDraftJobPostInput {
    "The new DraftJobPost"
    create: DraftJobPostCreateUpdateInput!
}

input CreateEventCalendarInput {
    "ID of the advertiser for which the Event Calendar is being created"
    advertiserId: AdvertiserId!
    "If not null, defines the event calendar's default resource availability rules."
    availabilitySettings: ResourceAvailabilitySettingsInput
}

input CreateHiringEventEnhancedScreeningInput {
    candidate: HiringEventCandidateInput!
    eventId: ID!
    hiringEventJobLocationId: ID!
    interviewPeriod: HiringEventAvailablePeriodInput!
    jobTitle: String!
    submissionMeta: CreateHiringEventEnhancedScreeningInputSubmissionMetaInput
}

input CreateHiringEventEnhancedScreeningInputSubmissionMetaInput {
    "Indeed Cookie Tracking Key"
    ctk: String
    "Indeed Apply application id"
    iaApplicationId: ID
    "RF tracking key key word"
    ikw: String
    "Indeed tracking token"
    indconvtk: String
    "RF tracking key search engine marketing"
    isid: String
    "Tk for ITA tracking"
    itaTk: String
    "logTK for IJP promotions page"
    nhdLogTk: String
    ref: String
    refKw: String
    refType: String
    rsvpReferrerCode: String
    "Tracking key for apply starts"
    serpTk: String
    sourceJobKey: String
    "IJP log tk"
    tk: String
    "How the jobseeker viewed the IJP page"
    viewType: String
}

input CreateHiringEventRsvpInput {
    candidate: HiringEventCandidateInput!
    eventUuid: ID!
    hiringEventJobLocationId: ID!
    interviewPeriod: HiringEventAvailablePeriodInput!
    jobTitle: String!
    screenerAnswers: [HiringEventScreeningAnswerInput!]!
    submissionMeta: CreateHiringEventRsvpInputSubmissionMetaInput
}

input CreateHiringEventRsvpInputSubmissionMetaInput {
    "Encoded adblob string containing ads info. Currently used for billing for RSVP success. See https://bugs.indeed.com/browse/IHPRAT-80"
    adblob: String
    ctk: String
    iaApplicationId: ID
    ikw: String
    indconvtk: String
    isid: String
    itaTk: String
    nhdLogTk: String
    ref: String
    refKw: String
    refType: String
    rsvpReferrerCode: String
    "UUID generated by Indeed Apply that correspond to a RSVP start."
    rsvpStartUuid: String
    serpTk: String
    sourceJobKey: String
    "log tk"
    tk: String
    viewType: String
}

"Input to createHostedEmployer"
input CreateHostedEmployerInput {
    "The new Hosted Employer"
    create: HostedEmployerCreateInput!
}

"Input to createHostedJobPost"
input CreateHostedJobPostInput {
    "The new HostedJobPost"
    create: HostedJobPostCreateUpdateInput!
}

input CreateOrUpdateTimePunchInput {
    clientExternalId: ID!
    comment: String
    jobsiteExternalId: ID!
    jobsiteTimezone: String!
    punchCode: PunchCode!
    punchIn: DateTime!
    punchOut: DateTime!
    shiftExternalId: ID
    workerExternalId: ID!
}

"Parameters for the `createReviewComment` mutation"
input CreateReviewCommentInput {
    "The country code of the review comment"
    countryCode: String!
    "The language code of the review comment"
    languageCode: String!
    """

    The ID of the associated review, ignored if review key is supplied.

    *Deprecated:* Review IDs are for internal use only. Use field `reviewKey` instead.
    """
    reviewId: ID
    "The key of the associated review, mandatory unless a review ID is supplied"
    reviewKey: ID
    "The full text of the review comment"
    text: String!
}

"Indicates how clients would want to get TaxoConcepts by CustomClass Filter."
input CustomClassFilterInput {
    "Use this field to only keep TaxonomyConcepts belong to the CustomClasses."
    customClasses: [ID!]!
    "The way of joining multiple `CustomClass`. Default is AND."
    operation: CustomClassFilterOperation
}

" Date Range "
input DateRangeInput {
    from: String!
    to: String!
}

input DeleteAppointmentInput {
    id: CalendarEventIdInput!
}

"Input to deleteDraftJobPost"
input DeleteDraftJobPostInput {
    "The ID of the existing Draft Job Post to delete"
    id: ID!
}

input DeleteEventCalendarInput {
    id: ID!
}

input DeleteFieldsJobSeekerProfileStructuredDataDislikedPreferenceInput {
    "List of disliked companies."
    companyIDs: [String!]
}

input DeleteJobSeekerProfileFileInput {
    "File Id"
    id: ID!
}

"Input that includes award ids to be deleted"
input DeleteJobSeekerProfileResumeAwardsInput {
    "List of award IDs in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    awardIds: [String!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input DeleteJobSeekerProfileResumeCertificationsInput {
    "List of certification IDs in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    certificationIds: [String!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input DeleteJobSeekerProfileResumeEducationsInput {
    "List of educations IDs."
    educationIds: [String!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input DeleteJobSeekerProfileResumeInput {
    "List of UpdogRezIDs for jobseeker resumes to delete"
    resumes: [ID!]!
}

input DeleteJobSeekerProfileResumeLanguageSkillsInput {
    "List of languages, e.g. [English, Spanish]"
    languages: [String!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input DeleteJobSeekerProfileResumeLinksInput {
    "Links on this job seeker's resume"
    linkIds: [String!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input DeleteJobSeekerProfileResumeMilitaryInput {
    "List of military IDs in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    militaryIds: [String!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input DeleteJobSeekerProfileResumeSkillsInput {
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
    "List of skill IDs in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    skillIds: [String!]!
}

"Input that includes work experience ids to be deleted"
input DeleteJobSeekerProfileResumeWorkExperiencesInput {
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
    "List of work experience IDs in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    workExperienceIds: [String!]!
}

"Parameters for the `deleteReviewComment` mutation"
input DeleteReviewCommentInput {
    "The key of the associated review comment"
    key: ID!
}

input DeleteUserCalendarInput {
    id: ID!
}

"DeleteVerificationInfo input for VerificationInfoInput"
input DeleteVerificationInfoInput {
    "Boolean for the client to confirm they really want to delete info"
    areYouSure: Boolean!
}

input DownloadJobSeekerProfileFileInput {
    "File Id"
    id: ID!
}

"""

A new employer Draft  Job Post
A  job post in draft mode - prior to publish.
"""
input DraftJobPostCreateUpdateInput {
    "List of advertising locations for this job."
    advertisingLocations: [AdvertisingLocationInput!] = []
    """

    An apply method, look at specific implementation
    for details.
    """
    applyMethod: ApplyMethodInput
    "List of extended job attributes"
    attributes: [KeyValuePairInput!] = []
    """

    The hiring company name.
    The maximum length for the company name should not exceed 200
    characters.
    """
    company: String
    "Country code."
    country: CountryCode
    "Is cover letter required?"
    coverLetterRequired: JobRequirement
    """

    The job description.
    Markdown formatting may be used:
    For _italics_ use underscores: `_italics_`
    For emphasis use asterisks: `*bold*`
    For line breaks use: `\n`
    For bullets use an asterisk and a space: `* Item`
    The minimum length for the job description should be 30
    characters and the maximum length should not exceed 20000.
    """
    description: String
    "External structured data"
    extensionMetadata: [EmployerJobPostExtensionMetadataInput!] = []
    "The full street address where work will be performed."
    jobAddress: String
    "List of job types."
    jobTypes: [JobType!] = []
    "Language code."
    language: LanguageCode
    "The taxonomy UUID that identifies the job occupation."
    occupationUuid: String
    "Is phone required?"
    phoneRequired: JobRequirement
    "Is resume required?"
    resumeRequired: JobRequirement
    "Job salary period and range amounts."
    salary: JobSalaryInput
    "List of taxonomy attributes"
    taxonomyAttributes: [JobPostTaxonomyCustomClassAttributesInput!] = []
    """

    The job post title
    The maximum length for the job title should not exceed 75
    characters.
    """
    title: String
}

"""

A patch object for a Draft Job Post.
Set fields to an explicit value or set fields to `null` to explicitly clear the field.
"""
input DraftJobPostPatchInput {
    "Replace existing set of advertiser locations with the given set."
    advertisingLocations: [AdvertisingLocationInput!]
    "Patch operations to apply to current set of advertising locations for this job."
    advertisingLocationsPatch: [AdvertisingLocationPatchInput!]
    """

    An apply method, look at specific implementation
    for details.
    """
    applyMethod: ApplyMethodInput
    "Replace existing set of job attributes with the given set."
    attributes: [KeyValuePairInput!]
    "Patch operations to apply to current set of extended job attributes."
    attributesPatch: [KeyValuePairPatchInput!]
    """

    The hiring company name.
    The maximum length for the company name should not exceed 200
    characters.
    """
    company: String
    "Country code."
    country: CountryCode
    "Is cover letter required?"
    coverLetterRequired: JobRequirement
    """

    The job description.
    Markdown formatting may be used:
    For _italics_ use underscores: `_italics_`
    For emphasis use asterisks: `*bold*`
    For line breaks use: `\n`
    For bullets use an asterisk and a space: `* Item`
    The minimum length for the job description should be 30
    characters and the maximum length should not exceed 20000.
    """
    description: String
    "External structured data"
    extensionMetadata: [EmployerJobPostExtensionMetadataInput!]
    "Replace existing set of extension metadata with the given set."
    extensionMetadataPatch: [EmployerJobPostExtensionMetadataPatchInput!]
    "The full street address where work will be performed."
    jobAddress: String
    "Replace existing set of job types with the given set."
    jobTypes: [JobType!]
    "Patch operations to apply to current set of job types."
    jobTypesPatch: [JobTypePatchInput!]
    "Language code."
    language: LanguageCode
    "The taxonomy UUID that identifies the job occupation."
    occupationUuid: String
    "Is phone required?"
    phoneRequired: JobRequirement
    "Is resume required?"
    resumeRequired: JobRequirement
    "Job salary period and range amounts."
    salary: JobSalaryInput
    "Patch operations to apply to current set of taxonomy attributes (atomic attributes)."
    taxonomyAttributesPatch: [JobPostTaxonomyCustomClassAttributePatchInput!]
    "Patch update Taxonomy Attributes based on Custom Class"
    taxonomyAttributesPatchByCustomClass: [JobPostTaxonomyAttributesPatchByCustomClassInput!]
    """

    The job post title
    The maximum length for the job title should not exceed 75
    characters.
    """
    title: String
}

"Filter criteria for FindDraftJobPosts."
input DraftJobPostsFilterInput {
    "An advertising location to match. Exact match by default. To partial match, set `partialAdvertisingLocation = true`."
    advertisingLocation: String
    """

    Draft job posts linked to an originating hosted job post. See `createDraftJobPostFromHostedJobPost`.
    `false` (default): filter to exclude draft job posts linked to an originating hosted job post.
    `true`: filter to include draft job posts linked to an originating hosted job post.
    """
    linkedToOriginatingHostedJobPost: Boolean! = false
    "Indicate whether a job location search should look for partial job location match."
    partialAdvertisingLocation: Boolean! = false
    "Indicate whether a title search should look for partial title match."
    partialTitle: Boolean! = false
    "Job title to match. Exact match by default. To partial match, set `partialTitle = true`."
    title: String
}

"Sorting of results"
input DraftJobPostsSortInput {
    "Sort direction."
    direction: SortDirection! = DESC
    "Sort field."
    field: DraftJobPostsSortField! = DATE_CREATED
}

"Apply by email."
input EmailMethodInput {
    "List of email addresses"
    emails: [EmailAddress!]!
}

"Specify pages to fetch using forward or backward cursor and limit."
input EmployerBidirectionalCursorInput {
    "Fetch entries after this cursor. Omit if you want the first page. Cannot be specify both `after` and `before`."
    after: ID
    "Fetch entries before this cursor. Cannot be specify both `after` and `before`."
    before: ID
    "The maximum number of entries to return. If the value exceeds the maximum of 100, then the maximum value will be used."
    limit: Int! = 100
}

"Specify pages to fetch using forward cursor and limit."
input EmployerForwardOnlyCursorInput {
    "Fetch entries after this cursor. Omit if you want the first page."
    after: ID
    "The maximum number of entries to return. If the value exceeds the maximum of 100, then the maximum value will be used."
    limit: Int! = 100
}

"""

Input for an external structured data extension defined by external client.
Examples of metadata that may be attached include:
- Job Requirements (aka screener questions)
- Funnel-specific data
This is specific to the DraftJobPost and there should be no
expectation that the extension metadata will be retained once the
job is published.
"""
input EmployerJobPostExtensionMetadataInput {
    """

    Metadata as a JSON string.
    e.g.: "{\"twitterHandle\":\"@thescavenger\"}"
    The structure of this data is externally defined (e.g. by the IQ
    team or funnel team).
    It must be a valid, parsable JSON
    string. It must not exceed 4096 bytes.
    """
    data: String!
    """

    Type
    e.g. "IqRequirements"
    """
    type: String!
    """

    Version of the type.
    e.g.: "2.1"
    """
    version: String
}

input EmployerJobPostExtensionMetadataPatchInput {
    "Type of patch operation to apply to set."
    operation: PatchSetOperationType!
    "Value to ADD or REMOVE."
    value: EmployerJobPostExtensionMetadataInput!
}

"Specify pages to fetch using offset and limit."
input EmployerOffsetInput {
    "The maximum number of entries to return. If the value exceeds the maximum of 100, then the maximum value will be used."
    limit: Int! = 100
    """

    The (zero-based) offset of the first item in the collection to return.
    You may alternatively use `pageOffset` for an page-based offset.
    """
    offset: Int! = 0
    """

    The (zero-based) offset of the page of items to return. A number of items in a page is equal to the limit.
    You may alternatively use `offset` for an item-based offset.
    """
    pageOffset: Int! = 0
}

"Model of a PIE permission"
input EmployerPermission {
    resource: String!
    verbs: [String!]!
}

input EmployerSalaryInput {
    jobTitle: String
    "Location in specific format(e.g. US, US/TX or US/TX/Austin). This field is required at least country level"
    location: String
    minCountForTimeRange: Int
    useLatestTimeRange: Boolean
}

" Input type for enableAttachResumes "
input EnableAttachNewCandidateResumesInput {
    " Reason that user wishes to attach a new candidate resume to email notifications "
    usageReason: AttachResumeUsageReason!
    " User-provided comments describing what other tools or applicant tracking systems the user employs "
    usageReasonDetails: String!
}

input EstimateSalaryForJobDetailsInput {
    "Job Location, note that job title and job location cannot both be empty"
    jobLocation: String
    "Job title, note that job title and job location cannot both be empty"
    jobTitle: String
    "Job locale"
    locale: JobLocale!
}

"Input to the [eventCalendar] query to retrieve an availability resource of type [EventCalendar]."
input EventCalendarInput {
    id: ID!
}

input ExcludeAvailabilitySettingsInput {
    periods: [AvailabilityPeriodInput!]
    "Note: exclude weekly availability rules are not currently implemented"
    week: WeekAvailabilityRulesInput
}

input FetchSQInput {
    applyJobId: String!
    ctk: String!
    ppid: String
}

input FilteredNamesFetcherInput {
    advertiserID: Int = 0
    dateRanges: [DateRangeInput!]!
    jobType: SponsoredEvent = COMBINED
    limit: Int = 100
    offset: Int = 0
}

"Response payload from findDraftJobPosts()"
input FindDraftJobPostsInput {
    "Filter results. If omitted, no filtering will be applied."
    filter: DraftJobPostsFilterInput
    "Page with limit and offset. If omitted, a default limit/offset will be applied."
    offset: EmployerOffsetInput
    "Sort results. If omitted, a default sorting will be applied."
    sort: DraftJobPostsSortInput
}

"""

Specifies an open-interval range filter for Dates. If both a "gt" and "lt" operator are supplied as part of the same
filter then they implicitly form an "allOf" filter. Dates are assumed to represent CDT.
"""
input FindEmployerJobsDateTimeFilterInput {
    "Matches if the Date associated with this field is \"greater than\" the supplied DateTime."
    gt: DateTime
    "Matches if the Date associated with this field is \"less than\" the supplied DateTime."
    lt: DateTime
}

"""

Each filter expression should consist of a single-arity object that contains either the field name or compound operator
and its value. If multiple operators or fields are supplied they will implicitly form an "allOf" filter. Filters can
be nested to build more complex filters.
"""
input FindEmployerJobsFilterInput {
    "Only includes an employer job if all of the provided filters match."
    allOf: [FindEmployerJobsFilterInput!]
    "Includes an employer job if any of the provided filters match."
    anyOf: [FindEmployerJobsFilterInput!]
    "Filter on the location attributes"
    location: FindEmployerJobsLocationFilterInput
    "Negates the provided child filter."
    not: FindEmployerJobsFilterInput
    """

    Filter on the date that the employer job was "published" with date in CDT. This is a best guess at when the job was
    first created and not necessarily when it was first aggregated by Indeed.
    """
    publishedDateTime: FindEmployerJobsDateTimeFilterInput
    "Filter on the referenceId also known as the \"refnum.\""
    referenceId: FindEmployerJobsInFilterInput
    "Filter on the sourceId field."
    sourceId: FindEmployerJobsInFilterInput
    "Filter on the title field"
    title: FindEmployerJobsTextFilterInput
}

"""

Matches an employer job if any of the provided values match for this field. Similar to an "anyOf" filter but for a
specific field.
"""
input FindEmployerJobsInFilterInput {
    in: [ID!]!
}

"This query input allows filtering, sorting, and paginating employer job hits for a given employer."
input FindEmployerJobsInput {
    "Finds results after a cursor. To advance to the next page provide the \"endCursor\" from \"pageInfo.\""
    after: String
    "Finds results before a cursor. To go back to the previous page provide the \"startCursor\" from \"pageInfo.\""
    before: String
    "An optional filter expression. Compound filters can be created through the use of the \"anyOf\" or \"allOf\" filter."
    filter: FindEmployerJobsFilterInput
    "Specifies the maximum number of results to return for a given query. Defaults to 10."
    limit: Int! = 10
    """

    An optional set of sort keys to apply. Includes both the field and the sort direction. The order of the sort keys
    matches the order in which sorts will be performed.
    """
    sort: [FindEmployerJobsSortKeyInput!]
}

"""

Performs a filter on the location of the job. Location attributes include the area (city, state) provided
through the `match` property and the country code using the `countryCode` property
Example:
```
filter: {
location: {
match: "Austin, TX",
countryCode: "US"
}
}
```
"""
input FindEmployerJobsLocationFilterInput {
    "Matches the country code of the job"
    countryCode: String
    "Matches the job area provided as `city,state`"
    match: String!
}

"""

Specifies a field to sort on whether to sort in an "ascending" or "descending" direction. Each sort key should be a
single-arity object.
"""
input FindEmployerJobsSortKeyInput {
    "Sort on the approximate publication date."
    publishedDateTime: FindEmployerJobsSortDirection!
}

"""

Performs a full text search using the specified `match` string
Example:
```
filter: {
title: {
match: "Content Developer"
}
}
```
"""
input FindEmployerJobsTextFilterInput {
    match: String!
}

input FindEmployersInput {
    """

    The maximum number of results to return

    Capped at 50.
    """
    limit: Int! = 10
    """

    The page number

    First page starts at 0.
    """
    offset: Int! = 0
    """

    Search query

    This may be a name of an employer, job title, or category

    **Examples:**
    - "Indeed"
    - "Glassdoor"
    - "Customer Support"
    - "Sales Representative/Customer Service"
    """
    what: String! = ""
    """

    Location query

    Location will be resolved based on country and language.

    **Examples:**
    - "Austin, TX"
    - "Texas"
    - "90210"
    - "30.26715, -97.74306"
    """
    where: String! = ""
}

input FindHiringEventRsvpsInput {
    "Indeed account keys."
    accountKeys: [ID!]
    "An RSVP will only be included in the response if its status is contained in this collection. If this collection is not provided, all statuses will be included."
    statusesToInclude: [HiringEventRsvpStatus]
}

"""

This input supports getting events by Event id (i.e. UUID), aggregation job key, or by the advertiser tied to the event.
If a combination is provided, an error will be thrown.
"""
input FindHiringEventsInput {
    "Retrieve events associated with the specified advertisers."
    advertiserNumbers: [ID!]
    "Retrieve events by their UUIDs."
    ids: [ID!]
    """

    Retrieve events associated with the specified jobs.
    Since multiple jobs can be tied to the same event,
    it may be possible to get duplicate events in the response.
    """
    jobKeys: [ID!]
    """

    Limits the number of hiring events provided in the result.
    No default value is specified.
    """
    limit: Int
}

input FindHostedJobPostsFilterInput {
    "An advertising location to match. Exact match by default. To partial match, set `partialAdvertisingLocation = true`."
    advertisingLocation: String
    "Match by campaign types."
    campaignTypes: [HostedJobPostCampaignType!]
    "Match by accounts."
    createdByAccounts: [ID!]
    "Indicate whether a job location search should look for partial advertising location match."
    partialAdvertisingLocation: Boolean! = false
    "Indicate whether a title search should look for partial title match."
    partialTitle: Boolean! = false
    "Match by statuses. By default, jobs are filtered by ACTIVE and PAUSED status."
    statuses: [HostedJobPostStatus!]
    "Job title to match. Exact match by default. To partial match, set `partialTitle = true`."
    title: String
}

input FindHostedJobPostsInput {
    "Filter results. If omitted, no filtering will be applied."
    filter: FindHostedJobPostsFilterInput
    "Page with limit and offset. If omitted, a default limit/offset will be applied."
    offset: EmployerOffsetInput
    "Sort results. If omitted, a default sorting will be applied."
    sort: HostedJobPostsSortInput
}

input FindRelevantJobsInput {
    "builds the field \"from\" = rjp_[adformat].[context]"
    context: String!
    isMobile: Boolean!
    lastVisitTime: Long! = 0
    limit: Int! = 10
}

"Input object with the data required to return targeted content results"
input FindTargetedContentInput {
    "Allow list of targeted content types"
    allowedContentTypes: [TargetedContentType!] = []
    "Content Metadata (e.g tags) of content being shown to the user"
    contentMetadata: [TargetedContentMetadata!] = []
    "Number of targeted content results to return"
    count: Int = 1
    "Specify Determination Type to use to generate results. ITA_FIRST is deprecated, now defaults to JOB_FIRST"
    determinationType: TargetedContentDeterminationType = JOB_FIRST
    "ITA related filters. Deprecated, targeted-content-service no long supports ITA"
    itaFilters: TargetedContentITAFilters
    """

    Query History of the user, used to better filter results on the ITA Side

    Accessible via __RQ__ Cookie in browser
    """
    jobSearchQueryHistory: String = ""
    "Content Title of content being shown to the user"
    subjectTitle: String!
    """

    This input can be used to override the content that would otherwise be generated
    this query operation.

    This overrides will be skipped on ITA Content Type

    Note: Only the first of a particular content type will be used,
    the repeats will be ignored
    """
    textOverrides: [TargetedContentTextOverride!] = []
}

input FindUserDisplayPreferenceByIdInput {
    accountId: Int!
}

input FindYelpBusinessInput {
    clientId: String
    country: String!
    ctk: Ctk
    jobId: String
    lat: Float!
    lon: Float!
    name: String!
    postalCode: String!
    prforceGroups: String
    streetAddress: String!
    tk: String
}

input FindYelpBusinessesByIdsInput {
    ids: [String!]!
    prforceGroups: String
}

input GetIhpAdvertiserSubscriptionsByAdvertiserInput {
    "Array of Advertiser Id."
    advertiserNumbers: [String!]!
}

"""

This is to provide the same structure as `JobSearchFilterInput`.
For each `GlobalJobCountFilterInput` instance `keyword` must be set.
"""
input GlobalJobCountFilterInput {
    keyword: GlobalJobCountKeywordFilterInput
}

input GlobalJobCountGroupingInput {
    "The type of grouping to execute."
    type: JobSearchResultGroupByRelation!
}

input GlobalJobCountInput {
    """

    Specify filters. This must not be empty.
    See also the `filter` argument of jobSearch API.
    """
    filters: [GlobalJobCountFilterInput!]!
    "Specify how to group the result count. Default is `{ type: EMPLOYER_TITLE }`."
    grouping: GlobalJobCountGroupingInput! = {type: EMPLOYER_TITLE}
}

"""

Detail of each keyword filter. This has the same structure as `JobSearchKeywordFilterInput` but supports limited fields.

|Field|Expected format of keys|
|-|-|
|indeedEmployerKey|The same format as `Employer/key` in jobSearch API|
|glassdoor.employerKey|Glassdoor employer key|
|sourceType|One of `EMPLOYER`, `JOB_BOARD`, or `RECRUITER`|
"""
input GlobalJobCountKeywordFilterInput {
    "Name of the field to filter jobs by"
    field: String!
    "Keys to filter jobs by"
    keys: [String!]!
    "The way of joining multiple `keywords`. Default is AND."
    operation: JobSearchKeywordFilterOperation
}

"Filters for happiness stats."
input HappinessStatsFilterInput {
    "Normalized job title"
    normalizedJobTitle: String
    "Job location in short display format (e.g. for US address, no zip code: San Francisco, CA)"
    shortFormattedLocation: String
}

"Parameter for the `highlight review` mutation"
input HighlightReviewInput {
    countryCode: String!
    languageCode: String!
    reviewKey: String!
}

input HiringEventAvailablePeriodInput {
    endTime: DateTime!
    startTime: DateTime!
}

input HiringEventCandidateInput {
    email: String!
    firstName: String!
    lastName: String!
    phone: String!
}

input HiringEventClientIntakesInput {
    "Array of client intake UUIDs"
    clientIntakeIds: [ID!]!
}

input HiringEventContactInfosInput {
    "Array of email UUIDs"
    emailIds: [ID!]!
}

input HiringEventRsvpsInput {
    "Array of RSVP UUIDs"
    rsvpIds: [ID!]!
}

input HiringEventScreeningAnswerInput {
    answer: HiringEventScreeningAnswerValue!
    hiringEventScreeningQuestionId: ID!
}

"Patch operation for Advertising Location."
input HostedAdvertisingLocationPatchInput {
    "Type of patch operation to apply to set."
    operation: PatchSetOperationType!
    "Advertising Location to add or update (if location exists)."
    value: AdvertisingLocationInput!
}

"Address of employer's company."
input HostedEmployerAddressInput {
    "Primary street address"
    address1: String
    "Secondary address (suite/apt #)"
    address2: String
    "Province/state code"
    admin1Code: String
    "City name"
    city: String
    "Postal/zip code"
    postalCode: String
}

input HostedEmployerAttributesPatchInput {
    "Type of patch operation to apply to set (currently limited to adding attributes - ADD)."
    operation: HostedEmployerAttributesPatchSetOperationType!
    "Value to add."
    value: KeyValuePairInput!
}

"An employer's billing information."
input HostedEmployerBillingInput {
    "The employer's billing-contact email. Format: 'name@domain'. Maximum length should not exceed 200 characters."
    email: EmailAddress
}

"An employer's company information."
input HostedEmployerCompanyInput {
    "The company's location."
    address: HostedEmployerAddressInput
    "The name of the company's primary context (a person)."
    contact: String
    "Approximate employee count."
    employeeCount: HostedEmployerEmployeeCount
    "The company's name."
    name: String
    "The phone number of the company's primary contxt. The minimum length is 5 digits."
    phone: String
    "The company's web site URL. Must begin with 'http://' or 'https://'."
    url: WebUrl
}

"A new Hosted Employer"
input HostedEmployerCreateInput {
    "Is this employer an ad agency? Default: false."
    adAgency: Boolean
    "The employer's billing information."
    billing: HostedEmployerBillingInput
    "Currency for billing. If this field is absent in employer creation, it will be the default currency of the employer country."
    billingCurrency: BillingCurrencyCode
    "The employer's company information."
    company: HostedEmployerCompanyInput
    "Primary country. Format: [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) 2-letter country code. Default: US."
    country: CountryCode
    "This employer's type."
    employerType: HostedEmployerType
    "Industry of employer."
    industry: HostedEmployerIndustry
    "Language for billing. Format: [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) 2-letter language code. Default: en."
    language: LanguageCode
}

"A patch update for a hosted employer"
input HostedEmployerPatchInput {
    "Is this employer an ad agency? Default: false."
    adAgency: Boolean
    "Patch operations to apply to current set of employer attributes."
    attributesPatch: [HostedEmployerAttributesPatchInput!]
    "The employer's billing information."
    billing: HostedEmployerBillingInput
    "Currency for billing. If this field is absent in employer creation, it will be the default currency of the employer country."
    billingCurrency: BillingCurrencyCode
    "The employer's company information."
    company: HostedEmployerCompanyInput
    "Primary country. Format: [ISO-3166-1](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) 2-letter country code. Default: US."
    country: CountryCode
    "This employer's type."
    employerType: HostedEmployerType
    "Industry of employer."
    industry: HostedEmployerIndustry
}

input HostedJobMatchingStringsInput {
    jobKey: String!
    tagId: Int
}

input HostedJobMessagingTagInput {
    jobKey: String
    visibilityEstimation: HostedJobPostVisibilityEstimation
}

input HostedJobMessagingTagsInput {
    messagingTagInputs: [HostedJobMessagingTagInput!]!
}

"Input for HostedJobPostCounts"
input HostedJobPostCountsInput {
    "An advertising location to match. Exact match by default. To partial match, set `partialAdvertisingLocation = true`."
    advertisingLocation: String
    "Match by accounts."
    createdByAccounts: [ID!]
    "Indicate whether a job location search should look for partial advertising location match."
    partialAdvertisingLocation: Boolean! = false
    "Indicate whether a title search should look for partial title match."
    partialTitle: Boolean! = false
    "Job title to match. Exact match by default. To partial match, set `partialTitle = true`."
    title: String
}

"A new employer Hosted  Job Post"
input HostedJobPostCreateUpdateInput {
    "List of advertising locations for this job."
    advertisingLocations: [AdvertisingLocationInput!]!
    """

    An apply method, look at specific implementation
    for details.
    """
    applyMethod: ApplyMethodInput!
    "List of extended job attributes"
    attributes: [KeyValuePairInput!] = []
    """

    The hiring company name.
    The maximum length for the company name should not exceed 200
    characters.
    """
    company: String!
    "Country code."
    country: CountryCode!
    "Is cover letter required?"
    coverLetterRequired: JobRequirement
    """

    The job description.
    Markdown formatting may be used:
    For _italics_ use underscores: `_italics_`
    For emphasis use asterisks: `*bold*`
    For line breaks use: `\n`
    For bullets use an asterisk and a space: `* Item`
    The minimum length for the job description should be 30
    characters and the maximum length should not exceed 20000.
    """
    description: String!
    "The full street address where work will be performed."
    jobAddress: String
    "List of job types."
    jobTypes: [JobType!]!
    "Language code."
    language: LanguageCode
    "The taxonomy UUID that identifies the job occupation."
    occupationUuid: String
    "Is phone required?"
    phoneRequired: JobRequirement
    "Is resume required?"
    resumeRequired: JobRequirement
    "Job salary period and range amounts."
    salary: JobSalaryInput
    "Status for the hosted job post"
    status: HostedJobPostStatus!
    "List of taxonomy attributes"
    taxonomyAttributes: [JobPostTaxonomyCustomClassAttributesInput!] = []
    """

    The job post title
    The maximum length for the job title should not exceed 75
    characters.
    """
    title: String!
}

"""

A patch object for a Hosted Job Post.
Set fields to an explicit value or set fields to `null` to explicitly clear the field.
"""
input HostedJobPostPatchInput {
    "List of advertising locations for this job."
    advertisingLocations: [AdvertisingLocationInput!]
    "Patch operations to apply to current set of advertising locations for this job."
    advertisingLocationsPatch: [HostedAdvertisingLocationPatchInput!]
    """

    An apply method, look at specific implementation
    for details.
    """
    applyMethod: ApplyMethodInput
    "Replace existing set of job attributes with the given set."
    attributes: [KeyValuePairInput!]
    "Patch operations to apply to current set of extended job attributes."
    attributesPatch: [KeyValuePairPatchInput!]
    """

    The hiring company name.
    The maximum length for the company name should not exceed 200
    characters.
    """
    company: String
    "Country code."
    country: CountryCode
    "Is cover letter required?"
    coverLetterRequired: JobRequirement
    """

    The job description.
    Markdown formatting may be used:
    For _italics_ use underscores: `_italics_`
    For emphasis use asterisks: `*bold*`
    For line breaks use: `\n`
    For bullets use an asterisk and a space: `* Item`
    The minimum length for the job description should be 30
    characters and the maximum length should not exceed 20000.
    """
    description: String
    "The full street address where work will be performed."
    jobAddress: String
    "Replace existing set of job types with the given set."
    jobTypes: [JobType!]
    "Patch operations to apply to current set of job types."
    jobTypesPatch: [JobTypePatchInput!]
    "Language code."
    language: LanguageCode
    "The taxonomy UUID that identifies the job occupation."
    occupationUuid: String
    "Is phone required?"
    phoneRequired: JobRequirement
    "Is resume required?"
    resumeRequired: JobRequirement
    "Job salary period and range amounts."
    salary: JobSalaryInput
    "Status for the hosted job post"
    status: HostedJobPostStatus
    "Patch update Taxonomy Attributes based on Custom Class"
    taxonomyAttributesPatchByCustomClass: [JobPostTaxonomyAttributesPatchByCustomClassInput!]
    """

    The job post title
    The maximum length for the job title should not exceed 75
    characters.
    """
    title: String
}

"Input to HostedJobPostPerformance"
input HostedJobPostPerformanceInput {
    "The end date of query in ISO-8601 format, e.g. 2020-03-31. Note that the end date is exclusive."
    endDate: String!
    "The unique identifier of an aggregated job."
    jobKey: String
    "The start date of query in ISO-8601 format, e.g. 2020-01-01. Note that the start date is inclusive."
    startDate: String!
}

input HostedJobPostVisibilityEstimation {
    jobCompany: String
    jobCountry: String!
    jobDescription: String
    jobLanguage: String
    messagingTagJobTitle: String
}

"""

type Query {
# Each schema definition requires a explicit Query type with at least one field / operation.
# Since this API service does not directly expose a root query, the following serves as a placeholder field/operation.
_drmxFedVisibilitiesApiPlaceholder: String
}
"""
input HostedJobPostVisibilityInput {
    "The unique identifier of an aggregated job."
    jobKey: String!
}

"Sorting of results"
input HostedJobPostsSortInput {
    "Sort direction."
    direction: SortDirection! = DESC
    "Sort field."
    field: HostedJobPostsSortField! = DATE_CREATED
}

input IhpFindRecommendedJobsInput {
    after: String = ""
    first: Int = 10
    hostedStatus: [IhpHostedStatus!]
    searchTerms: IhpRecommendedJobSearchTermsInput
    sortBy: [IhpRecommendedJobSortByOption!]
}

input IhpIsRecommendedJobInput {
    dradisJobKey: ID
    jobKey: ID
}

input IhpRecommendedJobSearchTermsInput {
    country: String
    location: String
    title: String
}

"Apply by in-person."
input InPersonMethodInput {
    "Address of place to apply in-person"
    address: String!
    "Instructions for how to apply in-person"
    instructions: String
    "Latitude of place to apply in-person"
    latitude: Float
    "Longitude of place to apply in-person"
    longitude: Float
}

input IncludeAvailabilitySettingsInput {
    periods: [AvailabilityPeriodInput!]
    week: WeekAvailabilityRulesInput
}

"Constraints integer value. Applied with AND operator"
input IntValueConstraints {
    "Greater than"
    gt: Int
    "Greater than or equal"
    gte: Int
    "Less than"
    lt: Int
    "Less than or equal"
    lte: Int
}

input JobCampaignDetailsInput {
    adName: [String!]
    admin1: [String!]
    admin2: [String!]
    admin3: [String!]
    admin4: [String!]
    advertisementID: [String!]
    advertiserID: Int = 0
    aggJobID: [String!]
    city: [String!]
    country: [String!]
    dateRanges: [DateRangeInput!]!
    granularity: Granularity
    jobLocationID: [String!]
    jobType: SponsoredEvent = COMBINED
    limit: Int = 100
    measureFilters: [JobCampaignMeasureFilterInput!]
    normTitle: [String!]
    normTitleCategory: [String!]
    offset: Int = 0
    title: [String!]
}

" measure filter to be used in Job & Campaign scenarios "
input JobCampaignMeasureFilterInput {
    member: JobCampaignMeasureFilterMember!
    operator: MeasureFilterOperator
    value: Float!
}

input JobDataInput {
    """

    For each `JobDataInput` only one of `jobKeys` OR `jobs` can be set.
    If `jobKeys` is set: requests must include at least 1 jobKey and are limited to a maximum of 500
    """
    jobKeys: [ID!]
    """

    If `jobs` is set, requests must include at least one `JobDataKeyInput` and are limited to a maximum of
    500 `JobDataKeyInput`.
    """
    jobs: [JobDataKeyInput!]
}

input JobDataKeyInput {
    key: ID!
    trackingKey: String!
}

input JobLocale {
    country: CountryCode!
    language: LanguageCode!
}

"A job intended to have its match with a jobseeker evaluated"
input JobMatchInput {
    "The jobKey identifying the job holding these properties"
    key: ID!
    "The Properties associated with this job"
    properties: [RequirementsMatchPropertyInput!]!
}

input JobPostTaxonomyAttributeInput {
    """

    Text describing what the attribute represents. This may be the
    official taxonomy label or custom text.
    Required for all attribute types except for NONE.
    Limit of 255 characters.
    """
    label: String
    """

    The type of attribute being provided, which may be one of
    OFFICIAL, EXPERIMENTAL, OTHER, or NONE.
    """
    type: TaxonomyAttributeType!
    """

    The taxonomy identifier (UUID) for the attribute.
    Required for OFFICIAL and EXPERIMENTAL attribute types.
    """
    uuid: ID
}

"""

Input for patch update by Taxonomy Custom Class.
Slightly different from JobPostTaxonomyCustomClassAttributePatchInput which will be deprecated.
This input allows add/remove a full set of Taxonomy custom class and it's attributes. If a taxonomy attribute set
previously existed with same custom class UUID, the add operation will replace the existing set.
"""
input JobPostTaxonomyAttributesPatchByCustomClassInput {
    "Type of patch operation to apply to set."
    operation: PatchSetOperationType!
    "Value to ADD or REMOVE."
    value: JobPostTaxonomyCustomClassAttributesInput!
}

input JobPostTaxonomyCustomClassAttributeInput {
    "Taxonomy attribute associated with the custom class"
    attribute: JobPostTaxonomyAttributeInput!
    "The taxonomy identifier (UUID) for the custom class."
    customClassUuid: String!
}

input JobPostTaxonomyCustomClassAttributePatchInput {
    "Type of patch operation to apply to set."
    operation: PatchSetOperationType!
    "Value to ADD or REMOVE."
    value: JobPostTaxonomyCustomClassAttributeInput!
}

input JobPostTaxonomyCustomClassAttributesInput {
    "The set of taxonomy attributes associated with the custom class"
    attributes: [JobPostTaxonomyAttributeInput!]! = []
    "The taxonomy identifier (UUID) for the custom class."
    customClassUuid: String!
}

input JobSalaryInput {
    "Maximum amount in LOCAL MINOR CURRENCY"
    maximumMinor: Int
    "Minimum amount in LOCAL MINOR CURRENCY"
    minimumMinor: Int
    "Period to pay"
    period: JobSalaryPeriod!
}

"Note: currently we don't have any usage"
input JobSearchBooleanFilterInput {
    "Name of the field to filter jobs by"
    field: String!
    """

    Whether this boolean filter MUST or MUST NOT match. MUST is the positive filtering while MUST NOT is negative.
    Default is MUST.
    """
    match: JobSearchKeywordFilterMatch
}

"""

Defines an interval to request job counts for

**Warning:** invalid format of start/end values will result in a invalid request error
"""
input JobSearchDateFacetIntervalInput {
    """

    Specify the end (exclusive upper bound) of the interval. Format is "{number of days}d"

    Values are relative to now. For example "1d" represents exactly 24 hours before now.

    Value must be "newer" than that of `start` (e.g., if `start` is "7d" `end` must be at least "6d")

    **Examples:**
    - "1d"
    - "7d"
    - "14d"

    **Default:** null (aka "now", "0d")
    """
    end: String
    "Label to be used in `JobSearchDateFacet` related response (e.g., \"Last Day\", \"Last 3 Days\", \"LAST_DAY\")"
    label: String!
    """

    Specify the start (inclusive lower bound) of the interval. Format is "{number of days}d"

    Values are relative to now. For example "1d" represents exactly 24 hours before now.

    Value must be "older" than that of `end` (e.g., if `end` is "7d" `start` must be at least "8d")

    **Examples:**
    - "1d"
    - "7d"
    - "14d"

    **Default:** null (aka "beginning of time")
    """
    start: String
}

"""

Filter jobSearch results via date fields.

Supported fields:
- dateOnIndeed

**Example:**

Search for jobs that are between 7 and 1 days old.

```
filters: [
{
date: {
field: "dateOnIndeed",
start: "7d",
end:   "1d"
}
}
]
```
"""
input JobSearchDateRangeFilterInput {
    "See `JobSearchDateFacetIntervalInput.end` for details"
    end: String
    field: String!
    "See `JobSearchDateFacetIntervalInput.start` for details"
    start: String
}

"""

**Examples:**

```
{
jobSearch (
filters: [
{
date: {
field: "dateOnIndeed",
start: "7d",
end: "1d"
}
}
{
range: {
field: "salary",
min:  50000,
max: 100000
}
}
{
keyword: {
field: "language",
keys: [ "en", "fr" ]
operation: OR
}
}
{
floatRange: {
field: "glassdoor.employerRating",
min: 1.5,
max: 4.0
}
}
]
) {
results {
job {
key
dateOnIndeed
compensation {
formattedText
}
}
}
}
}
```

For each `JobSearchFilterInput` instance ONLY ONE of `date`, `range`, or `keyword` must be set. See examples aboves.
"""
input JobSearchFilterInput {
    date: JobSearchDateRangeFilterInput
    floatRange: JobSearchFloatRangeFilterInput
    keyword: JobSearchKeywordFilterInput
    range: JobSearchRangeFilterInput
    tag: JobSearchBooleanFilterInput
}

"""

Detail of each float range filter.

|Field|Expected values of min and max|
|-|-|
|glassdoor.employerRating|Glassdoor's employer rating field|

**Example:**

Search for jobs with Glassdoor employer rating between 1.5 and 4.0

```
filters: [
{
floatRange: {
field: "glassdoor.employerRating",
min: 1.5,
max: 4.0
}
}
]
```
"""
input JobSearchFloatRangeFilterInput {
    "Name of the field to filter jobs by"
    field: String!
    """

    The maximum value of this range (exclusive upper bound). Default is positive infinity

    Value must be larger than `min`
    """
    max: Float
    """

    The minimum value of this range (inclusive lower bound). Default is -2^63

    Value must be smaller than `max`
    """
    min: Float
}

input JobSearchGroupingInput {
    """

    This is an opaque string used to focus on a particular grouping of the type specified above.

    See `JobSearchResultGroup.key`
    """
    key: String
    """

    The type of grouping to execute.
    When `key` is provided, `type` should be the same as the previous request or set to NONE to get all results.
    """
    type: JobSearchResultGroupByRelation!
}

"""

Detail of each keyword filter.

|Field|Expected format of keys|
|-|-|
|indeedEmployerKey|The same format as `Employer/key`|
|language|[ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code|
|normalizedCategory|Normalized title category string. See JRS-138.|
|normalizedTitle|Normalized title string. See JRS-138.|
|occupations|UUID or SUID|
|attributes|UUID or SUID|
|indeedApplyScope|Names in `enum JobIndeedApplyScope`. A request containing multiple keyword filters of this field is prohibited.|
|jobKey|The same format as `Job/key`|
|location.city|Combination of admin codes and city formatted by location.city facets|
|companySectors|SUID|
|sourceType|One of `EMPLOYER`, `JOB_BOARD`, or `RECRUITER`|
|glassdoor.employerKey|Glassdoor employer key|
|glassdoor.industryKey|Glassdoor industry key|
|glassdoor.divisionKey|Glassdoor division key|
|glassdoor.sGocKey|Glassdoor sGoc key|
|glassdoor.cityKey|Glassdoor city key|
|glassdoor.seniorityKey|Glassdoor seniority key|

**Example:**
```
filters: [
{
keyword: {
field: "language",
keys: ["en", "fr"],
operation: OR
match: MUST_NOT
}
}
]
```
"""
input JobSearchKeywordFilterInput {
    "Name of the field to filter jobs by"
    field: String!
    "Keys to filter jobs by"
    keys: [String!]!
    "Whether this filter MUST or MUST NOT match the jobs. Default is MUST."
    match: JobSearchKeywordFilterMatch
    "The way of joining multiple `keywords`. Default is AND."
    operation: JobSearchKeywordFilterOperation
}

input JobSearchLocationInput {
    """

    Distance from the search location (point-to-point aerial transit path, or "as the bird flies").

    Setting radius to 0 will perform an "exact match" location search which will only return job which have the exact
    location and not surrounding locations.

    **Note:** radius may not be applied to all search locations. For example a state level search will only match jobs
    within that state and not expand to surrounding states.
    """
    radius: Int!
    radiusUnit: JobSearchDistanceUnit!
    """

    Location name.
    Use a postal code or a "city, state/province/region" combination or a "latitude, longitude" combination.
    Location will be resolved based on country of search.

    **Examples:**
    - "Austin, TX"
    - "Texas"
    - "90210"
    - "30.26715, -97.74306"
    """
    where: String!
}

"The common input for range facet."
input JobSearchRangeFacetInput {
    label: String!
    """

    The maximum value of this range (exclusive upper bound).
    Value must be larger than `min`
    """
    max: Int
    """

    The minimum value of this range (inclusive lower bound).
    Value must be smaller than `max`
    """
    min: Int
}

"""

Detail of each range filter.

|Field|Expected values of min and max|
|-|-|
|companyHeadcount|Represents the number of employees of the company. Only supported in Japan, i.e., co=JP.|
|dateOnIndeed|Epoch time in milliseconds. See also date filter |
|requiredExperienceMonths|The number of months. Only supported in India, i.e., co=IN.|
|compensation.baseAnnualSalary|Best available salary for this job measured in local currency (e.g., USD in US, JPY in JP), sourced from extracted salary, estimated salary or override values|
|salary|Deprecated. Use `compensation.baseAnnualSalary` instead.|
|glassdoor.employeeCount|Glassdoor employee count|
|glassdoor.compensation.baseAnnualSalary|Glassdoor base annual salary, sourced from Glassdoor job enrichment service|
|glassdoor.combinedCompensation.baseAnnualSalary|Combined (Indeed/Glassdoor) base annual salary, sourced from salary override, Indeed extracted salary, Indeed estimated salary, or Glassdoor job enrichment service|

**Example:**

Search for jobs with base annual salary between $50,000 and $100,000 (co=US)

```
filters: [
{
range: {
field: "compensation.baseAnnualSalary",
min: 50000,
max: 100000
}
}
]
```
"""
input JobSearchRangeFilterInput {
    "Name of the field to filter jobs by"
    field: String!
    """

    The maximum value of this range (exclusive upper bound). Default is positive infinity

    Value must be larger than `min`
    """
    max: Long
    """

    The minimum value of this range (inclusive lower bound). Default is -2^63

    Value must be smaller than `max`
    """
    min: Long
}

"A jobseeker intended to have its match with a job evaluated"
input JobSeekerMatchInput {
    "The Properties associated with this job"
    properties: [RequirementsMatchPropertyInput!]!
}

input JobSeekerProfileContactInformationInput {
    "A Job Seeker's first name"
    firstName: String
    "A Job Seeker's last name"
    lastName: String
    "A Job Seeker's location"
    location: JobSeekerProfileLocationTypeInput
    "A Job Seeker's phone Number"
    phoneNumber: String
}

input JobSeekerProfileDateRangeInput {
    "The start point of the date range"
    fromDate: JobSeekerProfileDateTypeInput
    "The flag that indicates if the date range is ongoing. If True, then the value of toDate will be ignored."
    isCurrent: Boolean
    "The end point of the date range"
    toDate: JobSeekerProfileDateTypeInput
}

input JobSeekerProfileDateTypeInput {
    "The month of the date type"
    month: JobSeekerProfileMonthType
    "The year of the date type"
    year: Int
}

input JobSeekerProfileDefaultInfoInput {
    "A Job Seeker's contactInformation"
    contactInformation: JobSeekerProfileContactInformationInput
}

input JobSeekerProfileInput {
    "Whether a job seeker is available immediately to work"
    availableImmediately: Boolean
    "A Job Seeker's default contact information; is only used when resume does not exist"
    defaultInfo: JobSeekerProfileDefaultInfoInput
}

input JobSeekerProfileLanguageSkillInput {
    "The language of the language skill (e.g. English)"
    language: String!
    "The language SUID of the language skill (e.g. D866K)"
    languageTaxonomyId: String
    "The proficiency of the language skill (e.g. Beginner)"
    proficiency: String!
    "The proficiency SUID of the language skill (e.g. 5VATV)"
    proficiencyTaxonomyId: String
}

input JobSeekerProfileLanguageSkillUpdateInput {
    "The language skill to be updated"
    languageSkill: JobSeekerProfileLanguageSkillInput!
    "The previous language before the update (e.g. English). This acts as the language 'id'."
    previousLanguage: String!
}

input JobSeekerProfileLinkInput {
    "Link id in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    id: ID!
    "Links on a job seeker's resume"
    link: String
}

input JobSeekerProfileLocationTypeInput {
    "A Job Seeker's address"
    address: String
    "A Job Seeker's address line 2"
    address2: String
    "A Job Seeker's admin1"
    admin1: String
    "A Job Seeker's admin2"
    admin2: String
    "A Job Seeker's admin3"
    admin3: String
    "A Job Seeker's admin4"
    admin4: String
    "A Job Seeker's city"
    city: String
    "A Job Seeker's country"
    country: String
    "A Job Seeker's geocode precision"
    geocodePrecision: JobSeekerProfileGeocodePrecision
    "A Job Seeker's latitude"
    latitude: Float
    "A Job Seeker's default location"
    location: String
    "A Job Seeker's longitude"
    longitude: Float
    "A Job Seeker's postal code"
    postalCode: String
    "A Job Seeker's state"
    state: String
    "A Job Seeker's unknownLocation. An example values is \"Albany, New York\". The location geocoder service will attempt to extract admin1, admin2, admin3, admin4, city, country, lattitude, longitude, and geocode precision from this field."
    unknownLocation: String
}

input JobSeekerProfileResumeInput {
    "Additional info about the resume, added by the Job Seeker"
    additionalInfo: String
    "A Job Seeker's first name"
    firstName: String
    "A Job Seeker's resume id in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    id: ID!
    "A Job Seeker's last name"
    lastName: String
    "A Job Seeker's location"
    location: JobSeekerProfileLocationTypeInput
    "A Job Seeker's phone Number"
    phoneNumber: String
    "A Job Seeker's resume type, e.g. PARSED, INDEED_RESUME."
    resumeType: JobSeekerProfileResumeType
    "A Job Seeker's choice to make phone Number public"
    showPhoneNumber: Boolean
    "A Job Seeker's state / privacy setting, e.g. PUBLIC, HIDDEN."
    state: JobSeekerProfileResumeState
}

input JobSeekerProfileSectionIdsInput {
    "The section id of the SectionIds"
    sectionId: ID!
}

input JobSeekerProfileStructuredDataCompanyInput {
    "Company FCC ID."
    companyFccId: Int!
    "Company name."
    companyName: String
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
}

input JobSeekerProfileStructuredDataCompanySectorInput {
    "Company Sector data from taxonomyConcept."
    companySectorTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
}

input JobSeekerProfileStructuredDataInput {
    " We don't need accountId, ctk and co from client, instead, get them from gateway"
    email: String
    emailHash: String
    queryFilter: JobSeekerProfileStructuredDataQueryFilterInput
    rezId: ID
}

input JobSeekerProfileStructuredDataJobTitleInput {
    "Job title."
    jobTitle: String!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
}

input JobSeekerProfileStructuredDataJobTypeInput {
    "Job type."
    jobType: JobSeekerProfileStructuredDataJobTypeEnum
    "Job type taxonomy fields"
    jobTypeTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
}

input JobSeekerProfileStructuredDataLocationInput {
    "Street Address."
    address: String
    "Admin 1."
    admin1: String
    "Admin 2."
    admin2: String
    "Admin 3."
    admin3: String
    "Admin 4."
    admin4: String
    "City."
    city: String
    "Country."
    country: String
    "Location Geohash."
    geoHash: String
    "Location Latitude."
    latitude: Float
    "Show how accurate lat/lng has been calculated."
    latlngPrecision: JobSeekerProfileStructuredDataLatLngPrecision
    "Location Longtitude."
    longitude: Float
    "Postal Code."
    postalCode: String
    "Location Raw."
    raw: String
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Weight of data (coming from niffler, disregard from other producers)."
    weight: Float
}

input JobSeekerProfileStructuredDataOccupationInput {
    "Occupation data from taxonomyConcept."
    occupationTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
}

input JobSeekerProfileStructuredDataQueryFilterInput {
    "Filter by JobSeekerProfileStructuredDataDataCategory"
    dataCategory: JobSeekerProfileStructuredDataDataCategory
}

input JobSeekerProfileStructuredDataRemoteWorkTypeInput {
    "Remote work type taxonomy fields"
    remoteWorkTypeTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput!
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
}

input JobSeekerProfileStructuredDataSalaryInput {
    "Salary amount."
    amount: Float!
    "Salary currency."
    currency: String!
    "Salary type."
    salaryType: JobSeekerProfileStructuredDataSalaryType!
}

input JobSeekerProfileStructuredDataShiftInput {
    "JobSeekerProfileStructuredDataSentiment from user if confirm/deny."
    sentiment: JobSeekerProfileStructuredDataSentiment!
    "Shift data from taxonomyConcept."
    shiftTaxonomyConcept: JobSeekerProfileStructuredDataTaxonomyConceptInput!
}

input JobSeekerProfileStructuredDataTaxonomyConceptInput {
    "Label provided from taxonomyConcept."
    label: String!
    """

    Short TaxonomyConcept Id/Rosetta Id
    example: W3WGD
    """
    suid: String
    "Type provided from taxonomyConcept."
    type: String
    """

    Long TaxonomyConcept Id/Rosetta Id.
    example: e76aac9a-1ee7-46cf-969e-683f01571cbd
    """
    uuid: String
}

input JobTitleAndLocation {
    jobTitle: String
    location: String
}

input JobTypePatchInput {
    "Type of patch operation to apply to set."
    operation: PatchSetOperationType!
    "Value to ADD or REMOVE."
    value: JobType!
}

input JobUpdateInput {
    """

    An optional list of country codes. If it is non-empty, the job updates are filtered by the given country codes.
    In other words, every job in other countries is regarded as inactive.
    """
    countryCodes: [String!]! = []
    "The same string as `pageInfo/endCursor` in the previous response."
    cursor: String!
    "The maximum number of jobs in a single response. This must be between 1 and 5,000, inclusive."
    maxNumJobs: Int! = 2000
}

"Simple string-based key-value pair input."
input KeyValuePairInput {
    "Key for attribute pair"
    key: String!
    "Value for attribute pair"
    value: String!
}

input KeyValuePairPatchInput {
    "Type of patch operation to apply to set."
    operation: PatchSetOperationType!
    "Value to ADD or REMOVE. Removal is by key."
    value: KeyValuePairInput!
}

input MarketInsightsInput {
    "CountryCode for the job location."
    countryCode: CountryCode!
    "Location of the job."
    jobLocation: String
    "Title of the job."
    jobTitle: String
    "LanguageCode for the job."
    languageCode: LanguageCode!
}

input MicrocontentFilterInput {
    "Normalized job title in correct display locale"
    normalizedJobTitle: String
    "Job location in short display format (e.g. for US address, no zip code: San Francisco, CA)"
    shortFormattedLocation: String
}

input MosaicProviderInput {
    "Host id from mosaic"
    hostId: String!
    "Page id from mosaic"
    pageId: String!
    "Provider id from mosaic"
    providerId: String!
}

"Name input for VerificationInfoInput"
input NameInput {
    "First name"
    first: String
    "Last name"
    last: String
}

input NumJobPerCampaignInput {
    advertisementID: [String!]!
    advertiserID: Int = 0
    dateRanges: [DateRangeInput!]!
    jobType: SponsoredEvent = COMBINED
}

input OffsiteCtkDeviceIdMapInput {
    ctk: ID!
    externalId: ID!
    externalIdType: OffsiteDeviceIdEnum!
}

input OffsiteDeviceIdOptOutInput {
    externalId: ID!
}

input OptimizationsInput {
    "The Id of the Advertiser to return optimizations for"
    advertiserId: ID!
    "The job id we want to return optimizations for."
    jobId: String!
}

input PagingParams {
    "The max number of items to return"
    limit: Int!
    "The number of items to skip"
    offset: Int
}

"""

Parse resume file previously saved to Job Seeker's profile if input provided
otherwise parse most recently uploaded file
"""
input ParseJobSeekerProfileFileInput {
    """

    geoCountry code from indeed website country
    example : US
    """
    geoCountry: String!
    "File id"
    id: ID!
    """

    ipCountry code resolved from ipAddress
    example : US
    """
    ipCountry: String!
}

"Input to patchDraftJobPost"
input PatchDraftJobPostInput {
    "The ID of the existing Draft Job Post to update"
    id: ID!
    "The patch"
    patch: DraftJobPostPatchInput!
}

"Input to createHostedEmployer"
input PatchHostedEmployerInput {
    "The hosted employer ID to update"
    id: ID!
    "The new HostedEmployer"
    patch: HostedEmployerPatchInput!
}

"Input to patchHostedJobPost"
input PatchHostedJobPostInput {
    "The ID of the existing Hosted Job Post to update"
    id: ID!
    "The patch"
    patch: HostedJobPostPatchInput!
}

input PublishDraftJobPostInput {
    "Unique Job ID"
    id: ID!
}

input RatingHistogramFilterInput {
    location: RatingLocation
    normalizedJobTitle: String
}

input RatingLocation {
    country: String!
    shortFormattedLocation: String
}

input RatingsFilterInput {
    location: RatingLocation
    normalizedJobTitle: String
}

input RecommendationsInput {
    "The Id of the Advertiser to return recommendations for"
    advertiserId: ID!
    "Limit the range of recommendation types which will be queried for, including special categories \"All\" and \"Dismissed\""
    filter: RecommendationFilter
    """

    [skip] represents the start index of the elements that is expected to be shown.
    For example, if the first 60 elements are previously shown to a user and it is planned to show the 61st element,
    the [skip] value 60 will tell the engine that it should start with the item index 60, which is the 61st element in 0-based numbering.
    """
    skip: Int
    "How many elements should be published in the response."
    take: Int
}

input RecordApplyStartInput {
    "Job Result Tracking Key for the job for which the apply process was started."
    jobResultTrackingKey: ID!
}

input RecordCandidateContactInput {
    contactMethod: ContactMethod
    jobKey: String
}

input RecordCandidateUpdateInput {
    jobKey: String
    newSentiment: CandidateSentiment
    newStatus: CandidateStatus
    oldSentiment: CandidateSentiment
    oldStatus: CandidateStatus
}

input RecordCandidateViewInput {
    jobKey: String
    viewContent: ViewContent!
}

input RecordHomepageJobSeenAdditionalInfoInput {
    "ClientSideTk, generated from homepageTrackingKey and other client side information like PageLoadedTimeMillis"
    clientSideTk: String!
    """

    This is a parallel array with the jobResultTrackingKeys array of RecordJobSeenInput
    Each value is a feed TK for the corresponding job
    """
    feedTks: [String!]!
    "Tracking key for homepage"
    homepageTrackingKey: String!
    "If the job seen info is associated with desktop homepage or not"
    isDesktopRequest: Boolean!
    """

    This is a parallel array with the jobResultTrackingKeys array of RecordJobSeenInput
    Each value indicates if the corresponding job is sponsored
    """
    isSponsored: [Boolean!]!
}

input RecordJavascriptDetectionInput {
    jobSearchTrackingKey: String
}

input RecordJobClickInput {
    "Clicked Job Result Tracking Key"
    jobResultTrackingKey: ID!
}

input RecordJobDataResultsShownInput {
    "The tracking keys for the jobs that were shown - expected to be encoded with type information"
    trackingKeys: [ID!]!
}

input RecordJobSearchResultsShownInput {
    """

    List of custom fields that is allowed by the UIL Allow List.
    If UserInteractionCustomLogField.Name does not match entry in allow list, an error will be thrown and the operation will fail.
    """
    customFields: [UserInteractionCustomLogField!]
    "List of jobs shown referenced by their jobResultTrackingKey."
    jobResultTrackingKeys: [ID!]!
}

input RecordJobSeenAdditionalInfoInput {
    "Additional information for job seen event on homepage"
    homepageFields: RecordHomepageJobSeenAdditionalInfoInput
}

input RecordJobSeenInput {
    "Additional information for job seen event on different pages like homepage, serp, etc"
    additionalInfo: RecordJobSeenAdditionalInfoInput
    "List of Job Result Tracking Keys that have been seen by jobseeker."
    jobResultTrackingKeys: [ID!]!
}

input RecordMosaicOptOutInput {
    "The timestamp in milliseconds since epoch of when to expire the opt out"
    expiration: Timestamp
    mosaicProviderInput: MosaicProviderInput!
    "The tracking key of the page that loaded the provider"
    trackingKey: ID!
    "The name of the page associated with the trackingKey"
    trackingKeyType: MosaicOptOutTrackingKeyType!
}

"Input object with data required to record a user interaction (Content Shown/Content Seen)"
input RecordMultipleTargetedContentUserInteractionsInput {
    "Indeed UID, Content Ids sent back by the find content endpoint"
    contentTks: [ID!]!
    """

    List of custom fields that is allowed by the Targeted Content UIL Allow List.

    If TargetedContentUserInteractionCustomLogField.Name does not match entry in allow list,
    an error will be thrown and the operation will fail.
    """
    customLoggingFields: [TargetedContentUserInteractionCustomLogField!]
}

"Input object with data required to record a user interaction (Content Click/Content Close)"
input RecordSingleTargetedContentUserInteractionInput {
    "Indeed UID, Content Ids sent back by the find content endpoint"
    contentTk: ID!
    """

    List of custom fields that is allowed by the Targeted Content UIL Allow List.

    If TargetedContentUserInteractionCustomLogField.Name does not match entry in allow list,
    an error will be thrown and the operation will fail.
    """
    customLoggingFields: [TargetedContentUserInteractionCustomLogField!]
}

input RelatedTaxonomyConceptsInput {
    "Concept's UUID or SUID"
    conceptId: ID
    "A 2-character country code. The value is encoded as an ISO_3166-1 - alpha 2 formatted string"
    countryCode: CountryCode
    "Use this field to only keep TaxonomyConcepts belonging to the CustomClasses."
    customClassId: ID
    "A 2-character language code. The value is encoded as an ISO_639 formatted string"
    languageCode: LanguageCode
    """

    You can specify the UUID or SUID of a custom relation (See
    https://wiki.indeed.com/display/MetadataTaxonomy/Custom+Relations to know the available
    custom relation list)
    """
    relationshipId: ID!
}

input RemoveAvailabilityPeriodsInput {
    "Ids of availability periods to remove."
    keys: [String!]!
    "ID of the [AvailabilityResource] to remove availability periods from."
    resourceId: ID
}

input RemoveJobSeekerProfileStructuredDataPreferenceInput {
    "Preference Id."
    id: ID!
}

input RemoveUDPConfirmedSectionsInput {
    confirmedSections: [String!]! = []
}

input RemoveUDPSkippedQuestionsInput {
    skippedQuestionIds: [String!]! = []
}

input RemoveUserDisplayPreferenceInput {
    accountId: Int!
}

input ReplaceFieldsJobSeekerProfileStructuredDataDislikedPreferenceInput {
    "List of disliked companies."
    companies: [JobSeekerProfileStructuredDataCompanyInput!]
    "List of disliked company sectors."
    companySectors: [JobSeekerProfileStructuredDataCompanySectorInput!]
    "List of disliked job titles."
    jobTitles: [JobSeekerProfileStructuredDataJobTitleInput!]
    "List of disliked job types."
    jobTypes: [JobSeekerProfileStructuredDataJobTypeInput!]
    "List of locations that user will prefer not to work at."
    locations: [JobSeekerProfileStructuredDataLocationInput!]
    "List of disliked occupations."
    occupations: [JobSeekerProfileStructuredDataOccupationInput!]
    "List of disliked remote/In person work types."
    remoteWorkTypes: [JobSeekerProfileStructuredDataRemoteWorkTypeInput!]
    "Salary Input."
    salary: JobSeekerProfileStructuredDataSalaryInput
    "List of disliked shifts."
    shifts: [JobSeekerProfileStructuredDataShiftInput!]
}

"An input for retrieving the RequirementMatchPayload between a jobseeker and a list of jobs"
input RequirementMatchInput {
    jobSeeker: JobSeekerMatchInput!
    "Requests must include at least 1 job and are limited to a maximum of 500"
    jobs: [JobMatchInput!]!
}

"An input type to represent properties to be matched as part of a RequirementsMatch"
input RequirementsMatchPropertyInput {
    "The id of the attribute associated with this property"
    attributeId: ID!
}

input ResourceAvailabilitySettingsInput {
    "Settings that specify time the resource is explicitly unavailable."
    exclude: ExcludeAvailabilitySettingsInput
    "Settings that specify time the resource is potentially available."
    include: IncludeAvailabilitySettingsInput
    "Window in the future that events can be scheduled on the resource."
    window: AvailabilityWindowInput
}

"All filter constraints are applied with AND logic"
input ReviewFilterParams {
    "Filter reviews for particular country code, e.g. 'US'"
    country: String
    "Filter reviews by creation times. ISO 8601 formatted time"
    createdDateAfter: String
    """

    Review IDs to exclude from result

    *Deprecated:* Review IDs are for internal use only. Use field `excludedKeys` instead.
    """
    excludedIds: [Int]
    "Review keys to exclude from result"
    excludedKeys: [ID]
    """

    Include only reviews with particular ID

    *Deprecated:* Review IDs are for internal use only. Use field `keys` instead.
    """
    ids: [Int]
    "Job title constraints are applied with OR logic"
    jobFilters: [ReviewJobParams]
    "Include only reviews with particular keys"
    keys: [ID]
    "Filter reviews for particular language code, e.g. 'en'"
    language: String
    "Field needs to represent normalized location otherwise might not find anything US examples: \"Austin, TX\", \"Texas\". Location constraints are applied with OR logic"
    locations: [String]
    "Constraints for overall rating value. Constraints are applied with OR logic"
    ratingConstraints: [IntValueConstraints]
    "Redacted reviews contain only ratings. Set this to be true to return their original content. By default it is false"
    showRedactedContent: Boolean
    "Return reviews associated with provided `ReviewTopic`"
    topic: ReviewTopic
}

"Parameters of reviewed job. If both are defined, they are applied with AND logic"
input ReviewJobParams {
    "Review job's category."
    category: String
    "Reviewed job's title"
    title: String
}

"""

Sorts are applied one after another. Some example, sort by rating, among same rating sort by date:
`[(OVERALL_RATING, DESC), (REVIEW_DATE, DESC)]`
"""
input ReviewSortParams {
    "Ascending or Descending value order"
    order: SortOrder
    "Specify by what value reviews should be sorted"
    type: ReviewSortType
}

input SalaryFormatForLocaleInput {
    locale: JobLocale!
}

input SalaryInput {
    jobTitle: String
    key: ID
    "Location in specific format(e.g. US, US/TX or US/TX/Austin). This field is required at least country level"
    location: String
    minCountForTimeRange: Int
    useLatestTimeRange: Boolean
}

input SavedJobPaging {
    "The number of items to retrieve. Defaults to 100 if no value is provided."
    limit: Int
    "The page token for the page to retrieve."
    pageToken: String
}

" arguments for spend views "
input SpendInput {
    advertiserID: Int = 0
    dateRanges: [DateRangeInput!]!
    jobType: SponsoredEvent = SPONSORED
    limit: Int = 100
    orderBy: SpendOrderBy = CTR
    orderDirection: OrderDirection = ASC
}

input StoreAnswerInput {
    accountKey: String
    answerEntities: [AnswerEntityInput!]!
    applyJobId: String!
    ctk: String!
    jobCountry: String!
}

input SuggestCompanyAutofillInput {
    """

    An optional company name to help guess the segment, websiteUrl, industry etc.
    If not provided, we rely on emailDomain/country (user provided or from user auth)
    """
    companyName: String
    """

    An optional country to be paired wih companyName/emailDomain to help fetch the company details.
    If not provided, we will extract country from user locale after successful authentication.
    """
    country: String
    """

    An optional email domain to help guess the segment, websiteUrl, industry.
    If not provided, we will extract email domain from user's email after successful authentication.
    """
    emailDomain: String
    """

    An optional lang to be paired wih companyName to help fetch the company details.
    If not provided, we will extract lang from user locale after successful authentication.
    """
    lang: String
}

"Filters used by ITA for generating better targeted content"
input TargetedContentITAFilters {
    """

    Cookie value for Branded Ad History

    Accessible via __BRANDED_HISTORY__ Cookie in browser
    """
    brandedAdHistory: String = ""
    """

    Recently clicked organic job ids

    Accessible via __RSJC__ Cookie in browser (colon seperated values)
    """
    clickedOrganicJobIds: [String!] = []
    """

    Cookie value for Ad History

    Accessible via __ITAHISTORY__ Cookie in browser
    """
    itaAdHistory: String = ""
}

"""

Content metadata (e.g. tags)
e.g [TargetedContentMetadata!]
[
{type: OCCUPATION, value: "Nurse", metadataKeyType: "SUID", metadataKey: "<suid>"},
{type: JOB_TITLE, value: "job", metadataKeyType: "SUID", metadataKey: ""},
{type: INDUSTRY, value: "health", metadataKeyType: "SUID", metadataKey: ""},
...
]
"""
input TargetedContentMetadata {
    "Metadata Key Value (e.g suid value for occupation tag)"
    metadataKey: ID = ""
    "Metadata Key Type (e.g suid for occupation tag)"
    metadataKeyType: String = "SUID"
    """

    Type will be used to know how to treat and validate the value being passed
    Only types listed in the enum will be allowed to be passed through
    """
    type: TargetedContentMetadataType! = OCCUPATION
    "Value of the metadata"
    value: String = ""
}

"""

Text override per TargetedContentType

If the override field is empty or blank then that input will be ignored
"""
input TargetedContentTextOverride {
    """

    Override to use for the contentInHtml field in the result

    If absent or blank, the override will be skipped
    and content from the API will be applied
    """
    contentInHtmlOverride: String = ""
    """

    Override to use for the go text field in the result

    If absent or blank, the override will be skipped
    and content from the API will be applied
    """
    goTextOverride: String = ""
    "Overrides will be applied to this content type"
    promoType: TargetedContentType = RESUME_REVIEW
    """

    Override to use for the title text field in the result

    If absent or blank, the override will be skipped
    and content from the API will be applied
    """
    titleOverride: String = ""
}

"Only a single value field will be used as the value for this custom field. The value will be decided by the type field."
input TargetedContentUserInteractionCustomLogField {
    "Boolean Value should be populated if type=BOOLEAN"
    booleanValue: Boolean
    "Float Value should be populated if type=FLOAT"
    floatValue: Float
    "Int Value should be populated if type=INT"
    intValue: Int
    "Name of the custom field that will be logged in logrepo"
    name: String!
    "String Value should be populated if type=STRING"
    stringValue: String
    "Type will be used to know how to treat and validate the value being passed"
    type: TargetedContentUserInteractionCustomLogFieldType!
}

input TaxonomyConceptsInput {
    """

    Filter by Taxonomy Concepts UUIDs or SUIDs, both are supported.
    Leave it as empty if unnecessary.
    """
    conceptIdFilter: [ID!]!
    """

    Filter by TaxoomyConceptType that clients are requesting, e.g. ATTRIBUTE, OCCUPATION.
    Leave it as empty if unnecessary.
    """
    conceptTypeFilter: TaxonomyConceptType
    "A 2-character country code. The value is encoded as an ISO_3166-1 - alpha 2 formatted string"
    countryCode: CountryCode
    """

    Filter by CustomClasses.
    Leave it as empty if unnecessary.
    """
    customClassFilter: CustomClassFilterInput!
    "Set to true to keep TaxonomyConcepts that apply Internationally."
    global: Boolean = false
    "A 2-character language code. The value is encoded as an ISO_639 formatted string"
    languageCode: LanguageCode
}

"Parameter for the `unhighlight review` mutation"
input UnhighlightReviewInput {
    countryCode: String!
    employerKey: String!
    languageCode: String!
}

input UpdateAvailabilityResourceInput {
    "If not null, updates to apply to default resource availability rules."
    availabilitySettings: ResourceAvailabilitySettingsInput
    id: ID!
}

" Input type for updateCurrentLanguage "
input UpdateCurrentLanguageInput {
    " The new language to use.  It must be one of the available languages. "
    language: LanguageCode!
}

"Input to updateDraftJobPost"
input UpdateDraftJobPostInput {
    "The globally unique UUID"
    id: ID!
    "Replace with this DraftJobPost"
    update: DraftJobPostCreateUpdateInput!
}

"Input for award to be updated"
input UpdateJobSeekerProfileAwardInput {
    "The day the award was won, e.g. January of 2021"
    date: JobSeekerProfileDateTypeInput
    "A Job Seeker's award description, e.g. \"Award for the best programmer, is an award that is given in Indeed to the best programmer.\""
    description: String
    "A Job Seeker's award ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    id: ID!
    "A Job Seeker's award title, e.g. \"The best programmer award\""
    title: String!
}

input UpdateJobSeekerProfileCertificationInput {
    "The date range of the certification"
    dateRange: JobSeekerProfileDateRangeInput
    "The description of the certification"
    description: String
    "A Job Seeker's resume certification id in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    id: ID!
    "The taxonomy concept of the certification"
    taxonomyConceptTitle: UpdateJobSeekerProfileTaxonomyConceptInput
    "The title of the certification"
    title: String
}

"Input for updaing Job Seeker's company sector"
input UpdateJobSeekerProfileCompanySectorInput {
    "company sector name"
    name: String
    "company sector name taxonomy concept"
    taxonomyConceptName: UpdateJobSeekerProfileTaxonomyConceptInput
}

"Job seeker profile degree input to be updated."
input UpdateJobSeekerProfileDegreeInput {
    "The degree name"
    degreeName: String
    "The degree field e.g. Biology, Computer Science"
    field: String
    "The degree ID"
    id: ID!
    "The taxonomy concepts for degree"
    taxonomyConceptDegree: UpdateJobSeekerProfileTaxonomyConceptInput
    "The taxonomy concepts for degree's field"
    taxonomyConceptField: UpdateJobSeekerProfileTaxonomyConceptInput
}

"A Job Seeker's education details input to be updated."
input UpdateJobSeekerProfileEducationInput {
    "The date range of the certification"
    dateRange: JobSeekerProfileDateRangeInput
    "The degrees details of the education"
    degree: UpdateJobSeekerProfileDegreeInput
    "The education ID"
    id: ID!
    "The location where the degrees was obtained"
    location: JobSeekerProfileLocationTypeInput
    "The school in which the degree was obtained"
    school: String
}

input UpdateJobSeekerProfileInput {
    "Profile of the jobseeker"
    profile: JobSeekerProfileInput!
}

input UpdateJobSeekerProfileLinkInput {
    "Link id in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    id: ID!
    "Links on a job seeker's resume"
    link: String
}

"Input that includes awards to be updated"
input UpdateJobSeekerProfileResumeAwardsInput {
    "List of award items with fields to update"
    awards: [UpdateJobSeekerProfileAwardInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input UpdateJobSeekerProfileResumeCertificationsInput {
    "List of certifications"
    certifications: [UpdateJobSeekerProfileCertificationInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

"A Job Seeker's education details input to be updated."
input UpdateJobSeekerProfileResumeEducationsInput {
    "List of language skills"
    educations: [UpdateJobSeekerProfileEducationInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input UpdateJobSeekerProfileResumeInput {
    "Resume of the jobseeker"
    resume: JobSeekerProfileResumeInput!
}

"Language section"
input UpdateJobSeekerProfileResumeLanguageSkillsInput {
    "List of language skills"
    languageSkills: [JobSeekerProfileLanguageSkillUpdateInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input UpdateJobSeekerProfileResumeLinksInput {
    "Links on this job seeker's resume"
    links: [UpdateJobSeekerProfileLinkInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input UpdateJobSeekerProfileResumeMilitaryInput {
    "List of military items to be added"
    military: [UpdateJobSeekerProfileResumeMilitaryItemInput!]!
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
}

input UpdateJobSeekerProfileResumeMilitaryItemInput {
    "Branch"
    branch: String
    "Military service commendations"
    commendations: String
    "Military service country"
    country: String
    "Military service period"
    dateRange: JobSeekerProfileDateRangeInput
    "Description for military service"
    description: String
    "A Job Seeker's military id in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    id: ID!
    "Military rank"
    rank: String
    "Military service code"
    serviceCode: String
}

input UpdateJobSeekerProfileResumeSkillsInput {
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
    "List of skills"
    skills: [UpdateJobSeekerProfileSkillInput!]!
}

"Input that includes work experiences to be updated"
input UpdateJobSeekerProfileResumeWorkExperiencesInput {
    "A Job Seeker's resume ID in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    resumeId: ID!
    "List of work experience items with fields to update"
    workExperiences: [UpdateJobSeekerProfileWorkExperienceInput!]!
}

input UpdateJobSeekerProfileSkillInput {
    "The experience time, the number of the TimeUnit e.g. 10 of 10 years"
    experience: Int64
    "The skill ID"
    id: ID!
    "The the taxonomy concept object"
    taxonomyConceptTitle: UpdateJobSeekerProfileTaxonomyConceptInput
    "Description"
    text: String
    "The experience time unit"
    timeUnit: JobSeekerProfileTypeUnit
}

input UpdateJobSeekerProfileStructuredDataPreferenceInput {
    "Show if user is willing to relocate."
    ableToRelocate: Boolean
    "List of preferred companies."
    companies: [JobSeekerProfileStructuredDataCompanyInput!]
    "List of preferred company sectors."
    companySectors: [JobSeekerProfileStructuredDataCompanySectorInput!]
    "Preference Id."
    id: ID!
    "List of preferred job titles."
    jobTitles: [JobSeekerProfileStructuredDataJobTitleInput!]
    "List of preferred job types."
    jobTypes: [JobSeekerProfileStructuredDataJobTypeInput!]
    "List of locations that user will prefer to work at."
    locations: [JobSeekerProfileStructuredDataLocationInput!]
    "List of preferred occupations."
    occupations: [JobSeekerProfileStructuredDataOccupationInput!]
    "List of prefered remote/In person work types."
    remoteWorkTypes: [JobSeekerProfileStructuredDataRemoteWorkTypeInput!]
    "Resume Id"
    rezId: ID
    "Salary Input."
    salary: JobSeekerProfileStructuredDataSalaryInput
    "List of preferred shifts."
    shifts: [JobSeekerProfileStructuredDataShiftInput!]
}

input UpdateJobSeekerProfileTaxonomyConceptInput {
    "The label of the taxonomy concept"
    label: String
    "List of section ids of the taxonomy concept"
    sectionIds: [JobSeekerProfileSectionIdsInput!]
    "The suid (5-character String) of the taxonomy concept. e.g. GR7R8"
    suid: ID
    "The type of the taxonomy concept"
    type: String
}

"Input for work experience to be added"
input UpdateJobSeekerProfileWorkExperienceInput {
    "job common skills"
    commonSkills: String
    "job company name"
    company: String
    "job company FccId"
    companyFccid: Int64
    "job company sector"
    companySector: UpdateJobSeekerProfileCompanySectorInput
    "job date range"
    dateRange: JobSeekerProfileDateRangeInput
    "job desciption"
    description: String
    "A Job Seeker's work experience id in hex, e.g. 11EBA84514BECB07A6AE501B0A6880F9"
    id: ID!
    "job location"
    location: JobSeekerProfileLocationTypeInput
    "normalized job title"
    normalizedTitle: String
    "job title"
    title: String
}

" Input type for updateMonthlyBudgetAlerts "
input UpdateMonthlyBudgetAlertsInput {
    " Flag for whether or not monthly budget alerts have been enabled "
    monthlyBudgetAlertsEnabled: Boolean!
}

" Input type for updateProminentOptIn "
input UpdateProminentOptInInput {
    """

    Determines strategy used to send email notifications about new candidates
    true: Only sends email notifications for applications that match job details, such as job description
    false: Sends email notifications for all applications
    """
    prominentOptInEnabled: Boolean!
}

"Parameters for the `updateReviewComment` mutation"
input UpdateReviewCommentInput {
    "The key of the associated review comment"
    key: ID!
    "The full text of the review comment"
    text: String!
}

input UpdateSavedJobStateInput {
    "Job Key to Update"
    jobKey: ID!
    "The new state of the job"
    state: SavedJobState!
}

input UploadJobSeekerProfileFileInput {
    """

    File description
    example: "Main resume"
    """
    description: String
    "User uploaded Multipart file"
    file: Upload!
    "File type that a user uploads to their profile like a resume or cover letter"
    fileType: JobSeekerProfileFileType!
    """

    geoCountry code from indeed website country
    example : US
    """
    geoCountry: String!
    """

    ipCountry code resolved from ipAddress
    example : US
    """
    ipCountry: String!
    """

    File name
    example: "My Resume.pdf"
    """
    name: String
    """

    Tags are arbitrary strings that could be used by front end apps for specific purposes
    example: "['parse:failed', 'parse:sync']
    """
    tags: [String!]
}

"The update status input for an individual document upload from the front end"
input UploadedDocumentStatusInput {
    "The document ID"
    id: String!
    """

    The original name of the file from the user
    (Required on UPLOADED. Optional on DELETED.)
    """
    originalFileName: String
    "The file upload status"
    status: UploadedDocumentStatus!
}

"Create or update the given appointment. If the appointment already exists, it will be updated with the data given."
input UpsertAppointmentInput {
    """

    Plain text description of the appointment up to 4096 characters. If this is not provided, it will simply not be updated.
    In order to clear a description, this must be set to an empty string.
    """
    description: String
    "The endTime for the appointment. Must be greater than startTime."
    endTime: DateTime!
    "The id uniquely identifying this appointment."
    id: CalendarEventIdInput!
    "The start time for the appointment. Must be less than endTime and greater than 1 year ago."
    startTime: DateTime!
    "Plain text summary of the appointment up to 1024 characters."
    summary: String!
}

"""

Input to the [userCalendar] query to retrieve an availability resource of type [UserCalendar].
One and only one of id or indeedAccountId must be provided.
"""
input UserCalendarInput {
    "Globally unique ID of the availability resource. The id MUST be in the format of \"user-calendar:<encrypted indeed account id>\""
    id: ID
    "Indeed account id of user whose calendar is being requested."
    indeedAccountId: IndeedAccountId
}

"Only a single value field will be used as THE value for this custom field.  The value will be decided by the type field."
input UserInteractionCustomLogField {
    "Boolean Value should be populated if type=BOOLEAN"
    booleanValue: Boolean
    "Boolean Values should be populated if type=ARRAY_BOOLEAN"
    booleanValues: [Boolean!]
    "Float Value should be populated if type=FLOAT"
    floatValue: Float
    "Float Values should be populated if type=ARRAY_FLOAT"
    floatValues: [Float!]
    "Int Value should be populated if type=INT"
    intValue: Int
    "Int Values should be populated if type=ARRAY_INT"
    intValues: [Int!]
    "Name of the custom field that will be logged in logrepo"
    name: String!
    "String Value should be populated if type=STRING"
    stringValue: String
    "String Values should be populated if type=ARRAY_STRING"
    stringValues: [String!]
    "Type will be used to know how to treat and validate the value being passed"
    type: UserInteractionCustomLogFieldType!
}

"Input for updateDraftVerificationInfo, where only non-null fields will be updated"
input VerificationInfoInput {
    "Company phone number"
    companyPhoneNumber: String
    "A list of S3 object keys for uploaded business documents"
    documents: [UploadedDocumentStatusInput!]
    "Company headquarters mailing address"
    headquartersMailingAddress: AddressInput
    "The user's personal name"
    name: NameInput
}

"Apply by website."
input WebsiteMethodInput {
    """

    The URL must be a valid URL beginning with 'http://' or 'https://'.
    The maximum length for the url should not exceed 2000 characters.
    """
    url: WebUrl!
}

"Rule that defines a repeating availability period for a specific day of the week."
input WeekAvailabilityRuleInput {
    "Day of the week that this rule applies to."
    dayOfWeek: DayOfWeek!
    """

    End time of the availability.

    The value ranges from 00:00-24:00, where 00:00 represents the beginning of the day and
    24:00 represents the end of the day.

    Value is greater than [startTime]. Resolution is 1 minute.
    """
    endTime: Time!
    """

    Start time of the availability.

    The value ranges from 00:00-24:00, where 00:00 represents the beginning of the day and
    24:00 represents the end of the day.

    Resolution is 1 minute.
    """
    startTime: Time!
}

input WeekAvailabilityRulesFilterInput {
    """

    Duration to split up the weekly availability rules into or null to return all the rules.

    If specified, the weekly availability rules will be divided and returned in periods of the
    given size. The periods will align the highest [StartInterval] that is less than or equal to
    the duration. Resulting periods that are less than the given duration are not
    returned.

    For example, if the calendar has the following availability rules
    `WED 11:15-12:00`, `WED 12:00-13:10`, `THU 09:01-09:31`.
    If the duration is set to 30 minutes, the following rules will be
    returned: `WED 11:30-12:00`, `WED 12:00-12:30`, `WED 12:30-13:00`.
    If the duration is set to 40 minutes, the following periods will be returned:
    `WED 11:30-12:10`, `WED 12:30-13:10`.

    The value has a resolution of 1 minute. Minimum value is 1 minute.
    """
    requiredDuration: Duration
}

input WeekAvailabilityRulesInput {
    rules: [WeekAvailabilityRuleInput!]!
    "Time zone to interpret the availability rules with."
    timezone: ZoneID!
}
